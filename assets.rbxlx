<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="0">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">0</token>
			<string name="CollisionGroups">Default^0^1</string>
			<Ref name="CurrentCamera">1</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<bool name="FilteringEnabled">true</bool>
			<float name="Gravity">196.199997</float>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">true</bool>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="SignalBehavior">2</token>
			<int64 name="SourceAssetId">-1</int64>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>23.5956306</X>
					<Y>10.1296453</Y>
					<Z>-17.1985874</Z>
					<R00>-0.999591947</R00>
					<R01>0.0115538584</R01>
					<R02>-0.0261268653</R02>
					<R10>-0</R10>
					<R11>0.914564669</R11>
					<R12>0.404439986</R12>
					<R20>0.028567547</R20>
					<R21>0.40427494</R21>
					<R22>-0.914191365</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>23.6478844</X>
					<Y>9.3207655</Y>
					<Z>-15.3702049</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Part" referent="2">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-8</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284177243</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Baseplate</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">0</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>2048</X>
					<Y>16</Y>
					<Z>2048</Z>
				</Vector3>
			</Properties>
			<Item class="Texture" referent="3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">1</token>
					<string name="Name">Texture</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<int64 name="SourceAssetId">-1</int64>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://6372755229</url></Content>
					<float name="Transparency">0.800000012</float>
				</Properties>
			</Item>
		</Item>
		<Item class="Terrain" referent="4">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0470588282</R>
					<G>0.329411775</G>
					<B>0.360784322</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="SpawnLocation" referent="5">
			<Properties>
				<bool name="AllowTeamChangeOnTouch">false</bool>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0.5</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<int name="Duration">0</int>
				<bool name="Enabled">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">SpawnLocation</string>
				<bool name="Neutral">true</bool>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<int name="TeamColor">194</int>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>12</X>
					<Y>1</Y>
					<Z>12</Z>
				</Vector3>
			</Properties>
			<Item class="Decal" referent="6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Color3 name="Color3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<token name="Face">1</token>
					<string name="Name">Decal</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxasset://textures/SpawnLocation.png</url></Content>
					<float name="Transparency">0</float>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="7">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Chat" referent="10">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">true</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="11">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="12">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">30</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">30</int>
			<float name="RespawnTime">3</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="13">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TweenService" referent="14">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PermissionsService" referent="15">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="16">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="DEPRECATED_SerializedEmulatedPolicyInfo"></string>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StudioData" referent="17">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">true</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">6531585849</int64>
			<int64 name="SrcUniverseId">2448884957</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="18">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">128</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">false</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="19">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX51B2F12FA63A4A839B19FDE795FA1931">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">TS</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXC698BE4901794C398E18C9E4B2FA56D1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">App</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3A0C1AFECF0E41099CC02EB316588D79">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Typist</string>
							<string name="ScriptGuid">{5FF2F644-6D45-4EE1-BBE8-80984ACF26F1}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "roact").src)
local RunService = TS.import(script, TS.getModule(script, "services")).RunService
local function removeTags(text)
	text = (string.gsub(text, "<br&s*/>", "\n"))
	return string.gsub(text, "<[^<>]->", "")
end
local function now()
	return DateTime.now().UnixTimestampMillis / 1000
end
local function fastWait(n)
	local step = now() + n
	while now() < step do
		RunService.Heartbeat:Wait()
	end
	return n
end
local Typist
do
	Typist = Roact.Component:extend("Typist")
	function Typist:init()
		self.state = {
			maxGraph = 0,
		}
	end
	function Typist:didMount()
		coroutine.wrap(function()
			local displayText = removeTags(self.props.finalText)
			local index = 0
			for first, last in utf8.graphemes(displayText) do
				local _0 = displayText
				local _1 = first
				local _2 = last
				local grapheme = string.sub(_0, _1, _2)
				index += 1
				self:setState({
					maxGraph = index,
				})
				fastWait(self.props.interval)
			end
		end)()
	end
	function Typist:render()
		local current = self.state.maxGraph
		return Roact.createElement("TextLabel", {
			Size = UDim2.new(0, 200, 0, 50),
			RichText = true,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			Text = self.props.finalText,
			MaxVisibleGraphemes = current,
		})
	end
end
return {
	Typist = Typist,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX03CDEE4BCB7A427C80EAADC114A79A90">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">example</string>
						<string name="ScriptGuid">{6A821BCC-3DCC-4369-85EB-6353495A226A}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _0 = TS.import(script, TS.getModule(script, "services"))
local StarterPlayer = _0.StarterPlayer
local Players = _0.Players
local FabricLib = TS.import(script, TS.getModule(script, "fabric").src.FabricLib)
local Remotes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Remotes").default
local Spirit = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit")
local fabric = FabricLib.Fabric.new("Example")
fabric.DEBUG = false
FabricLib.useReplication(fabric)
FabricLib.useTags(fabric)
FabricLib.useBatching(fabric)
fabric:registerUnitsIn(StarterPlayer.StarterPlayerScripts.TS.units)
local ServerCreateHealthPack = Remotes.Client:Get("ServerCreateHealthPack")
ServerCreateHealthPack:Connect(function(healthPack)
	local c = fabric:getOrCreateUnitByRef("Heal", healthPack)
	c:mergeBaseLayer({})
end)
Players.LocalPlayer.CharacterAdded:Wait()
local gunTool = Players.LocalPlayer:WaitForChild("Backpack"):WaitForChild("GunTool")
local gun = fabric:getOrCreateUnitByRef("Gun", gunTool)
gun:mergeBaseLayer({})
Spirit.bind(Enum.KeyCode.M)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX65C0C894406648CBB0F149D93B82B385">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">testtype</string>
						<string name="ScriptGuid">{9AC0C764-0847-4C49-9D02-31F34D337986}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
--[[
	Roact.mount(
	<screengui>
	<Typist
	interval={0.05}
	finalText={'Each event offers <font color ="#ffee59">unique</font> rewards and prizes'}
	></Typist>
	</screengui>,
	Players.LocalPlayer.WaitForChild("PlayerGui"),
	);
]]
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXC8275BDDE9A64D9DAC4FE52F7D9A82E4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">units</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX51DB2FFA58574575A1979E9CFC07D809">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Gun</string>
							<string name="ScriptGuid">{D829071E-9DB9-4ED2-B362-305FCF1F5E95}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Players = TS.import(script, TS.getModule(script, "services")).Players
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local gun = {
	name = "Gun",
	tag = "Gun",
	units = {
		Replicated = {},
	},
	defaults = {
		damage = 0,
		debounce = true,
		mouseDown = false,
		equipped = false,
	},
	onInitialize = function(self)
		local function updateMouseIcon(mouse)
			if mouse ~= nil then
				mouse.Icon = "rbxasset://textures/GunCursor.png"
			end
		end
		local onEquipped = function(mouse)
			updateMouseIcon(mouse)
		end
		local onUnequipped = function()
			updateMouseIcon()
		end
		local tool = self.ref
		tool.Equipped:Connect(onEquipped)
		tool.Unequipped:Connect(onUnequipped)
		tool.Activated:Connect(function()
			if (self:get("debounce")) == true then
				local amount = math.random(10, 50)
				self:getUnit("Transmitter"):sendWithPredictiveLayer({
					damage = amount,
				}, "shoot", amount)
			end
		end)
	end,
	effects = { function(self)
		local tool = self.ref
		local handle = tool:FindFirstChild("Handle")
		handle.Size = Vector3.new(handle.Size.X, self:get("damage"), handle.Size.Z)
	end },
}
return gun
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX15BC4E7E69304E05B0C810527453D82C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Heal</string>
							<string name="ScriptGuid">{407E78FE-5722-4282-81A6-1A2B77F5C560}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local healPackage = {
	name = "Heal",
	tag = "Heal",
	units = {
		Replicated = {
			Blur = 25,
			Bloom = "Hello",
		},
	},
	defaults = {
		debounce = true,
	},
	onInitialize = function(self)
		local model = self.ref
		local part = model.PrimaryPart
		part.BrickColor = BrickColor.new("Teal")
		part.Touched:Connect(function(hit)
			local _0 = hit.Parent
			if _0 ~= nil then
				_0 = _0:FindFirstChild("Humanoid")
			end
			if _0 then
				local amount = math.random(10, 50)
				self:getUnit("Transmitter"):sendWithPredictiveLayer({
					transparency = 1,
					heal = amount,
				}, "heal", amount)
			end
		end)
	end,
}
return healPackage
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3BD5935EF4C344DDBE393DFD3BD21DB3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Luck</string>
							<string name="ScriptGuid">{AF35BE98-A08C-4F6B-931D-BE0DF1ADEF13}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local Luck = {
	name = "Luck",
	units = {
		Replicated = {},
	},
	onInitialize = function(self) end,
}
return Luck
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="20">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="21">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="22">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">4</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="23">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="24">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="25">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="26">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="27">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="28">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="StringValue" referent="29">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">{37C84A65-2DBA-4D20-BB93-3F7A2EBB49AE}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="30">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="31">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="32">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="33">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="34">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="35">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="36">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="37">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="38">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="39">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="40">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXD0533C83BD5D40F9844D92266FC0D153">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">TS</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBX2C7649F6EDA04447BDB8A828DD59BFD1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">runTime</string>
					<string name="ScriptGuid">{69755F5B-329B-4EDB-8F39-4F5543632FE8}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _0 = TS.import(script, TS.getModule(script, "services"))
local ServerScriptService = _0.ServerScriptService
local Workspace = _0.Workspace
local Players = _0.Players
local ReplicatedStorage = _0.ReplicatedStorage
local yieldForR15CharacterDescendants = TS.import(script, TS.getModule(script, "yield-for-character")).yieldForR15CharacterDescendants
local FabricLib = TS.import(script, TS.getModule(script, "fabric").src.FabricLib)
local Remotes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Remotes").default
local ServerCreateHealthPack = Remotes.Server:Create("ServerCreateHealthPack")
local fabric = FabricLib.Fabric.new("Example")
do
	FabricLib.useReplication(fabric)
	FabricLib.useTags(fabric)
	FabricLib.useBatching(fabric)
	fabric:registerUnitsIn(ServerScriptService.TS.units)
	fabric.DEBUG = true
end
local function createHealthPack(character)
	local healthPack = ReplicatedStorage.TS.assets.Heal:Clone()
	healthPack.Parent = Workspace
	local _1 = healthPack
	local _2 = healthPack:GetPrimaryPartCFrame()
	local _3 = healthPack.PrimaryPart.Position
	local _4 = character.HumanoidRootPart.Position
	_1:SetPrimaryPartCFrame(_2 - _3 + _4)
	local c = fabric:getOrCreateUnitByRef("Heal", healthPack)
	c:mergeBaseLayer({})
	c.onUpdated = function(self) end
	ServerCreateHealthPack:SendToAllPlayersExcept(Players:GetPlayerFromCharacter(character), healthPack)
	local _5 = TS.Promise.delay(30)
	local _6 = function()
		healthPack:Destroy()
	end
	_5:andThen(_6)
end
local handleCharacterAdded = TS.async(function(character)
	local rig = TS.await(yieldForR15CharacterDescendants(character))
	rig.Humanoid.Health = 20
	rig.Humanoid.Died:Connect(function()
		createHealthPack(rig)
	end)
	local gunTool = Instance.new("Tool")
	gunTool.Name = "GunTool"
	local _1 = Players:GetPlayerFromCharacter(rig)
	if _1 ~= nil then
		_1 = _1:WaitForChild("Backpack")
	end
	gunTool.Parent = _1
	local handle = Instance.new("Part")
	handle.Parent = gunTool
	handle.Name = "Handle"
	local gun = fabric:getOrCreateUnitByRef("Gun", gunTool)
	gun:mergeBaseLayer({})
end)
local onPlayerAdded = function(player)
	if player.Character then
		handleCharacterAdded(player.Character)
	else
		player.CharacterAdded:Connect(handleCharacterAdded)
	end
end
for _, player in ipairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX44BEDC2C1FEB4375B40F65781A0F4C6A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">testBootstrap</string>
					<string name="ScriptGuid">{5F11E932-3328-447F-BB2A-8C93F215097B}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local ReplicatedStorage = TS.import(script, TS.getModule(script, "services")).ReplicatedStorage
local TestEz = TS.import(script, TS.getModule(script, "testez").src)
local _0 = TestEz.TestBootstrap
local _1 = {}
local _2 = #_1
for _3, _4 in ipairs(ReplicatedStorage.TS.tests:GetChildren()) do
	_1[_2 + _3] = _4
end
_0:run(_1)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX33ECD97166E646D481254326145039B2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">units</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE050D927FB0942598E06A168BA2D0F7A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Gun</string>
						<string name="ScriptGuid">{EF4E6A90-B0E9-418D-8AC7-F21C4BC697F5}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local gun = {
	name = "Gun",
	tag = "Gun",
	units = {
		Replicated = {},
	},
	defaults = {
		damage = 0,
		debounce = true,
		mouseDown = false,
		equipped = false,
	},
	onInitialize = function(self)
		self.fabric:getOrCreateUnitByRef("Luck", self)
	end,
	onClientShoot = function(self, _player, amount)
		local luck = self.fabric:getOrCreateUnitByRef("Luck", self)
		self:addLayer(self, {
			damage = luck:applyLuck(amount),
		})
		local _0 = TS.Promise.delay(5)
		local _1 = function()
			self:removeLayer(self)
		end
		_0:andThen(_1)
	end,
}
return gun
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9BAECDECD09D45E1AF0ADE56E60B1A02">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Heal</string>
						<string name="ScriptGuid">{EA5DA322-63A6-4A2E-BE8E-2D0A1AA993C3}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local RunService = TS.import(script, TS.getModule(script, "services")).RunService
local healPackage = {
	name = "Heal",
	tag = "Heal",
	units = {
		Replicated = {},
	},
	onInitialize = function(self)
		local model = self.ref
		RunService.Heartbeat:Connect(function(dt)
			for _, part in ipairs(model:GetChildren()) do
				if part ~= model.PrimaryPart then
					local Part = part
					local _0 = Part.CFrame
					local _1 = CFrame.Angles(0, math.rad(dt * 37.5), 0)
					Part.CFrame = _0 * _1
				end
			end
		end)
	end,
	onClientHeal = function(self, _player, amount)
		if self:get("debounce") == false then
			return nil
		end
		local _0 = self
		local _1 = self
		local _2 = {
			heal = amount,
		}
		local _3 = "target"
		local _4 = _player.Character
		if _4 ~= nil then
			_4 = _4:FindFirstChild("Humanoid")
		end
		_2[_3] = _4
		_2.debounce = false
		_2.transparency = 1
		_2.particle = false
		_0:addLayer(_1, _2)
		local _5 = TS.Promise.delay(30)
		local _6 = function()
			return self:removeLayer(self)
		end
		_5:andThen(_6)
	end,
	onDestroy = function(self) end,
	effects = { function(self)
		if self:get("target") ~= nil then
			local _0 = (self:get("heal"))
			if _0 == nil then
				_0 = 0
			end
			(self:get("target")).Health += _0
		end
	end, function(self)
		local model = self.ref
		for _, part in ipairs(model:GetChildren()) do
			if part ~= model.PrimaryPart and part:IsA("BasePart") then
				local _0 = (self:get("transparency"))
				if _0 == nil then
					_0 = 0
				end
				part.Transparency = _0
			else
				local _0 = (self:get("particle"))
				if _0 == nil then
					_0 = true
				end
				(part:FindFirstChild("Sparkles")).Enabled = _0
			end
		end
	end },
}
return healPackage
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX56A3BB4E6942442E9B854EFE2AAF73AA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Luck</string>
						<string name="ScriptGuid">{2E50B56D-A7B2-4805-8B79-FC3ABAC243BA}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local Luck = {
	name = "Luck",
	units = {
		Replicated = {},
	},
	onInitialize = function(self) end,
	applyLuck = function(self, layerData)
		local rng = math.random(0, layerData)
		if rng < 25 then
			return layerData
		end
		return 0
	end,
}
return Luck
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="41">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="42">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX5E2325C69C9A4CD9A4BF8710EBB66ADF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">rbxts_include</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX52CFF0B642CA4B34B6F28C5A48B3A4DB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{E6DD6E6A-F4CB-4FA0-B55E-39006D9EB5A0}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {__mode = "k"}

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.
]]
local Error do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(errorStrings, table.concat({
				runtimeError.trace or runtimeError.error,
				runtimeError.context,
			}, "\n"))
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end


local function makeErrorHandler(traceback)
	assert(traceback ~= nil)

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {"Started", "Resolved", "Rejected", "Cancelled"}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
}
Promise.prototype = {}
Promise.__index = Promise.prototype

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(
			self._source,
			callback,
			resolve,
			reject,
			onCancel
		)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self:getStatus())
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.defer(callback)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise._try(debug.traceback(nil, 2), ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					rejectedCount = rejectedCount + 1

					if amount == nil or #promises - rejectedCount < amount then
						cancel()
						done = true

						reject(...)
					end
				end
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

function Promise.fold(list, callback, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(type(callback) == "function", "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return callback(previousValueResolved, resolvedElement, i)
		end)
	end):andThenReturn(accumulator)
end

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, amount)
end

function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(
				function(...)
					resolveOne(i, ...)
				end
			)
		end
	end)
end

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[[
	Iterates serially over the given an array of values, calling the predicate callback on each before continuing.
	If the predicate returns a Promise, we wait for that Promise to resolve before continuing to the next item
	in the array. If the Promise the predicate returns rejects, the Promise from Promise.each is also rejected with
	the same value.

	Returns a Promise containing an array of the return values from the predicate for each item in the original list.
]]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(type(predicate) == "function", string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and type(rawget(rawget(objectMetatable, "__index"), "andThen")) == "function"
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:catch")
	)
	return self:_andThen(debug.traceback(nil, 2), nil, failureCallback)
end

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:finally")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				local maybeRuntimeError = chainedPromise._values[1]

				-- Backwards compatibility < v2
				if chainedPromise._error then
					maybeRuntimeError = Error.new({
						error = chainedPromise._error,
						kind = Error.Kind.ExecutionError,
						context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
					})
				end

				if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
					return self:_reject(maybeRuntimeError:extend({
						error = "This Promise was chained to a Promise that errored.",
						trace = "",
						context = string.format(
							"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
							self._source
						),
					}))
				end

				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format(
				"Unhandled Promise rejection:\n\n%s\n\n%s",
				err,
				self._source
			)

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[[
	Chains a Promise from this one that is resolved if this Promise is
	resolved, and rejected if it is not resolved.
]]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self:getStatus() == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[[
	Retries a Promise-returning callback N times until it succeeds.
]]
function Promise.retry(callback, times, ...)
	assert(type(callback) == "function", "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = {...}, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[[
	Converts an event into a Promise with an optional predicate
]]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(function()
			disconnect()
		end)
	end)
end

return Promise
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2F6B02D2AECA4887847C57BAADEB152D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RuntimeLib</string>
					<string name="ScriptGuid">{573F46E1-2499-4337-8ADF-3CC6A9F56047}</string>
					<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

local TS = {}

-- runtime classes
TS.Promise = Promise

local Symbol
do
	Symbol = {}
	Symbol.__index = Symbol
	setmetatable(
		Symbol,
		{
			__call = function(_, description)
				local self = setmetatable({}, Symbol)
				self.description = "Symbol(" .. (description or "") .. ")"
				return self
			end,
		}
	)

	local symbolRegistry = setmetatable(
		{},
		{
			__index = function(self, k)
				self[k] = Symbol(k)
				return self[k]
			end,
		}
	)

	function Symbol:toString()
		return self.description
	end

	Symbol.__tostring = Symbol.toString

	-- Symbol.for
	function Symbol.getFor(key)
		return symbolRegistry[key]
	end

	function Symbol.keyFor(goalSymbol)
		for key, symbol in pairs(symbolRegistry) do
			if symbol == goalSymbol then
				return key
			end
		end
	end
end

TS.Symbol = Symbol
TS.Symbol_iterator = Symbol("Symbol.iterator")

local function isPlugin(object)
	return RunService:IsStudio() and object:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

-- module resolution
function TS.getModule(object, moduleName)
	if RunService:IsRunning() and object:IsDescendantOf(ReplicatedFirst) then
		warn("roblox-ts packages should not be used from ReplicatedFirst!")
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(object) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local globalModules = script.Parent:FindFirstChild("node_modules")
	if not globalModules then
		error("Could not find any modules!", 2)
	end

	repeat
		local modules = object:FindFirstChild("node_modules")
		if modules and modules ~= globalModules then
			modules = modules:FindFirstChild("@rbxts")
		end
		if modules then
			local module = modules:FindFirstChild(moduleName)
			if module then
				return module
			end
		end
		object = object.Parent
	until object == nil or object == globalModules

	return globalModules:FindFirstChild(moduleName) or error("Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(caller, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error("Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[caller] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error("Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				"Invalid module access! Do you have two TS runtimes trying to import this? " .. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[caller] == module then -- Thread-safe cleanup!
		currentlyLoading[caller] = nil
	end

	return data
end

function TS.exportNamespace(module, ancestor)
	for key, value in pairs(module) do
		ancestor[key] = value
	end
end

-- general utility functions
function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

function TS.add(a, b)
	if type(a) == "string" or type(b) == "string" then
		return a .. b
	else
		return a + b
	end
end

function TS.bit_lrsh(a, b)
	local absA = math.abs(a)
	local result = bit32.rshift(absA, b)
	if a == absA then
		return result
	else
		return -result - 1
	end
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

-- LEGACY RUNTIME FUNCTIONS

local HttpService = game:GetService("HttpService")

-- utility functions
local function copy(object)
	local result = {}
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = {}
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

local function deepCopy(object)
	return deepCopyHelper(object, {})
end

local function deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

-- Object static functions

function TS.Object_keys(object)
	local result = {}
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function TS.Object_values(object)
	local result = {}
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function TS.Object_entries(object)
	local result = {}
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function TS.Object_assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

TS.Object_copy = copy

TS.Object_deepCopy = deepCopy

TS.Object_deepEquals = deepEquals

local function toString(data)
	return HttpService:JSONEncode(data)
end

TS.Object_toString = toString

-- string macro functions
function TS.string_find_wrap(a, b, ...)
	if a then
		return a - 1, b - 1, ...
	end
end

-- array macro functions
local function array_copy(list)
	local result = {}
	for i = 1, #list do
		result[i] = list[i]
	end
	return result
end

TS.array_copy = array_copy

function TS.array_entries(list)
	local result = {}
	for key = 1, #list do
		result[key] = { key - 1, list[key] }
	end
	return result
end

function TS.array_forEach(list, callback)
	for i = 1, #list do
		callback(list[i], i - 1, list)
	end
end

local function array_map(list, callback)
	local result = {}
	for i = 1, #list do
		result[i] = callback(list[i], i - 1, list)
	end
	return result
end

TS.array_map = array_map

function TS.array_mapFiltered(list, callback)
	local new = {}
	local index = 1

	for i = 1, #list do
		local result = callback(list[i], i - 1, list)

		if result ~= nil then
			new[index] = result
			index = index + 1
		end
	end

	return new
end

local function getArraySizeSlow(list)
	local result = 0
	for index in pairs(list) do
		if index > result then
			result = index
		end
	end
	return result
end

function TS.array_filterUndefined(list)
	local length = 0
	local result = {}
	for i = 1, getArraySizeSlow(list) do
		local value = list[i]
		if value ~= nil then
			length = length + 1
			result[length] = value
		end
	end
	return result
end

function TS.array_filter(list, callback)
	local result = {}
	for i = 1, #list do
		local v = list[i]
		if callback(v, i - 1, list) == true then
			result[#result + 1] = v
		end
	end
	return result
end

function TS.array_sort(list, callback)
	table.sort(list, callback)
	return list
end

TS.array_toString = toString

function TS.array_slice(list, startI, endI)
	local length = #list

	if startI == nil then startI = 0 end
	if endI == nil then endI = length end

	if startI < 0 then startI = length + startI end
	if endI < 0 then endI = length + endI end

	local result = {}

	for i = startI + 1, endI do
		result[i - startI] = list[i]
	end

	return result
end

function TS.array_splice(list, start, deleteCount, ...)
	local len = #list
	local actualStart
	if start < 0 then
		actualStart = len + start
		if actualStart < 0 then
			actualStart = 0
		end
	else
		if start < len then
			actualStart = start
		else
			actualStart = len
		end
	end
	local items = { ... }
	local itemCount = #items
	local actualDeleteCount
	if start == nil then
		actualDeleteCount = 0
	elseif deleteCount == nil then
		actualDeleteCount = len - actualStart
	else
		if deleteCount < 0 then
			deleteCount = 0
		end
		actualDeleteCount = len - actualStart
		if deleteCount < actualDeleteCount then
			actualDeleteCount = deleteCount
		end
	end
	local out = {}
	local k = 0
	while k < actualDeleteCount do
		local from = actualStart + k
		if list[from + 1] then
			out[k + 1] = list[from + 1]
		end
		k = k + 1
	end
	if itemCount < actualDeleteCount then
		k = actualStart
		while k < len - actualDeleteCount do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from + 1] then
				list[to + 1] = list[from + 1]
			else
				list[to + 1] = nil
			end
			k = k + 1
		end
		k = len
		while k > len - actualDeleteCount + itemCount do
			list[k] = nil
			k = k - 1
		end
	elseif itemCount > actualDeleteCount then
		k = len - actualDeleteCount
		while k > actualStart do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from] then
				list[to] = list[from]
			else
				list[to] = nil
			end
			k = k - 1
		end
	end
	k = actualStart
	for i = 1, #items do
		list[k + 1] = items[i]
		k = k + 1
	end
	k = #list
	while k > len - actualDeleteCount + itemCount do
		list[k] = nil
		k = k - 1
	end
	return out
end

function TS.array_some(list, callback)
	for i = 1, #list do
		if callback(list[i], i - 1, list) == true then
			return true
		end
	end
	return false
end

function TS.array_every(list, callback)
	for i = 1, #list do
		if not callback(list[i], i - 1, list) then
			return false
		end
	end
	return true
end

function TS.array_includes(list, item, startingIndex)
	for i = (startingIndex or 0) + 1, #list do
		if list[i] == item then
			return true
		end
	end
	return false
end

function TS.array_indexOf(list, value, fromIndex)
	for i = (fromIndex or 0) + 1, #list do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_lastIndexOf(list, value, fromIndex)
	for i = (fromIndex or #list - 1) + 1, 1, -1 do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_reverse(list)
	local result = {}
	local length = #list
	local n = length + 1
	for i = 1, length do
		result[i] = list[n - i]
	end
	return result
end

function TS.array_reduce(list, callback, ...)
	local first = 1
	local last = #list
	local accumulator
	-- support `nil` initialValues
	if select("#", ...) == 0 then
		if last == 0 then
			error("Reduce of empty array with no initial value at Array.reduce", 2)
		end
		accumulator = list[first]
		first = first + 1
	else
		accumulator = ...
	end
	for i = first, last do
		accumulator = callback(accumulator, list[i], i - 1, list)
	end
	return accumulator
end

function TS.array_reduceRight(list, callback, ...)
	local first = #list
	local last = 1
	local accumulator
	-- support `nil` initialValues
	if select("#", ...) == 0 then
		if first == 0 then
			error("Reduce of empty array with no initial value at Array.reduceRight", 2)
		end
		accumulator = list[first]
		first = first - 1
	else
		accumulator = ...
	end
	for i = first, last, -1 do
		accumulator = callback(accumulator, list[i], i - 1, list)
	end
	return accumulator
end

function TS.array_unshift(list, ...)
	local n = #list
	local argsLength = select("#", ...)
	for i = n, 1, -1 do
		list[i + argsLength] = list[i]
	end
	for i = 1, argsLength do
		list[i] = select(i, ...)
	end
	return n + argsLength
end

local function array_push_apply(list, ...)
	local len = #list
	for i = 1, select("#", ...) do
		local list2 = select(i, ...)
		local len2 = #list2
		for j = 1, len2 do
			list[len + j] = list2[j]
		end
		len = len + len2
	end
	return len
end

TS.array_push_apply = array_push_apply

function TS.array_push_stack(list, ...)
	local len = #list
	local len2 = select("#", ...)
	for i = 1, len2 do
		list[len + i] = select(i, ...)
	end
	return len + len2
end

function TS.array_concat(...)
	local result = {}
	array_push_apply(result, ...)
	return result
end

function TS.array_join(list, separator)
	return table.concat(array_map(list, tostring), separator or ",")
end

function TS.array_find(list, callback)
	for i = 1, #list do
		local v = list[i]
		if callback(v, i - 1, list) == true then
			return v
		end
	end
end

function TS.array_findIndex(list, callback)
	for i = 0, #list - 1 do
		if callback(list[i + 1], i, list) == true then
			return i
		end
	end
	return -1
end

local function array_flat_helper(list, depth, count, result)
	for i = 1, #list do
		local v = list[i]

		if type(v) == "table" and depth ~= 0 then
			count = array_flat_helper(v, depth - 1, count, result)
		else
			count = count + 1
			result[count] = v
		end
	end

	return count
end

function TS.array_flat(list, depth)
	local result = {}
	array_flat_helper(list, depth or 1, 0, result)
	return result
end

function TS.array_fill(list, value, from, to)
	local length = #list

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	for i = from + 1, to do
		list[i] = value
	end

	return list
end

function TS.array_copyWithin(list, target, from, to)
	local length = #list

	if target < 0 then
		target = target + length
	end

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	local tf = target - from
	local overshoot = to + tf - length

	if overshoot > 0 then
		to = from + length - target
	end

	for i = to, from + 1, -1 do
		list[i + tf] = list[i]
	end

	return list
end

TS.array_deepCopy = deepCopy

TS.array_deepEquals = deepEquals

-- map macro functions

function TS.map_new(pairs)
	local result = {}
	if pairs then
		for i = 1, #pairs do
			local pair = pairs[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

TS.Object_fromEntries = TS.map_new

function TS.map_clear(map)
	for key in pairs(map) do
		map[key] = nil
	end
end

local function getNumKeys(map)
	local result = 0
	for _ in pairs(map) do
		result = result + 1
	end
	return result
end

TS.map_size = getNumKeys
TS.map_entries = TS.Object_entries

function TS.map_forEach(map, callback)
	for key, value in pairs(map) do
		callback(value, key, map)
	end
end

TS.map_keys = TS.Object_keys

TS.map_values = TS.Object_values
TS.map_toString = toString

-- set macro functions

function TS.set_new(values)
	local result = {}
	if values then
		for i = 1, #values do
			result[values[i]] = true
		end
	end
	return result
end

TS.set_clear = TS.map_clear

function TS.set_forEach(set, callback)
	for key in pairs(set) do
		callback(key, key, set)
	end
end

function TS.set_union(set1, set2)
	local result = {}

	for value in pairs(set1) do
		result[value] = true
	end

	for value in pairs(set2) do
		result[value] = true
	end

	return result
end

function TS.set_intersect(set1, set2)
	local result = {}

	for value in pairs(set1) do
		if set2[value] then
			result[value] = true
		end
	end

	return result
end

function TS.set_isDisjointWith(set1, set2)
	for value in pairs(set1) do
		if set2[value] then
			return false
		end
	end
	return true
end

function TS.set_isSubsetOf(set1, set2)
	for value in pairs(set1) do
		if set2[value] == nil then
			return false
		end
	end

	return true
end

function TS.set_difference(set1, set2)
	local result = {}
	for value in pairs(set1) do
		if set2[value] == nil then
			result[value] = true
		end
	end
	return result
end

TS.set_values = TS.Object_keys

TS.set_size = getNumKeys

TS.set_toString = toString

function TS.string_startsWith(str1, str2, pos)
	local n1 = #str1
	local n2 = #str2

	if pos == nil or pos ~= pos then
		pos = 0
	else
		pos = math.clamp(pos, 0, n1)
	end

	local last = pos + n2
	return last <= n1 and string.sub(str1, pos + 1, last) == str2
end

function TS.string_endsWith(str1, str2, pos)
	local n1 = #str1
	local n2 = #str2

	if pos == nil then
		pos = n1
	elseif pos ~= pos then
		pos = 0
	else
		pos = math.clamp(pos, 0, n1)
	end

	local start = pos - n2 + 1
	return start > 0 and string.sub(str1, start, pos) == str2
end

-- spread cache functions
function TS.string_spread(str)
	local results = {}
	local count = 0
	for char in string.gmatch(str, "[%z\1-\127\194-\244][\128-\191]*") do
		count = count + 1
		results[count] = char
	end
	return results
end

function TS.iterableCache(iter)
	local results = {}
	local count = 0
	for _0 in iter.next do
		if _0.done then break end
		count = count + 1
		results[count] = _0.value
	end
	return results
end

local function package(...)
	return select("#", ...), { ... }
end

function TS.iterableFunctionCache(iter)
	local results = {}
	local count = 0

	while true do
		local size, t = package(iter())
		if size == 0 then break end
		count = count + 1
		results[count] = t
	end

	return results
end

-- roact functions

function TS.Roact_combine(...)
	local args = { ... }
	local result = {}
	for i = 1, #args do
		for key, value in pairs(args[i]) do
			if (type(key) == "number") then
				table.insert(result, value)
			else
				result[key] = value
			end
		end
	end
	return result
end

-- opcall

function TS.opcall(func, ...)
	local success, valueOrErr = pcall(func, ...)
	if success then
		return {
			success = true,
			value = valueOrErr,
		}
	else
		return {
			success = false,
			error = valueOrErr,
		}
	end
end

return TS
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX02F286FD3A4C40AE836DB38B8DA694D1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">node_modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX3D4530E2B3434AFE9ECCA3F43BC27340">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">compiler-types</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX9E056D468CAC4C4F9E5DB3E29F802646">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8F82C42F70C140D0BF1F7C272FDB247C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">fabric</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX994DBC1CFB7D4619B9EB057EB53B87A6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">src</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX3074A1C197104A679715A6720E8CC4F3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FabricLib</string>
								<string name="ScriptGuid">{9B0F3A65-2FF4-4466-A253-FC3D24A625FD}</string>
								<ProtectedString name="Source"><![CDATA[return {
	Fabric = require(script.Fabric);
	useTags = require(script.Tags);
	useReplication = require(script.Replication);
	useRoact = require(script.Roact);
	useServiceUnits = require(script.ServiceUnits);
	useBatching = require(script.Batching);
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX80F2C7CBA9B243C09A91898352C294BA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Batching</string>
									<string name="ScriptGuid">{FD930A21-2D90-4421-8652-EA22C2065D58}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

--[[
	Looks for a batch key inside of components

	If is true or function, we maintain an array of all of the components
	We add a function to fabric which lets you retrieve this array
	If function, we call it on component registration to determine the events you want to do
]]
local Promise = require(script.Parent.Parent.Promise)
local SinglePromiseEvent = require(script.SinglePromiseEvent)

local dt = 1 / 60

RunService.Heartbeat:Connect(function(step)
	dt = step
end)

local batchConstructors = {
	event = function(event, callback)
		return {
			event = event,
			callback = callback
		}
	end,

	interval = function(duration, callback)
		local intervalEvent = SinglePromiseEvent.new(function(fire)
			return function(_, _, isCancelled)
				local loop

				loop = function()
					return Promise.try(fire):andThenCall(Promise.delay, duration):andThen(function()
						if not isCancelled() then
							return loop()
						end
					end)
				end

				loop()
			end
		end)

		return {
			event = intervalEvent,
			callback = callback
		}
	end,

	spreadInterval = function(duration, callbackCreator)
		local isReady = true
		local needsRestart = false
		local loop

		local intervalEvent = SinglePromiseEvent.new(function(fire)
			return function(_, _, isCancelled)
				loop = function()
					isReady = false

					return Promise.try(fire):andThenCall(Promise.delay, duration):andThen(function()
						if not isCancelled() then
							if isReady then
								return loop()
							else
								needsRestart = true
							end
						end
					end)
				end

				loop()
			end
		end)

		local function becomeReady()
			isReady = true

			if needsRestart then
				needsRestart = false

				loop()
			end
		end

		return {
			event = intervalEvent,
			callback = function(list)
				local callback = callbackCreator()

				local listCopy = {}
				for idx, unit in ipairs(list) do
					listCopy[idx] = unit
				end

				local copyIdx = 1
				local currentIdx = 1
				local seen = 0

				local function stepIdx()
					-- updates indices to match expeted positions
					if copyIdx <= #listCopy and listCopy[copyIdx] ~= list[currentIdx] then
						currentIdx = table.find(list, listCopy[copyIdx]) or currentIdx
					end

					local val = list[currentIdx]
					currentIdx = math.min(#list + 1, currentIdx + 1)
					copyIdx = math.min(#listCopy + 1, copyIdx + 1)
					if val then
						seen += 1
					end
					return val -- return next value to use
				end

				local currentTime = 0
				while currentTime <= duration do
					local remainingUnits = #list - seen
					local remainingTime = duration - currentTime
					local timePerUpdate = remainingTime / remainingUnits -- time we spend per future update (assuming even distribution)
					local updatesToDoNow = math.ceil(dt/timePerUpdate) -- if timePerUpdate < 1, we need to do more than 1 unit of work/frame - so we batch

					local p = Promise.delay(timePerUpdate):andThen(function(timeTaken)
						currentTime += timeTaken
					end)
					for _ = 1, updatesToDoNow do
						local nextUnit = stepIdx()
						if nextUnit then
							local ok, errorValue = coroutine.resume(coroutine.create(callback), nextUnit)

							if not ok then
								warn(errorValue)
							end
						end
					end
					p:await()
				end
				-- failsafe - if we have remaining units to update, we do them now
				if seen < #list then
					for i = seen, #list do
						local ok, errorValue = coroutine.resume(coroutine.create(callback), list[i])

						if not ok then
							warn(errorValue)
						end
					end
				end
				becomeReady()
			end,
		}
	end
}

return function (fabric)
	local batches = {}
	local unitToListeners = {}

	local function setupBatching(staticUnit)
		local unitName = staticUnit.name

		if unitToListeners[unitName] then
			for _, listener in ipairs(unitToListeners[unitName]) do
				listener:Disconnect()
			end

			unitToListeners[unitName] = nil
		end

		if staticUnit.batch then
			-- add listener effect
			staticUnit.effects = staticUnit.effects or {}
			staticUnit.effects._batchListener = function(self)
				batches[unitName] = batches[unitName] or {}
				if self._batchArray == batches[unitName] then
					return
				end

				if unitToListeners[unitName] == nil and typeof(staticUnit.batch) == "function" then
					unitToListeners[unitName] = {}

					for _, listenerDefinition in ipairs(staticUnit.batch(batchConstructors)) do
						table.insert(unitToListeners[unitName], listenerDefinition.event:Connect(function()
							listenerDefinition.callback(batches[unitName])
						end))
					end
				end

				self._batchArray = batches[unitName]

				table.insert(self._batchArray, self)

				self:on("destroy", function()
					table.remove(self._batchArray, table.find(self._batchArray, self))

					if #self._batchArray == 0 then
						for _, listener in ipairs(unitToListeners[unitName]) do
							listener:Disconnect()
						end

						batches[unitName] = nil
						unitToListeners[unitName] = nil
					end
				end)
			end
		end
	end

	fabric:on("unitRegistered", setupBatching)
	fabric:on("unitHotReloaded", setupBatching)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX5FEF5DB72F7E4C57945A90E0F2C49C4C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">SinglePromiseEvent</string>
										<string name="ScriptGuid">{C6B2FF0C-0575-4FDB-9AE9-054EA116E6DF}</string>
										<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Parent.Promise)

local SinglePromiseEvent = {}
SinglePromiseEvent.__index = SinglePromiseEvent

function SinglePromiseEvent.new(executor)
	local self = setmetatable({
		_listener = nil,
	}, SinglePromiseEvent)

	local function fire()
		if self._listener then
			coroutine.wrap(self._listener)()
		end
	end

	self._promise = Promise.defer(function(resolve)
		resolve(Promise.new(executor(fire)):andThen(function()
			self._listener = nil
		end))
	end)

	return self
end

function SinglePromiseEvent:Connect(callback)
	assert(self._listener == nil, "SinglePromiseEvent is already used up")
	assert(self._promise:getStatus() == "Started", "SinglePromiseEvent is already used up")

	self._listener = callback
	return {
		Disconnect = function()
			self._promise:cancel()
			self._listener = nil
		end
	}
end

return SinglePromiseEvent]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCA7AEE7839D344FEB86893704FCE12D7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">init.spec</string>
										<string name="ScriptGuid">{9014DDDA-F6BA-40D3-82A7-C25ED41402F8}</string>
										<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Parent.Promise)
local FabricLib = require(script.Parent.Parent)
local Fabric = FabricLib.Fabric

return function()
	if true then return end

	local fabric, event

	local function makeUnitDefinition(callback)
		return {
			name = "test";
			batch = function(on)
				return {
					on.event(event.Event, callback)
				}
			end
		}
	end

	beforeEach(function()
		fabric = Fabric.new("batching")
		FabricLib.useBatching(fabric)
		event = Instance.new("BindableEvent")
	end)

	describe("Batching", function()
		it("should loop over everything", function()
			local refs = {}
			for i = 1, 10 do
				refs[i] = {}
			end

			local hasRan = false
			local staticUnit = makeUnitDefinition(function(list)
				expect(#list).to.equal(#refs)
				hasRan = true
				for _, unit in ipairs(list) do
					unit:mergeBaseLayer({
						testValue = true
					})
				end
			end)
			fabric:registerUnit(staticUnit)

			for _, ref in ipairs(refs) do
				fabric:getOrCreateUnitByRef(staticUnit, ref):mergeBaseLayer({})
			end

			event:Fire() -- ☠️🏴
			expect(hasRan).to.equal(true)

			for _, ref in ipairs(refs) do
				expect(fabric:getUnitByRef(staticUnit, ref):get("testValue")).to.be.ok()
			end
		end)

		it("should remove refs from batch on destruction", function()
			local refs = {}
			for i = 1, 10 do
				refs[i] = {}
			end

			local hasRan = false
			local staticUnit = makeUnitDefinition(function(list)
				expect(#list).to.equal(#refs - 1)
				hasRan = true
				for _, unit in ipairs(list) do
					unit:mergeBaseLayer({
						testValue = true
					})
				end
			end)
			fabric:registerUnit(staticUnit)

			for _, ref in ipairs(refs) do
				fabric:getOrCreateUnitByRef(staticUnit, ref):mergeBaseLayer({})
			end
			fabric:removeAllUnitsWithRef(refs[1])

			event:Fire() -- ☠️🏴
			expect(hasRan).to.equal(true)
		end)

		it("should fire every interval", function()
			local times = {}
			local intervalUnit = {
				name = "test";
				batch = function(on)
					return {
						on.interval(1/6, function(list)
							list[1]:mergeBaseLayer({
								testValue = list[1]:get("testValue") + 1
							})
							table.insert(times, os.clock())
						end)
					}
				end
			}
			fabric:registerUnit(intervalUnit)

			local ref = {}
			local unit = fabric:getOrCreateUnitByRef(intervalUnit, ref)
			unit:mergeBaseLayer({
				testValue = 0
			})
			Promise.delay(5.2/6):await()

			expect(math.abs(unit:get("testValue") - 5) <= 1).to.equal(true)
			fabric:removeAllUnitsWithRef(ref)
		end)
	end)

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX83B146853B6840E39C9584FE18300490">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Fabric</string>
									<string name="ScriptGuid">{32F1F695-F294-4E59-8C53-44BC3C8DB95F}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local DEFAULT_NAMESPACE = "game"

local Promise = require(script.Parent.Parent.Promise)

local UnitCollection = require(script.UnitCollection)
local Reactor = require(script.Reactor)
local Serializer = require(script.Serializer)
local HotReloader = require(script.HotReloader)
local Symbol = require(script.Parent.Shared.Symbol)

local Fabric = {
	reducers = require(script.Operators.Reducers);
	comparators = require(script.Operators.Comparators);
	t = require(script.Parent.Parent.t);
	DEBUG = true;
	Heartbeat = RunService.Heartbeat;
	None = Symbol.named("None");
	Unit = setmetatable({}, {
		__index = function(_, key)
			error(("Unit %q is not registered!"):format(key))
		end
	});
}
Fabric.__index = Fabric

function Fabric.new(namespace)
	local self = setmetatable({
		namespace = namespace or DEFAULT_NAMESPACE;
		_listeners = {};
	}, Fabric)

	self.serializer = Serializer.new(self)
	self._collection = UnitCollection.new(self)
	self._reactor = Reactor.new(self)

	if RunService:IsStudio() then
		self._hotReloader = HotReloader.new(self)
	end

	return self
end

--[=[
	Registers a unit. This function should be called before attempting to get or create the unit.

	@param unitDefinition UnitDefinition -- The definition of the unit
	@return UnitDefinition -- The passed unit definition
]=]
function Fabric:registerUnit(unitDefinition)
	assert(unitDefinition ~= nil, "unitDefinition is nil")
	self._collection:register(unitDefinition)

	self:fire("unitRegistered", unitDefinition)

	return unitDefinition
end

--[=[
	Registers all units that are immmediate children of a container.
	Skips any test scripts (i.e. name of form `*.spec`) in the container.

	@param container Instance -- The container
	@return nil
]=]
function Fabric:registerUnitsIn(container)
	for _, object in ipairs(container:GetChildren()) do
		if object:IsA("ModuleScript") then
			if not object.Name:match("%.spec$") then
				local unitDefinition = require(object)

				if unitDefinition.name == nil then
					unitDefinition.name = object.Name
				end

				self:registerUnit(unitDefinition)

				if self._hotReloader then
					self._hotReloader:giveModule(object, unitDefinition)
				end
			end
		else
			self:registerUnitsIn(object)
		end
	end
end

--[=[
	Returns the unit associated with a unit resolvable that is attached to a ref,
	or nil if it doesn't exist.

	@param unitResolvable UnitResolvable -- The unit to retrieve
	@param ref Ref -- The ref to retrieve the unit from
	@return Unit? -- The attached unit
]=]
function Fabric:getUnitByRef(unitResolvable, ref)
	return self._collection:getUnitByRef(unitResolvable, ref)
end

--[=[
	Returns the unit associated with a unit resolvable that is attached to ref.
	If it does not exist, then creates and attaches the unit to ref and returns it.

	@param unitResolvable UnitResolvable -- The unit to retrieve
	@param ref Ref -- The ref to retrieve the attached unit from
	@return Unit -- The attached unit
]=]
function Fabric:getOrCreateUnitByRef(unitResolvable, ref)
	return self._collection:getOrCreateUnitByRef(unitResolvable, ref)
end

function Fabric:getLoadedUnitByRef(unitResolvable, ref)
	local unit = self._collection:getUnitByRef(unitResolvable, ref)

	if unit == nil then
		error(("Attempt to get loaded unit %q on %s, but it does not exist."):format(
			tostring(unitResolvable),
			tostring(ref)
		))
	end

	if not (unit._loaded or unit._loading) then
		error(("Attempt to call getLoadedUnitByRef on %q on %s, but it will never be loaded."):format(
			tostring(unitResolvable),
			tostring(ref)
		))
	end

	return Promise.new(function(resolve, reject)
		if unit._loaded then
			return resolve(unit)
		else
			unit:on("loaded", function()
				resolve(unit)
			end)

			-- This must be fired by the user. It's not fired anywhere inside the Fabric library.
			unit:on("loadingFailed", function(...)
				reject(...)
			end)
		end
	end)
end

--[=[
	Removes all units attached to the passed ref.

	@param ref Ref -- The ref to remove all units from
	@return nil
]=]
function Fabric:removeAllUnitsWithRef(ref)
	self._collection:removeAllUnitsWithRef(ref)
end

--[=[
	Fires a fabric event.

	@param eventName string -- The event name to fire
	@param ... any -- The arguments to fire the event with.
	@return nil
]=]
function Fabric:fire(eventName, ...)
	if not self._listeners[eventName] then
		return -- Do nothing if no listeners registered
	end

	for _, callback in ipairs(self._listeners[eventName]) do
		local success, errorValue = coroutine.resume(coroutine.create(callback), ...)

		if not success then
			warn(("Event listener for %s encountered an error: %s"):format(
				tostring(eventName),
				tostring(errorValue)
			))
		end
	end
end

--[=[
	Listens to a fabric event.

	@param eventName string -- The event name to listen to
	@param callback function -- The callback fired
	@return nil
]=]
function Fabric:on(eventName, callback)
	self._listeners[eventName] = self._listeners[eventName] or {}
	table.insert(self._listeners[eventName], callback)

	return function()
		for i, listCallback in ipairs(self._listeners[eventName]) do
			if listCallback == callback then
				table.remove(self._listeners[eventName], i)
				break
			end
		end
	end
end

--[=[
	Logs a debug message. Set fabric.DEBUG = true to enable.

	@param ... any -- The debug information to log
	@return nil
]=]
function Fabric:debug(...)
	if self.DEBUG then
		warn("[Fabric]", ...)
	end
end

return Fabric]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX06953085C28E4030899C760343B8615F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">BuiltInSerializers</string>
										<string name="ScriptGuid">{3F333142-BDFE-4C67-A2EC-44841505BFD9}</string>
										<ProtectedString name="Source"><![CDATA[local Unit = require(script.Parent.Unit)

return {
	serializers = {
		[Unit] = function(unit, fabric)

			return {
				type = "_unit";
				name = unit.name;
				ref = fabric.serializer:serialize(unit.ref);
			}
		end
	};

	deserializers = {
		_unit = function(data, fabric, failMode)
			local ref = fabric.serializer:deserialize(data.ref)

			if failMode == fabric.serializer.FailMode.Error then
				assert(ref ~= nil, ("Attempt to deserialize a %q unit on a ref that's not present in this realm."):format(
					tostring(data.name)
				))
			end

			local unit = fabric._collection:getUnitByRef(data.name, ref)

			if unit == nil and failMode == fabric.serializer.FailMode.Error then
				error(
					("Attempt to deserialize unit %q on %q, but it does not exist in this realm."):format(
						tostring(data.name),
						tostring(ref)
					)
				)
			end

			return unit
		end
	};
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX02D67B4E9A3F47268D73CB24F3D4CFA2">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">HotReloader</string>
										<string name="ScriptGuid">{38A7BDB0-ACD3-46CE-9DB5-49998490A68C}</string>
										<ProtectedString name="Source"><![CDATA[local HotReloader = {}
HotReloader.__index = HotReloader

function HotReloader.new(fabric)
	return setmetatable({
		fabric = fabric;
		staticUnits = {};
	}, HotReloader)
end

function HotReloader:giveModule(module, initialValue)
	self.staticUnits[module] = initialValue

	module.Changed:Connect(function()
		local newStaticUnit = require(module:Clone())
		local oldStaticUnit = self.staticUnits[module]

		if newStaticUnit.name == nil then
			newStaticUnit.name = module.Name
		end

		self.fabric._collection:register(newStaticUnit, true)
		self.fabric:fire("unitHotReloaded", newStaticUnit)

		local count = 0
		for _, unitMap in pairs(self.fabric._collection._refUnits) do
			if unitMap[oldStaticUnit] then
				unitMap[newStaticUnit] = unitMap[oldStaticUnit]
				unitMap[oldStaticUnit] = nil

				setmetatable(unitMap[newStaticUnit], newStaticUnit)
				unitMap[newStaticUnit]:fire("hotReloaded")

				local ok, errorValue = xpcall(function()
					unitMap[newStaticUnit]:_runEffects()
				end, function(innerErrorValue)
					return debug.traceback(innerErrorValue)
				end)

				if not ok then
					warn(("Effects of %s encountered an error during hot reloading:\n\n%s"):format(
						tostring(unitMap[newStaticUnit]),
						tostring(errorValue)
					))
				end

				count += 1
			end
		end

		self.staticUnits[module] = newStaticUnit

		self.fabric:debug("[Hot Reload]", module.Name, "->", count, "units")
	end)
end

return HotReloader
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBX54BC2AD5785849E9BB14A0DBE02DD364">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">Operators</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX5E44BA2D2F6E42D28A9FB0191F0FC661">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Comparators</string>
											<string name="ScriptGuid">{931983CB-0CDF-464B-A7FC-97CE2DC66211}</string>
											<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Parent.Shared.Util)

local COMPARATOR_NEAR_DEFAULT = 0.001

local Comparators = {}

function Comparators.reference(a, b)
	return a ~= b
end

function Comparators.value(a, b)
	return not Util.deepEquals(a, b)
end

function Comparators.within(epsilon)
	return function(a, b)
		return math.abs(a - b) > epsilon
	end
end

function Comparators.structure(propertyComparators)
	return function (a, b)
		for _, item in ipairs({a, b}) do
			for key in pairs(item) do
				if (propertyComparators[key] or Comparators.default)(a and a[key], b and b[key]) then
					return true
				end
			end
		end

		return false
	end
end

Comparators.near = Comparators.within(COMPARATOR_NEAR_DEFAULT)

Comparators.default = Comparators.reference

return Comparators
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX1A2259F3A3DC445ABC5D90493064D43B">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Comparators.spec</string>
											<string name="ScriptGuid">{BC67991B-FFA5-4378-B38B-424AD330E8AA}</string>
											<ProtectedString name="Source"><![CDATA[local Comparators = require(script.Parent.Comparators)
local Util = require(script.Parent.Parent.Parent.Shared.Util)

local COMPARATOR_NEAR_DEFAULT = 0.001

return function ()
	describe("Comparators", function()
		it("should compare by reference", function()
			expect(Comparators.reference(1, 1)).to.equal(false)
			expect(Comparators.reference(1, 2)).to.equal(true)
			expect(Comparators.reference({}, {})).to.equal(true)

			local a = {}
			expect(Comparators.reference(a, a)).to.equal(false)
		end)

		it("should compare by value", function()
			expect(Comparators.value(1, 1)).to.equal(false)
			expect(Comparators.value(1, 2)).to.equal(true)
			expect(Comparators.value({}, {})).to.equal(false)
			expect(Comparators.value({1}, {1})).to.equal(false)
			expect(Comparators.value({1}, {2})).to.equal(true)

			local a = {}
			expect(Comparators.value(a, a)).to.equal(false)

			expect(Comparators.value({key = 1}, {key = 1})).to.equal(false)
			expect(Comparators.value({key = 1}, {key = 2})).to.equal(true)

			local nested = {key = 1, sub = {subkey = "hello"}}
			local nestedCopy = Util.deepCopy(nested)
			expect(Comparators.value(nested, nestedCopy)).to.equal(false)
		end)

		it("should compare within a range", function()
			expect(Comparators.within(1)(1, 5)).to.equal(true)
			expect(Comparators.within(1)(1, 1.5)).to.equal(false)

			expect(COMPARATOR_NEAR_DEFAULT > 0).to.equal(true)
			expect(Comparators.near(0, COMPARATOR_NEAR_DEFAULT/2)).to.equal(false)
			expect(Comparators.near(0, COMPARATOR_NEAR_DEFAULT*2)).to.equal(true)
		end)
	end)

	describe("Comparator utilities", function()
		it("should compare by property", function()
			local compare = Comparators.structure({
				reference = Comparators.reference;
				value = Comparators.value;
				near = Comparators.near;
			})

			local t = { x = 1 }

			expect(compare({
				reference = t;
				value = t;
				near = 0;
			}, {
				reference = t;
				value = { x = 1 };
				near = 0.0001;
			})).to.equal(false)

			expect(compare({
				reference = t;
				new = 5;
			}, {
				reference = t;
			})).to.equal(true)
		end)
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXB0C95E96B8FC49609725795C1F577350">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Reducers</string>
											<string name="ScriptGuid">{DDC56396-18CD-44F7-8C5D-D50BA4356CAC}</string>
											<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Parent.Shared.Util)

local Reducers = {}

function Reducers.last(values)
	return values[#values]
end

function Reducers.first(values)
	return values[1]
end

function Reducers.truthy(values)
	for _, value in ipairs(values) do
		if value then
			return value
		end
	end
end

function Reducers.falsy(values)
	for _, value in ipairs(values) do
		if not value then
			return value
		end
	end
end

function Reducers.add(values)
	local reducedValue = 0

	for _, value in ipairs(values) do
		reducedValue = reducedValue + value
	end

	return reducedValue
end

function Reducers.multiply(values)
	local reducedValue = 1

	for _, value in ipairs(values) do
		reducedValue = reducedValue * value
	end

	return reducedValue
end

function Reducers.concatArray(values)
	return Util.concat(unpack(values))
end

function Reducers.collect(values)
	return values
end

function Reducers.lowest(values)
	if #values == 0 then
		return
	end

	return math.min(unpack(values))
end

function Reducers.highest(values)
	if #values == 0 then
		return
	end

	return math.max(unpack(values))
end

function Reducers.mergeTable(values)
	return Util.assign({}, unpack(values))
end

-- Utilities

function Reducers.concatString(delim)
	return function (values)
		return table.concat(values, delim or "")
	end
end

function Reducers.priorityValue(reducer)
	reducer = reducer or Reducers.last

	return function (values)

		local highestPriority = -math.huge
		local highestPriorityValues = {}

		for _, struct in ipairs(values) do
			if struct.priority > highestPriority then
				highestPriorityValues = {struct.value}
			elseif struct.priority == highestPriority then
				table.insert(highestPriorityValues, struct.value)
			end
		end

		return reducer(highestPriorityValues)
	end
end

function Reducers.structure(reducers, default)
	local passthrough = reducers == nil and default == nil

	if default == nil then
		default = Reducers.last
	end

	return function(values)
		if passthrough then
			if #values == 1 then
				return values[1]
			else
				return Util.assign({}, unpack(values))
			end
		end

		local properties = {}

		for _, value in ipairs(values) do
			for propName, propValue in pairs(value) do
				if properties[propName] == nil then
					properties[propName] = {}
				end

				table.insert(properties[propName], propValue)
			end
		end

		local reducedValue = {}

		for propName, propValues in pairs(properties) do
			reducedValue[propName] =
				(reducers[propName] or default)(propValues, properties)
		end

		return reducedValue
	end
end

-- TODO: structure with unknown fields using one
function Reducers.map(reducer, ...)
	return Reducers.structure({}, reducer, ...)
end

function Reducers.exactly(value)
	return function ()
		return value
	end
end

function Reducers.try(...)
	local reducers = {...}

	return function (values)
		for _, reducer in ipairs(reducers) do
			local result = reducer(values)

			if result ~= nil then
				return result
			end
		end

		return nil
	end
end

function Reducers.compose(...)
	local reducers = {...}

	return function (values)
		for _, reducer in ipairs(reducers) do
			values = reducer(values)
		end

		return values
	end
end

--? Should this be removed in favor of Reducers.try?
function Reducers.thisOr(reducer, defaultValue)
	return function(values)
		local result = reducer(values)

		if result == nil then
			return defaultValue
		else
			return result
		end
	end
end

local function makeOr(func)
	return function (defaultValue)
		return Reducers.thisOr(func, defaultValue)
	end
end

Reducers.truthyOr = makeOr(Reducers.truthy)
Reducers.falsyOr = makeOr(Reducers.falsy)
Reducers.lastOr = makeOr(Reducers.last)
Reducers.default = Reducers.structure()

return Reducers
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXBDAF235BD9AA4E8A93D0F507663F8316">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Reducers.spec</string>
											<string name="ScriptGuid">{44774E1A-237D-4E54-A9AC-42D7A6D91BD1}</string>
											<ProtectedString name="Source"><![CDATA[local Reducers = require(script.Parent.Reducers)

return function()
	describe("structure", function()
		it("should reduce normally", function()
			local value = Reducers.structure({
				add = Reducers.add,
				multiply = Reducers.multiply,
			})({
				{ add = 3, multiply = 3, default = 1 },
				{ add = 2, multiply = 2, default = 2 },
			})

			expect(value.add).to.equal(5)
			expect(value.multiply).to.equal(6)
			expect(value.default).to.equal(2)
		end)

		it("should pass through with one value with no params", function()
			local layer = { add = 3, multiply = 3, default = 1 }

			local value = Reducers.structure()({
				layer,
			})

			expect(value.add).to.equal(3)
			expect(value.multiply).to.equal(3)
			expect(value.default).to.equal(1)

			expect(value).to.equal(layer)
		end)

		it("should assign with two value", function()
			local layer1 = { add = 3, multiply = 3, default = 1 }
			local layer2 = { add = 2, default = 2 }

			local value = Reducers.structure()({
				layer1,
				layer2
			})

			expect(value.add).to.equal(2)
			expect(value.multiply).to.equal(3)
			expect(value.default).to.equal(2)

			expect(value).to.never.equal(layer1)
			expect(value).to.never.equal(layer2)
		end)
	end)
end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBX3BC3A07895EE4357A87C28251507711E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Reactor</string>
										<string name="ScriptGuid">{EE5AFC90-C517-44C4-9A9C-092E577C2489}</string>
										<ProtectedString name="Source"><![CDATA[local ROOT = {}

local Reactor = {}
Reactor.__index = Reactor

function Reactor.new(fabric)
	return setmetatable({
		fabric = fabric;
		_unitStack = {};
		_effectStack = {};
	}, Reactor)
end

function Reactor:push(unit, effectKey)
	table.insert(self._unitStack, unit)
	table.insert(self._effectStack, effectKey)
end

function Reactor:pop()
	table.remove(self._effectStack, #self._effectStack)
	table.remove(self._unitStack, #self._unitStack)
end

function Reactor:peek()
	return self._unitStack[#self._unitStack], self._effectStack[#self._effectStack]
end

function Reactor._getCallback(unit, interestedUnit)
	return function(data, lastData)
		for interestedEffectKey, interestedKeys in pairs(interestedUnit._reactsTo[unit]) do
			local needsUpdate = false

			for interestedKey in pairs(interestedKeys) do
				if
					interestedKey == ROOT
					or data == nil
					or lastData == nil
					or data[interestedKey] ~= lastData[interestedKey]
				then
					interestedUnit.fabric:debug(
						"[Reactor Push]",
						unit,
						interestedKey == ROOT and "root" or interestedKey,
						"->",
						interestedUnit
					)
					needsUpdate = true
					break
				end
			end

			if needsUpdate then
				interestedUnit:_runEffect(interestedEffectKey)
			end
		end
	end
end

function Reactor:react(unit, key)
	if unit:isDestroyed() then
		-- unit:get can still be called if the unit is destroyed.
		return
	end

	local interestedUnit, interestedEffectKey = self:peek()

	if interestedUnit == nil then
		return
	end

	assert(key == nil or type(key) == "string", "Effects API does not work with nested keys yet")

	if key == nil then
		key = ROOT
	end

	if interestedUnit._reactsTo[unit] == nil then
		self.fabric:debug("[Reactor Interest]", unit, "->", interestedUnit)

		interestedUnit._reactsTo[unit] = {}

		local cleanupCallback = unit:on("updated", self._getCallback(unit, interestedUnit))
		interestedUnit:on("destroy", cleanupCallback)
		interestedUnit:on("hotReloaded", cleanupCallback)
		interestedUnit:on("hotReloaded", function()
			interestedUnit._reactsTo[unit] = nil
		end)
	end

	if interestedUnit._reactsTo[unit][interestedEffectKey] == nil then
		interestedUnit._reactsTo[unit][interestedEffectKey] = {}
	end

	interestedUnit._reactsTo[unit][interestedEffectKey][key] = true
end

return Reactor]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX8DA238D56E3C449CAD3C663B886B3036">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Serializer</string>
										<string name="ScriptGuid">{6F5AAF43-722E-4598-8664-95E36F2C7402}</string>
										<ProtectedString name="Source"><![CDATA[local BuiltInSerializers = require(script.Parent.BuiltInSerializers)
local makeEnum = require(script.Parent.makeEnum).makeEnum

local Serializer = {
	FailMode = makeEnum("FailMode", {"Error", "Ignore"});
}
Serializer.__index = Serializer

function Serializer.new(fabric)
	return setmetatable({
		_serializers = setmetatable({}, {__index = BuiltInSerializers.serializers});
		_deserializers = setmetatable({}, {__index = BuiltInSerializers.deserializers});
		fabric = fabric;
	}, Serializer)
end

function Serializer:deserialize(serializedTarget, failMode)
	if type(serializedTarget) ~= "table" then
		return serializedTarget
	end

	local deserializer = self._deserializers[serializedTarget.type]
	if not deserializer then
		error("Unable to deserialize object") -- TODO: Dump inspect of object
	end

	local object = deserializer(serializedTarget, self.fabric)

	if object == nil and failMode == Serializer.FailMode.Error then
		error("Deserialization failed for object and no error was emitted by the deserializer. This is a bug in your deserializer!")
	end

	return object
end

function Serializer:serialize(object)
	if type(object) ~= "table" then
		return object
	end

	local serializer = self:findSerializer(object)

	return
		serializer and serializer(object, self.fabric)
		or error(("Unable to serialize replicated unit %s"):format(tostring(object)))
end

function Serializer:registerSerializer(class, callback)
	self._serializers[class] = callback
end

function Serializer:registerDeserializer(name, callback)
	assert(type(name) == "string", "Deserializer type must be a string")
	self._deserializers[name] = callback
end

local function find(class, map)
	if map[class] then
		return map[class]
	end

	local metatable = getmetatable(class)

	if metatable then
		return find(metatable, map)
	end
end

function Serializer:findSerializer(class)
	return find(class, self._serializers)
end

function Serializer:findDeserializer(name)
	return self._deserializers[name]
end

return Serializer]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB1F49F8B6185403993BE32B6E8D6DB22">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Types</string>
										<string name="ScriptGuid">{1FAA60EB-8877-411A-BC6B-7B7A4BF61358}</string>
										<ProtectedString name="Source"><![CDATA[local t = require(script.Parent.Parent.Parent.t);

local Types = {}

Types.UnitDefinition = t.interface({
	-- User implementations
	name = t.string;
	reducer = t.optional(t.callback);
	schema = t.optional(t.callback);
	defaults = t.optional(t.map(t.string, t.any));
	units = t.optional(t.map(t.string, t.any));
	refCheck = t.optional(t.union(t.array(t.string), t.callback));
	shouldUpdate = t.optional(t.callback);

	-- Reserved Properties
	data = t.none;
	lastData = t.none;
	fabric = t.none;
	fire = t.none;
	on = t.none;
	ref = t.none;
	isLoaded = t.none;
	setIsLoading = t.none;
	get = t.none;

	-- Events
	onLoaded = t.optional(t.callback);
	onUpdated = t.optional(t.callback);
	initialize = t.optional(t.callback);
	destroy = t.optional(t.callback);
	render = t.optional(t.callback);

	effects = t.optional(t.map(t.any, t.callback));

	-- Extensions
	tag = t.optional(t.string);
	chainingEvents = t.optional(t.array(t.string));
	isService = t.optional(t.boolean);
})

return Types]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2714C55ED9F34B639070DAEEF26DCB04">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Unit</string>
										<string name="ScriptGuid">{80309F4D-FF1E-431D-B1FC-D8180AEDD612}</string>
										<ProtectedString name="Source"><![CDATA[local Comparators = require(script.Parent.Operators.Comparators)
local Reducers = require(script.Parent.Operators.Reducers)
local Symbol = require(script.Parent.Parent.Shared.Symbol)
local Util = require(script.Parent.Parent.Shared.Util)

local RESERVED_SCOPES = {
	[Symbol.named("base")] = true;
	[Symbol.named("remote")] = true;
}

local Unit = {}
Unit.__index = Unit

function Unit:fire(eventName, ...)
	if self:isDestroyed() then
		error(("Cannot fire event %q because this unit is destroyed."):format(
			tostring(eventName)
		))
	end

	-- call a method of the event name if it exists
	local methodName = "on" .. eventName:sub(1, 1):upper() .. eventName:sub(2)
	if self[methodName] then
		debug.profilebegin(("%s: %s"):format(
			tostring(self),
			tostring(methodName)
		))

		local thread = coroutine.create(self[methodName])
		local success, errorValue = coroutine.resume(thread, self, ...)

		debug.profileend()

		if not success then
			warn(("%q method of %s encountered an error: %s"):format(
				tostring(methodName),
				tostring(self),
				tostring(errorValue)
			))

			return
		end

		if coroutine.status(thread) ~= "dead" then
			warn(("Yielding in %s of %s is not allowed!"):format(
				tostring(methodName),
				tostring(self)
			))
		end
	end

	if not self._listeners[eventName] then
		return -- Do nothing if no listeners registered
	end

	for i, callback in ipairs(self._listeners[eventName]) do
		debug.profilebegin(("%s: %s (%d)"):format(
			tostring(self),
			tostring(eventName),
			i
		))

		local success, errorValue = coroutine.resume(coroutine.create(callback), ...)

		debug.profileend()

		if not success then
			warn(("Event listener of %s for %q encountered an error: %s"):format(
				tostring(self),
				tostring(eventName),
				tostring(errorValue)
			))
		end
	end
end

function Unit:on(eventName, callback)
	if self:isDestroyed() then
		error(("Cannot attach event listener %q because this unit is destroyed."):format(
			tostring(eventName)
		))
	end

	self._listeners[eventName] = self._listeners[eventName] or {}
	table.insert(self._listeners[eventName], callback)

	-- The disconnect callback closes on `self`, which will prevent it from being
	-- GC'd as long as a reference to the callback exists. We use a weak values
	-- container to allow the unit to be cleaned up even if a callback
	-- exists.
	local weakSelfContainer = setmetatable({ self = self }, { __mode = "v" })

	return function()
		local weakSelf = weakSelfContainer.self

		if not weakSelf then
			return
		end

		if weakSelf._listeners == nil then
			-- This unit has been destroyed
			return
		end

		for i, listCallback in ipairs(weakSelf._listeners[eventName]) do
			if listCallback == callback then
				table.remove(weakSelf._listeners[eventName], i)
				break
			end
		end
	end
end

function Unit:get(key)
	self.fabric._reactor:react(self, key)

	local object = self.data

	if object == nil then
		return
	end

	if key == nil then
		return object
	end

	if type(key) == "table" then
		for _, field in ipairs(key) do
			object = object[field]

			if object == nil then
				return
			end
		end

		return object
	elseif type(object) == "table" then
		return object[key]
	else
		error("Can't call Unit:get() with a parameter when unit data isn't a table")
	end
end

function Unit:getUnit(unitResolvable)
	self:assertNotDestroyed()
	return self.fabric._collection:getUnitByRef(unitResolvable, self)
end

function Unit:getOrCreateUnit(unitResolvable)
	self:assertNotDestroyed()
	return self.fabric._collection:getOrCreateUnitByRef(unitResolvable, self)
end

function Unit:isDestroyed()
	return self._destroyed or false
end

function Unit:assertNotDestroyed()
	assert(self:isDestroyed() == false, "This unit is destroyed!")
end

function Unit:addLayer(scope, data)
	self:assertNotDestroyed()
	return self:_addLayer(scope, data)
end

function Unit:mergeBaseLayer(data)
	self:assertNotDestroyed()
	local existingBaseLayer = self._layers[Symbol.named("base")] or {}
	local newBaseLayer = {}

	for _, tableToMerge in ipairs({existingBaseLayer, data}) do
		for key, value in pairs(tableToMerge) do
			if value == self.fabric.None then
				newBaseLayer[key] = nil
			else
				newBaseLayer[key] = value
			end
		end
	end

	return self:_addLayer(Symbol.named("base"), newBaseLayer)
end

function Unit:removeLayer(scope)
	self:assertNotDestroyed()
	return self:_removeLayer(scope)
end

function Unit:_addLayer(scope, data)
	if data == nil then
		return self:_removeLayer(scope)
	end

	if self._layers[scope] == nil then
		table.insert(self._layerOrder, scope)
	end

	self._layers[scope] = data

	-- Set up automatic layer removal if scope is a unit
	-- This lets you use a unit as a scope, and the layer gets auto removed
	-- when the unit gets removed.
	if type(scope) == "table" and getmetatable(getmetatable(scope)) == Unit then
		if self._unitScopeLayers[scope] == nil then
			self._unitScopeLayers[scope] = scope:on("destroy", function()
				self:_removeLayer(scope)
			end)
		end
	end

	self:_changed()
end

function Unit:_removeLayer(scope)
	-- Disconnect listener for layer removal if the layer is removed explicitly
	if self._unitScopeLayers[scope] then
		self._unitScopeLayers[scope]() -- This is the disconnect callback
		self._unitScopeLayers[scope] = nil
	end

	if self._layers[scope] then
		table.remove(self._layerOrder, table.find(self._layerOrder, scope))

		self._layers[scope] = nil
		self:_changed()
	end

	local shouldDestroy = next(self._layers) == nil

	if shouldDestroy then
		self:fire("destroy")
	end
end

function Unit:_runEffect(key)
	self.fabric._reactor:push(self, key)

	debug.profilebegin(("%s: Effect %s"):format(
		tostring(self),
		tostring(key)
	))

	local thread = coroutine.create(self.effects[key])
	local success, errorValue = coroutine.resume(thread, self)

	debug.profileend()

	if coroutine.status(thread) ~= "dead" then
		warn(("Effect %q of %s yielded! This is very illegal."):format(
			tostring(key),
			tostring(self)
		))
	end

	self.fabric._reactor:pop()

	if not success then
		warn(("Effect %q of %s encountered an error: %s"):format(
			tostring(key),
			tostring(self),
			tostring(errorValue)
		))
	end
end

function Unit:_runEffects()
	if self.effects == nil then
		return
	end

	-- TODO: Document effects don't run in guaranteed order
	for key in pairs(self.effects) do
		self:_runEffect(key)
	end
end

function Unit:_changed()
	local lastData = self.data

	debug.profilebegin(("%s: reduce"):format(
		tostring(self)
	))

	local newData = self:_reduce()

	debug.profileend()

	self.data = newData

	local shouldRunAllEffects = false
	if lastData == nil and newData ~= nil then
		self._loaded = true
		self._loading = false
		self:fire("loaded", newData)

		shouldRunAllEffects = true
	end

	if (self.shouldUpdate or Comparators.default)(newData, lastData) then
		self:fire("updated", newData, lastData)
	end

	if shouldRunAllEffects then
		self:_runEffects()
	end
end

function Unit:_reduce()
	if next(self._layers) == nil then
		return
	end

	local values = { self._layers[Symbol.named("remote")] }
	table.insert(values, self._layers[Symbol.named("base")])

	for _, name in ipairs(self._layerOrder) do
		if RESERVED_SCOPES[name] == nil then
			table.insert(values, self._layers[name])
		end
	end

	local reducedValue = (self.reducer or Reducers.default)(values)
	local data = reducedValue

	if self.defaults and type(data) == "table" then
		data = Util.assign({}, self.defaults, reducedValue)
	end

	if self.schema then
		assert(self.schema(data))
	end

	return data
end

function Unit:isLoaded()
	self:assertNotDestroyed()
	return self._loaded
end

function Unit:setIsLoading()
	self:assertNotDestroyed()
	if self._loaded then
		error("Attempt to call setIsLoading when this unit is already loaded.")
	end

	self._loading = true
end

function Unit:__tostring()
	return ("Unit(%s)"):format(
		typeof(self.ref) == "Instance" and ("%s, %s"):format(self.name, self.ref:GetFullName()) or self.name
	)
end

return Unit
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX38F0972CA8C44251A3FBA7A7E8E07FA3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Unit.spec</string>
										<string name="ScriptGuid">{B7AFC1B2-6B9A-4D18-8F7B-99E4F4CB6C65}</string>
										<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Fabric = require(script.Parent)

local TEST_REF = {}
local TEST_REF_2 = {}

return function()
	local function makeTestUnitDefinition(fabric)
		local callCounts =  Util.callCounter()

		local reducers = fabric.reducers

		return {
			name = "Test";
			onInitialize = function(self)
				expect(self).to.be.ok()
				callCounts:call("onInitialize")
			end;
			onDestroy = function(self)
				expect(self).to.be.ok()
				callCounts:call("onDestroy")
			end;
			defaults = {
				testDefault = 5;
			};
			reducer = reducers.structure({
				added = reducers.add;
				nested = reducers.structure({
					value = reducers.last;
				})
			});
			shouldUpdate = fabric.comparators.structure({
				shouldUpdateTest = function()
					callCounts:call("shouldUpdate")
					return false
				end
			});
			schema = function(data)
				expect(data).to.be.ok()
				expect(type(data)).to.equal("table")

				callCounts:call("schema")

				return true
			end;
			refCheck = function(ref)
				expect(ref).to.be.ok()
				expect(ref).to.equal(TEST_REF)
				callCounts:call("refCheck")

				return true
			end;
			tag = "Test";
			onUpdated = function()
				callCounts:call("onUpdated")
			end;
			onLoaded = function()
				callCounts:call("onLoaded")
			end;
		}, callCounts
	end

	local fabric

	beforeEach(function()
		fabric = Fabric.new("test")
	end)

	describe("Unit", function()
		it("should add units", function()
			local testUnit, callCounts = makeTestUnitDefinition(fabric)
			fabric:registerUnit(testUnit)

			local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)

			unit:addLayer("foo", {
				added = 1;
				nested = {
					value = "nested_value";
				};
				shouldUpdateTest = 1;
			})

			expect(callCounts.refCheck).to.equal(1)
			expect(callCounts.onInitialize).to.equal(1)
			expect(unit:isLoaded()).to.equal(true)
			expect(callCounts.onLoaded).to.equal(1)
			expect(callCounts.onUpdated).to.equal(1)
			expect(callCounts.schema).to.equal(1)
			expect(callCounts.onDestroy).to.equal(0)

			local loadedPromise = fabric:getLoadedUnitByRef("Test", TEST_REF)
			expect(loadedPromise:getStatus()).to.equal("Resolved")
			expect(loadedPromise._values[1]).to.equal(unit)

			expect(unit:get("added")).to.equal(1)
			expect(unit:get("testDefault")).to.equal(5)
			expect(unit:get({"nested", "value"})).to.equal("nested_value")
		end)

		it("should have data and lastData correct in onUpdated", function()
			local iteration = 0
			local callCount = 0

			fabric:registerUnit({
				name = "hi";
				onUpdated = function(self, newData, lastData)
					callCount += 1

					if iteration == 0 then
						expect(newData).to.be.ok()
						expect(lastData).to.never.be.ok()

						expect(newData.foo).to.equal(1)
					elseif iteration == 1 then
						expect(newData).to.be.ok()
						expect(lastData).to.be.ok()

						expect(newData.foo).to.equal(2)
						expect(lastData.foo).to.equal(1)
					end
				end
			})

			expect(callCount).to.equal(0)

			local unit = fabric:getOrCreateUnitByRef("hi", TEST_REF)

			unit:addLayer("hi", {
				foo = 1
			})

			expect(callCount).to.equal(1)

			iteration += 1

			unit:addLayer("hi", {
				foo = 2
			})

			expect(callCount).to.equal(2)
		end)

		it("should be safe when dealing with non-table data", function()
			fabric:registerUnit({
				name = "foo",
				reducer = fabric.reducers.add,
				defaults = {
					bar = 2
				}
			})

			local unit = fabric:getOrCreateUnitByRef("foo", TEST_REF)

			unit:addLayer("aaa", 1)

			expect(unit:get()).to.equal(1)
		end)

		describe("mergeBaseLayer", function()
			it("should allow merging into the base layer", function()
				local testUnit, _callCounts = makeTestUnitDefinition(fabric)
				fabric:registerUnit(testUnit)
				local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)

				unit:mergeBaseLayer({
					bar = 1
				})

				unit:mergeBaseLayer({
					foo = 2
				})
				expect(unit.data.bar).to.equal(1)
				expect(unit.data.foo).to.equal(2)

				unit:mergeBaseLayer({
					bar = 2
				})
				expect(unit.data.bar).to.equal(2)
				expect(unit.data.foo).to.equal(2)
			end)

			it("should work when the base layer is nil", function()
				local testUnit, _callCounts = makeTestUnitDefinition(fabric)
				fabric:registerUnit(testUnit)

				local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)

				unit:mergeBaseLayer({
					baz = 4
				})

				expect(unit.data.baz).to.equal(4)
			end)

			it("should set fabric.None values to nil", function()
				local testUnit, _callCounts = makeTestUnitDefinition(fabric)
				fabric:registerUnit(testUnit)

				local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)

				unit:mergeBaseLayer({
					bar = 1
				})

				expect(unit.data.bar).to.equal(1)

				unit:mergeBaseLayer({
					bar = fabric.None
				})
				expect(unit.data.bar).to.never.be.ok()
			end)
		end)

		describe("get", function()
			it("should get values", function()
				fabric:registerUnit({
					name = "foo"
				})

				local unit = fabric:getOrCreateUnitByRef("foo", TEST_REF)

				expect(unit:get("baz")).to.equal(nil)
				expect(unit:get({})).to.equal(nil)

				unit:addLayer("bar", {
					baz = 1
				})

				expect(unit:get("baz")).to.equal(1)
				expect(unit:get({"baz"})).to.equal(1)

				expect(unit:get().baz).to.equal(1)
				expect(unit:get({}).baz).to.equal(1)
			end)

			it("should get nested values", function()
				fabric:registerUnit({
					name = "foo"
				})

				local unit = fabric:getOrCreateUnitByRef("foo", TEST_REF)

				expect(unit:get("baz")).to.equal(nil)

				unit:addLayer("bar", {
					baz = {
						qux = 1
					}
				})

				expect(unit:get({"baz", "qux"})).to.equal(1)

				expect(unit:get().baz.qux).to.equal(1)
				expect(unit:get({"baz"}).qux).to.equal(1)
			end)

			it("should error with non-table data", function()
				fabric:registerUnit({
					name = "foo",
					reducer = fabric.reducers.add,
				})

				local unit = fabric:getOrCreateUnitByRef("foo", TEST_REF)

				expect(unit:get("baz")).to.equal(nil)
				expect(unit:get({})).to.equal(nil)

				unit:addLayer("bar", 1)

				expect(function()
					unit:get("bad")
				end).to.throw()

				expect(function()
					unit:get({"hi"})
				end).to.throw()

				expect(unit:get()).to.equal(1)
				expect(unit:get({})).to.equal(1)
			end)
		end)

		it("should combine layers", function()
			local testUnit, callCounts = makeTestUnitDefinition(fabric)
			fabric:registerUnit(testUnit)

			local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)
			unit:mergeBaseLayer({
				added = 1;
				nested = {
					value = "nested_value_first";
				};
				shouldUpdateTest = 1;
			})

			unit:addLayer("bar", {
				added = 1;
				nested = {
					value = "nested_value_last";
				};
				shouldUpdateTest = 2;
			})

			expect(callCounts.refCheck).to.equal(1)
			expect(callCounts.onInitialize).to.equal(1)
			expect(callCounts.onLoaded).to.equal(1)
			expect(callCounts.onUpdated).to.equal(2)
			expect(callCounts.schema).to.equal(2)
			expect(callCounts.onDestroy).to.equal(0)

			expect(unit:get("added")).to.equal(2)
			expect(unit:get({"nested", "value"})).to.equal("nested_value_last")
		end)

		it("should run the shouldUpdate handler", function()
			local testUnit, callCounts = makeTestUnitDefinition(fabric)
			fabric:registerUnit(testUnit)

			local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)
			unit:addLayer("foo", {
				shouldUpdateTest = 1;
			})

			unit:addLayer("bar", {
				shouldUpdateTest = 2;
			})

			expect(callCounts.shouldUpdate).to.equal(3)
			expect(callCounts.onUpdated).to.equal(1)
		end)

		it("should remove correctly", function()
			local testUnit, callCounts = makeTestUnitDefinition(fabric)
			fabric:registerUnit(testUnit)

			local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)

			unit:addLayer("foo", {
				added = 1;
			})

			unit:addLayer("bar", {
				added = 2;
			})

			expect(unit:get("added")).to.equal(3)

			unit:removeLayer("foo")

			expect(unit:get("added")).to.equal(2)

			expect(unit:isDestroyed()).to.equal(false)

			unit:removeLayer("bar")

			expect(unit:get("added")).to.equal(nil)
			expect(callCounts.onDestroy).to.equal(1)
			expect(unit:isDestroyed()).to.equal(true)

			local newUnit = fabric:getOrCreateUnitByRef("Test", TEST_REF)
			newUnit:addLayer("foo", {
				added = 1;
			})

			expect(newUnit).to.never.equal(unit)
		end)

		it("shouldn't remove other refs", function()
			local newUnit = {
				name = "Test2",
				tag = "Test2",
			}
			local newUnit2 = {
				name = "Test3",
				tag = "Test3",
				units = {
					Test2 = {}
				},
			}
			fabric:registerUnit(newUnit)
			fabric:registerUnit(newUnit2)

			local unit = fabric:getOrCreateUnitByRef("Test3", TEST_REF)
			unit:addLayer("foo", {})
			local otherUnit = fabric:getOrCreateUnitByRef("Test3", TEST_REF_2)
			otherUnit:addLayer("foo", {})

			expect(unit:isDestroyed()).to.equal(false)
			expect(otherUnit:isDestroyed()).to.equal(false)

			unit:removeLayer("foo")

			expect(unit:isDestroyed()).to.equal(true)
			expect(otherUnit:isDestroyed()).to.equal(false)
		end)

		it("should attach nested units", function()
			local newUnit = {
				name = "Test2",
				tag = "Test2",
			}
			local newUnit2 = {
				name = "Test3",
				tag = "Test3",
				units = {
					Test2 = {
						foo = 1;
					}
				},
			}
			fabric:registerUnit(newUnit)
			fabric:registerUnit(newUnit2)

			local unit = fabric:getOrCreateUnitByRef("Test3", TEST_REF)
			local nestedUnit = unit:getUnit("Test2")

			expect(unit).to.be.ok()
			expect(nestedUnit).to.be.ok()
			expect(nestedUnit.data.foo).to.equal(1)
		end)

		it("should remove layers whose scopes are units when the unit is destroyed", function()
			fabric:registerUnit({
				name = "Test"
			})

			local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)
			local unitToBeRemoved = fabric:getOrCreateUnitByRef("Test", TEST_REF_2)

			unit:addLayer("some scope", {
				foo = 0
			})

			expect(unit:get("foo")).to.equal(0)

			unit:addLayer(unitToBeRemoved, {
				foo = 1
			})

			expect(unit:get("foo")).to.equal(1)

			expect(unit:isDestroyed()).to.equal(false)
			expect(unitToBeRemoved:isDestroyed()).to.equal(false)

			fabric:removeAllUnitsWithRef(TEST_REF_2)

			expect(unit:isDestroyed()).to.equal(false)
			expect(unit:get("foo")).to.equal(0)
		end)
	end)
	describe("Events", function()
		SKIP()
		it("shouldn't run events if connected during firing", function()
			fabric:registerUnit({
				name = "Test",
			})

			local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)

			local count = 0
			unit:on("foo", function()
				unit:on("foo", function()
					count += 1
				end)
			end)

			unit:fire("foo")

			expect(count).to.equal(0)
		end)

		it("shouldn't skip events if one is disconnected during firing", function()
			fabric:registerUnit({
				name = "Test",
			})

			local unit = fabric:getOrCreateUnitByRef("Test", TEST_REF)

			local disconnect
			disconnect = unit:on("foo", function()
				disconnect()
			end)

			local count = 0
			unit:on("foo", function()
				count += 1
			end)

			expect(count).to.equal(1)
		end)
	end)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX74F665E6999D4CB29925E139E3222518">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">UnitCollection</string>
										<string name="ScriptGuid">{5CE06F12-5976-43F0-B13C-3317D609CBFB}</string>
										<ProtectedString name="Source"><![CDATA[local Unit = require(script.Parent.Unit)
local Types = require(script.Parent.Types)
local isAllowedOnRef = require(script.Parent.isAllowedOnRef).isAllowedOnRef

local WEAK_KEYS_METATABLE = {
	__mode = "k"
}

local UnitCollection = {}
UnitCollection.__index = UnitCollection

function UnitCollection.new(fabric)
	return setmetatable({
		fabric = fabric;
		_unitsByName = {};
		_unitsByRef = {};
		_refUnits = {};
	}, UnitCollection)
end

function UnitCollection:register(unitDefinition, isHotReload)
	assert(Types.UnitDefinition(unitDefinition))

	if not isHotReload then
		assert(self._unitsByName[unitDefinition.name] == nil, "A unit with this name is already registered!")
	end

	self.fabric.Unit[unitDefinition.name] = unitDefinition

	setmetatable(unitDefinition, Unit)
	unitDefinition.__index = unitDefinition
	unitDefinition.__tostring = Unit.__tostring
	unitDefinition.fabric = self.fabric

	unitDefinition.new = function()
		return setmetatable({}, unitDefinition)
	end

	self._unitsByName[unitDefinition.name] = unitDefinition
	self._unitsByRef[unitDefinition] = unitDefinition
end

function UnitCollection:resolve(unitResolvable)
	return self._unitsByRef[unitResolvable]
		or self._unitsByName[unitResolvable]
end

function UnitCollection:resolveOrError(unitResolvable)
	return self:resolve(unitResolvable) or error(
		("Cannot resolve unit %s"):format(tostring(unitResolvable))
	)
end

function UnitCollection:constructUnit(staticUnit, ref)
	assert(isAllowedOnRef(staticUnit, ref))

	local unit = staticUnit.new()

	assert(
		getmetatable(unit) == staticUnit,
		"Metatable of newly constructed unit must be its static counterpart"
	)

	unit.private = {}
	unit._layers = {}
	unit._layerOrder = {}
	unit._reactsTo = setmetatable({}, WEAK_KEYS_METATABLE)
	unit._unitScopeLayers = {}
	unit._listeners = {}
	unit.ref = ref
	unit.fabric = self.fabric
	unit._loading = false
	unit._loaded = false

	self._refUnits[ref] = self._refUnits[ref] or {}
	self._refUnits[ref][staticUnit] = unit

	unit:on("destroy", function()
		self:deconstructUnit(unit)
	end)

	if staticUnit.units then
		for name, data in pairs(staticUnit.units) do
			unit:getOrCreateUnit(name):mergeBaseLayer(data)
		end
	end

	unit:fire("initialize")

	return unit
end

-- Need a way to hook into that and make sure units being removed is
-- identical to unit having all data set to nil
-- Perhaps a unit:destroy() method is necessary after all
function UnitCollection:deconstructUnit(unit)
	local staticUnit = getmetatable(unit)

	self._refUnits[unit.ref][staticUnit] = nil

	if next(self._refUnits[unit.ref]) == nil then
		self._refUnits[unit.ref] = nil
	end

	self:removeAllUnitsWithRef(unit)

	unit._listeners = nil
	unit.ref = nil
	unit._destroyed = true
	unit._layers = nil
	unit._layerOrder = nil
	unit._reactsTo = nil

	for _, disconnect in pairs(unit._unitScopeLayers) do
		disconnect()
	end

	unit._unitScopeLayers = nil
end

function UnitCollection:getUnitByRef(unitResolvable, ref)
	local staticUnit = self:resolveOrError(unitResolvable)

	return self._refUnits[ref] and self._refUnits[ref][staticUnit]
end

function UnitCollection:getOrCreateUnitByRef(unitResolvable, ref)
	local unit = self:getUnitByRef(unitResolvable, ref)

	if not unit then
		unit = self:constructUnit(self:resolveOrError(unitResolvable), ref)
	end

	return unit
end

function UnitCollection:removeAllUnitsWithRef(ref)
	if self._refUnits[ref] then
		for _staticUnit, unit in pairs(self._refUnits[ref]) do
			unit:fire("destroy")
		end
	end
end

return UnitCollection
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXEF5DF7F2277C460FAED71A1D2DB23642">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">init.spec</string>
										<string name="ScriptGuid">{522515FE-F08F-4247-9074-0CC93485E0D6}</string>
										<ProtectedString name="Source"><![CDATA[local Fabric = require(script.Parent)

return function()
	describe("Fabric.new", function()
		it("should return a fabric", function()
			local fabric = Fabric.new("the namespace")

			expect(fabric.namespace).to.equal("the namespace")
		end)
	end)

	describe("Fabric:registerUnit", function()
		it("should register units", function()
			local unitDef = {
				name = "Test";
			}
			local fabric = Fabric.new()

			local eventCount = 0

			fabric:on("unitRegistered", function()
				eventCount += 1
			end)

			fabric:registerUnit(unitDef)

			expect(fabric.Unit.Test).to.be.ok()
			expect(eventCount).to.equal(1)
		end)

		it("shouldn't register duplicate units", function()
			local unitDef = {
				name = "Test";
			}
			local fabric = Fabric.new()

			fabric:registerUnit(unitDef)

			local unitDef2 = {
				name = "Test";
			}
			local stat, err = pcall(function()
				fabric:registerUnit(unitDef2)
			end)

			expect(stat).to.equal(false)
			expect(err:match("A unit with this name is already registered!")).to.be.ok()
		end)
	end)

	describe("Fabric:registerUnitsIn", function()

	end)

	describe("Fabric:getUnitByRef and Fabric:getOrCreateUnitByRef", function()
		it("should create and get a unit on ref", function()
			local unitDef = {
				name = "Test";
			}
			local fabric = Fabric.new()

			fabric:registerUnit(unitDef)

			local testRef = {}

			expect(fabric:getUnitByRef("Test", testRef)).to.never.be.ok()

			fabric:getOrCreateUnitByRef(unitDef, testRef)
			expect(fabric:getUnitByRef("Test", testRef)).to.be.ok()
		end)
	end)

	describe("Fabric:removeAllUnitsWithRef", function()
		it("should remove all units with a ref", function()
			local unitDef = {
				name = "Test";
			}
			local unitDef2 = {
				name = "Test2";
			}
			local fabric = Fabric.new()

			fabric:registerUnit(unitDef)
			fabric:registerUnit(unitDef2)

			local testRef = {}

			fabric:getOrCreateUnitByRef(unitDef, testRef)
			fabric:getOrCreateUnitByRef(unitDef2, testRef)

			expect(fabric:getUnitByRef("Test", testRef)).to.be.ok()
			expect(fabric:getUnitByRef("Test2", testRef)).to.be.ok()

			fabric:removeAllUnitsWithRef(testRef)

			expect(fabric:getUnitByRef("Test", testRef)).to.never.be.ok()
			expect(fabric:getUnitByRef("Test2", testRef)).to.never.be.ok()
		end)
	end)

	describe("Fabric:fire and Fabric:on", function()
		it("should fire events", function()
			local fabric = Fabric.new()

			local callCount = 0
			fabric:on("testEvent", function()
				callCount += 1
			end)

			expect(callCount).to.equal(0)

			fabric:fire("testEvent")

			expect(callCount).to.equal(1)

			fabric:fire("doesn't exist")

			expect(callCount).to.equal(1)
		end)
	end)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX21C5377B962D4D2D9DB5E103894D633E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">isAllowedOnRef</string>
										<string name="ScriptGuid">{1B830444-435C-4ACA-942D-77067F2A6AD4}</string>
										<ProtectedString name="Source"><![CDATA[local function makeClassCheckFromArray(array)
	return function(ref)
		for _, className in ipairs(array) do
			if ref:IsA(className) then
				return true
			end
		end

		return
			false,
			("Ref type %q is not allowed to have this unit!")
				:format(tostring(ref))
	end
end

local function isAllowedOnRef(staticUnit, ref)
	if staticUnit.refCheck == nil then
		return true
	end

	if type(staticUnit.refCheck) == "table" then
		staticUnit.refCheck = makeClassCheckFromArray(staticUnit.refCheck)
	end

	return staticUnit.refCheck(ref)
end

return {
	isAllowedOnRef = isAllowedOnRef;
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXEA55241888CA4E028B0B78B776BEE10F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">makeEnum</string>
										<string name="ScriptGuid">{93AC0CC5-461D-4D88-9A89-A3EE78E9C6B8}</string>
										<ProtectedString name="Source"><![CDATA[local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

return {
	makeEnum = makeEnum;
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX186DD54801FB4AB6A9877811EC1873FC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Replication</string>
									<string name="ScriptGuid">{1502837D-0298-4E2C-B33E-FD351C7A52A0}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local ServerReplicator = require(script.ServerTransmitter)
local ClientReplicator = require(script.ClientTransmitter)
local registerReplicator = require(script.Replicator)

return function (fabric)
	registerReplicator(fabric)

	fabric.transmitter = (RunService:IsServer() and ServerReplicator or ClientReplicator).new(fabric)

end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX9E30702DE3004258998DF81EC6329752">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ClientTransmitter</string>
										<string name="ScriptGuid">{D18116CD-5223-4338-8AD3-A31CF15CB363}</string>
										<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local EVENT_NAME = "fabricEvent"

local ClientTransmitter = {
	Remote = {};
}
ClientTransmitter.__index = ClientTransmitter

function ClientTransmitter.new(fabric)
	local self = {
		fabric = fabric;
	}

	self._event = ReplicatedStorage:WaitForChild(EVENT_NAME)

	self._unit = fabric:registerUnit({
		name = "Transmitter";
		onInitialize = function(unit)
			self:subscribe(unit.ref)
		end;
		onDestroy = function(unit)
			assert(unit.ref ~= nil, "unit.ref is nil")
			self:unsubscribe(unit.ref)
		end;
		send = function(unit, transmitEvent, transmitData)
			self:_send(
				"event",
				self.fabric.serializer:serialize(unit.ref),
				transmitEvent,
				transmitData
			)
		end;
		-- Returns true if the layer is created, false if not.
		sendWithPredictiveLayer = function(unit, layerData, transmitEvent, transmitData)

			if unit.ref.data == nil then
				-- use regular send if it is loading
				unit:send(transmitEvent, transmitData)

				return false
			end

			local predictionGUID = "NetworkPredictionLayer-" .. HttpService:GenerateGUID(false)

			self:_send(
				"event",
				self.fabric.serializer:serialize(unit.ref),
				transmitEvent,
				transmitData,
				predictionGUID
			)

			unit.ref:addLayer(predictionGUID, layerData)
			return true
		end;
	})

	self._event.OnClientEvent:Connect(function(namespace, serializedUnit, predictionGUIDs, eventName, ...)
		if namespace ~= self.fabric.namespace then
			return
		end

		local unit = self.fabric.serializer:deserialize(serializedUnit)
		assert(unit ~= nil, "unit is nil")

		if predictionGUIDs then
			for _, predictionGUID in ipairs(predictionGUIDs) do
				unit:removeLayer(predictionGUID)
			end
		end

		if ClientTransmitter.Remote[eventName] then
			ClientTransmitter.Remote[eventName](self, unit, ...)
		end
	end)

	return setmetatable(self, ClientTransmitter)
end

function ClientTransmitter:subscribe(unit)
	self.fabric:debug("Subscribing to", unit.name)
	self:_send("subscribe", self.fabric.serializer:serialize(unit))
end

function ClientTransmitter:unsubscribe(unit)
	self.fabric:debug("Unsubscribing from", unit.name)
	self:_send("unsubscribe", self.fabric.serializer:serialize(unit))
end

function ClientTransmitter:_send(eventName, serializedUnit, ...)
	self._event:FireServer(self.fabric.namespace, eventName, serializedUnit, ...)
end

function ClientTransmitter.Remote:event(unit, transmitEvent, transmitData)
	local transmitter = unit:getUnit(self._unit)

	assert(transmitter ~= nil, "unit doesn't have a transmitter")

	local transmitStr = "server" .. transmitEvent:sub(1, 1):upper() .. transmitEvent:sub(2)
	transmitter:fire(
		transmitStr,
		transmitData
	)

	transmitter.ref:fire(
		transmitStr,
		transmitData
	)
end

function ClientTransmitter.Remote:rejectNetworkPrediction(unit)
	self.fabric:debug(("Network prediction rejected for %q"):format(tostring(unit)))
	unit:getUnit(self._unit):fire("rejectNetworkPrediction")
end

return ClientTransmitter
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX82C5F050D4414E53869344AC2AB8F874">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Replicator</string>
										<string name="ScriptGuid">{1E6ED1EA-6EBA-469E-9FBD-E5A74C9041CF}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Util = require(script.Parent.Parent.Shared.Util)
local Symbol = require(script.Parent.Parent.Shared.Symbol)

return function (fabric)
	fabric:registerUnit(Util.assign(
		{},
		{
			name = "Replicated";
			reducer = fabric.reducers.structure({});
			schema = function(value)
				return type(value) == "table"
			end;
			onInitialize = function(self)
				self.transmitter = self.ref:getOrCreateUnit("Transmitter")
				self.initialBroadcastSent = false

				self:on("destroy", self.transmitter:on("subscriberAdded", function(player)
					if self.initialBroadcastSent then
						self.transmitter:sendTo(player, "replicate", {
							data = self.ref.data
						})
					end
				end))

				if RunService:IsClient() then
					self.ref:setIsLoading()

					self.transmitter:on("serverReplicate", function(payload)
						self.ref:_addLayer(Symbol.named("remote"), payload.data)
					end)
				end
			end;
		},
		RunService:IsServer() and {
			onLoaded = function(self)
				self:on("destroy", self.ref:on("updated", function()
					self.initialBroadcastSent = true

					self.transmitter:broadcast("replicate", {
						data = self.ref.data;
					})
				end))
			end;
		} or {}
	))
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX87ACDAB5571147EC88407FB47C795ED6">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ServerTransmitter</string>
										<string name="ScriptGuid">{B2804A3D-4CA9-4B29-BB80-D8349FCEB36C}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local getOrCreate = require(script.Parent.getOrCreate).getOrCreate
local FailMode = require(script.Parent.Parent.Fabric.Serializer).FailMode

local EVENT_NAME = "fabricEvent"

local EVENT_FAIL_MODES = {
	unsubscribe = FailMode.Ignore;
}

local ServerTransmitter = {
	Remote = {}
}
ServerTransmitter.__index = ServerTransmitter

function ServerTransmitter.new(fabric)
	local self = {
		fabric = fabric;
	}

	self._event = getOrCreate(
		ReplicatedStorage,
		EVENT_NAME,
		"RemoteEvent"
	)

	self._unit = fabric:registerUnit({
		name = "Transmitter";
		reducer = fabric.reducers.structure({});
		schema = function(value)
			return type(value) == "table"
		end;
		onInitialize = function(unit)
			unit.subscribers = {}
		end;
		broadcast = function(unit, transmitEvent, transmitData)
			for _, player in ipairs(unit.subscribers) do
				self:_send(
					unit,
					player,
					"event",
					transmitEvent,
					transmitData
				)
			end
		end;
		sendTo = function(unit, player, transmitEvent, transmitData)
			self:_send(
				unit,
				player,
				"event",
				transmitEvent,
				transmitData
			)
		end;
	})

	self._event.OnServerEvent:Connect(function(player, namespace, eventName, serializedUnit, ...)
		if namespace ~= self.fabric.namespace then
			return
		end

		if ServerTransmitter.Remote[eventName] then
			local transmitter = self:_getTransmitterFromSerializedUnit(
				serializedUnit,
				EVENT_FAIL_MODES[eventName] or FailMode.Error
			)

			ServerTransmitter.Remote[eventName](self, player, transmitter, ...)
		end
	end)

	--quick and dirty fix for https://github.com/evaera/Fabric/issues/55
	game:GetService("Players").PlayerRemoving:Connect(function(player)
		for i, subunits in pairs(fabric._collection._refUnits) do
			for subunitDefinition, subunitInstance in pairs(subunits) do
				if subunitDefinition.name == "Transmitter" then
					ServerTransmitter.Remote.unsubscribe(self, player, subunitInstance)
				end
			end
		end
	end)

	return setmetatable(self, ServerTransmitter)
end

function ServerTransmitter:_getTransmitterFromSerializedUnit(serializedUnit, failMode)
	local unit = self.fabric.serializer:deserialize(serializedUnit, failMode)

	if not unit then
		self.fabric:debug(("Client wants communicate with unit %q on %q, but that doesn't exist on the server. This could be normal if the attached Instance was removed."):format(
				tostring(serializedUnit.name),
				tostring(serializedUnit.ref)
			))
		return
	end

	local transmitter = unit:getUnit(self._unit)

	if not transmitter then
		self.fabric:debug(("%s does not have a Transmitter attached, but received a message."):format(unit))
	end

	return transmitter
end

function ServerTransmitter.Remote:subscribe(player, transmitter)
	table.insert(transmitter.subscribers, player)

	transmitter:fire("subscriberAdded", player)
end

-- TODO: Make sure players who leave the game get removed from subscribers
function ServerTransmitter.Remote:unsubscribe(player, transmitter)
	if transmitter == nil then
		return
	end

	for i, listPlayer in ipairs(transmitter.subscribers) do
		if player == listPlayer then
			table.remove(transmitter.subscribers, i)

			transmitter:fire("subscriberRemoved", player)

			break
		end
	end
end

function ServerTransmitter.Remote:event(player, transmitter, transmitEvent, transmitData, predictionGUID)
	if type(predictionGUID) == "string" then
		if transmitter.predictionGUIDBuffer == nil then
			transmitter.predictionGUIDBuffer = {}

			local connection
			connection = transmitter.fabric.Heartbeat:Connect(function()
				connection:Disconnect()

				if #transmitter.predictionGUIDBuffer > 0 then
					self:_send(transmitter, player, "rejectNetworkPrediction")
				end

				transmitter.predictionGUIDBuffer = nil
			end)
		end

		table.insert(transmitter.predictionGUIDBuffer, predictionGUID)
	end

	local transmitStr = "client" .. transmitEvent:sub(1, 1):upper() .. transmitEvent:sub(2)
	transmitter:fire(
		transmitStr,
		player,
		transmitData
	)

	transmitter.ref:fire(
		transmitStr,
		player,
		transmitData
	)
end

function ServerTransmitter:_send(transmitter, player, eventName, ...)
	self._event:FireClient(
		player,
		self.fabric.namespace,
		self.fabric.serializer:serialize(transmitter.ref),
		transmitter.predictionGUIDBuffer,
		eventName,
		...
	)

	if transmitter.predictionGUIDBuffer then
		transmitter.predictionGUIDBuffer = {}
	end
end

return ServerTransmitter
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0300C520B4EE42E2BC198CAFE1DE0687">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Transmitter.spec</string>
										<string name="ScriptGuid">{5D070923-B7D8-422E-A4E0-D0B7D5B765CD}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local FabricLib = require(script.Parent.Parent)
local Fabric = FabricLib.Fabric
local Promise = require(script.Parent.Parent.Parent.Promise)
local invokeClientRPC = require(script.Parent.Parent.Shared.ClientTestRPC)
-- TEST_REF must be visible to clients
local TEST_REF = Instance.new("Folder")
TEST_REF.Name = "TEST_REF"
TEST_REF.Parent = script

return function()

	-- HACK: Detect if play solo (devhub big dumb dumb https://developer.roblox.com/en-us/api-reference/function/RunService/IsRunMode)
	wait(1)
	if #Players:GetPlayers() == 0 then
		return
	end


	local testUnit

	-- TODO: since fabrics with the same namesapce share event listeners,
	-- we must use a unique namespace for each test
	local function makeFabric(namespace)
		local fabric = Fabric.new(namespace)
		FabricLib.useTags(fabric)
		FabricLib.useReplication(fabric)
		fabric:registerUnit(testUnit)
		return fabric
	end
	beforeEach(function()
		testUnit = {
			name = "TestTransmitter",
			units = {
				Replicated = {}
			},
		}
	end)

	describe("Transmitter", function()
		it("should receive from client", function()
			local fabric = makeFabric("receive")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", TEST_REF)
			expect(unit).to.be.ok()

			local done = false
			local promise = Promise.new(function(resolve)
				unit:on("clientTestEvent", function(_, test_arg)
					resolve(test_arg == "this is a test arg")
				end)
			end):andThen(function(serverDone)
				done = serverDone
			end)

			invokeClientRPC("invoke_test", {script["TransmitterClient.spec"]}, nil, {testNamePattern = "should transmit from client"})

			promise:timeout(2):await()
			expect(done).to.equal(true)
		end)

		it("should transmit to client", function()
			local fabric = makeFabric("transmit")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", TEST_REF)
			expect(unit).to.be.ok()

			-- wait for client to sub before pub
			Promise.all({
				Promise.new(function(resolve)
					resolve(invokeClientRPC("invoke_test", {script["TransmitterClient.spec"]}, nil, {testNamePattern = "should receive from server"}))
				end),
				Promise.new(function(resolve)
					unit:getUnit("Transmitter"):on("subscriberAdded", function()
						resolve(unit:getUnit("Transmitter"):broadcast("TestEvent", "this is a test arg"))
					end)
				end)
			}):timeout(2):await()
		end)

		it("should reject invalid predictive layers", function()
			local fabric = makeFabric("predictive")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", TEST_REF)
			expect(unit).to.be.ok()
			local done = false
			local promise = Promise.new(function(resolve)
				unit:on("clientTestEvent", function(_, test_arg)
					resolve(test_arg == "this is a test arg")
				end)
			end):andThen(function(serverDone)
				done = serverDone
			end)

			invokeClientRPC("invoke_test", {script["TransmitterClient.spec"]}, nil, {testNamePattern = "should send with predictive layers"})

			promise:timeout(2):await()
			expect(done).to.equal(true)
		end)

		it("should respond to valid predictive layer", function()
			local fabric = makeFabric("validPredictive")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", TEST_REF)
			expect(unit).to.be.ok()

			local done = false
			Promise.all({
				Promise.new(function(resolve)
					unit:on("clientTestEvent", function(_, test_arg)
						resolve(test_arg == "this is a test arg")
					end)
				end):andThen(function(serverDone)
					done = serverDone
					unit:mergeBaseLayer({
						testData = 2
					})
					unit:getUnit("Transmitter"):broadcast("Response")
				end),
				Promise.new(function(resolve)
					invokeClientRPC("invoke_test", {script["TransmitterClient.spec"]}, nil, {testNamePattern = "should send with valid predictive layers"})
					resolve()
				end)
			}):timeout(2):await()

			expect(done).to.equal(true)
		end)
	end)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXB0DC2ABA31C148C4B51EAA497B306E1C">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">TransmitterClient.spec</string>
											<string name="ScriptGuid">{FDA0894D-DB70-41FE-B07F-EFBE400C8542}</string>
											<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Promise = require(script.Parent.Parent.Parent.Parent.Promise)
local FabricLib = require(script.Parent.Parent.Parent)
local Fabric = FabricLib.Fabric


return function()
	if not RunService:IsClient() then
		return
	end

	local testUnit, testRef


	-- TODO: since fabrics with the same namesapce share event listeners,
	-- we must use a unique namespace for each test
	local function makeFabric(namespace)
		local fabric = Fabric.new(namespace)
		FabricLib.useTags(fabric)
		FabricLib.useReplication(fabric)
		fabric:registerUnit(testUnit)
		return fabric
	end
	beforeEach(function()
		testUnit = {
			name = "TestTransmitter",
			units = {
				Replicated = {}
			},
		}
		testRef = script.Parent:WaitForChild("TEST_REF")
	end)

	describe("Transmitter", function()
		it("should transmit from client", function()
			local fabric = makeFabric("receive")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", testRef)
			expect(unit).to.be.ok()
			unit:getUnit("Transmitter"):send("TestEvent", "this is a test arg")
		end)

		it("should receive from server", function()
			local fabric = makeFabric("transmit")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", testRef)

			local done = false
			Promise.new(function(resolve)
				unit:on("serverTestEvent", function(test_arg)
					resolve(test_arg == "this is a test arg")
				end)
			end):andThen(function(clientDone)
				done = clientDone
			end):timeout(2):await()
			expect(done).to.equal(true)
		end)

		it("should send with predictive layers", function()
			local fabric = makeFabric("predictive")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", testRef)
			expect(unit).to.be.ok()
			unit:mergeBaseLayer({
				someOtherData = true
			})
			unit:getUnit("Transmitter"):sendWithPredictiveLayer({
				testData = true
			}, "TestEvent", "this is a test arg")
			-- on same frame, check if predictive data set
			expect(unit:get("testData")).to.equal(true)
			local onRejectData = true
			Promise.new(function(resolve)
				unit:getUnit("Transmitter"):on("rejectNetworkPrediction", function()
					onRejectData = unit:get("testData")
					resolve()
				end)
			end):timeout(2):await()
			expect(onRejectData).to.never.be.ok()
		end)

		it("should send with valid predictive layers", function()
			local fabric = makeFabric("validPredictive")
			local unit = fabric:getOrCreateUnitByRef("TestTransmitter", testRef)
			expect(unit).to.be.ok()
			unit:mergeBaseLayer({
				someOtherData = true
			})
			unit:getUnit("Transmitter"):sendWithPredictiveLayer({
				testData = 1
			}, "TestEvent", "this is a test arg")
			-- on same frame, check if predictive data set
			expect(unit:get("testData")).to.equal(1)
			Promise.new(function(resolve)
				unit:on("serverResponse", function()
					resolve()
				end)
			end):timeout(5):await()
			expect(unit:get("testData")).to.equal(2)
		end)
	end)
end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBXA35E569B9C42420C863C51B8BC90D80F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Util</string>
										<string name="ScriptGuid">{A20E40F1-9384-4818-812D-F7C61669F3B9}</string>
										<ProtectedString name="Source"><![CDATA[local Util = {}

function Util.clipMask(data, mask)
	assert(type(data) == "table", "Attempt to mask on a non-table!")

	local clippedData = {}

	for k, v in pairs(data) do
		if mask[k] == true then
			clippedData[k] = v
		elseif type(mask[k]) == "table" then
			clippedData[k] = Util.clipMask(data[k], mask[k])
		end
	end

	return clippedData
end

function Util.find(array, value)
	for i, v in ipairs(array) do
		if v == value then
			return i
		end
	end
end

return Util
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX525F45DD481C4225B9C7CD40C9AB9E65">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">getOrCreate</string>
										<string name="ScriptGuid">{AF6341D7-9C05-4FE4-BB1E-61444280A535}</string>
										<ProtectedString name="Source"><![CDATA[local function getOrCreate(parent, name, class)
	local instance = parent:FindFirstChild(name)

	if not instance then
		instance = Instance.new(class)
		instance.Name = name
		instance.Parent = parent
	end

	return instance
end

return {
	getOrCreate = getOrCreate
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX77662221FE9E496D8CB250351DEA76AA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Roact</string>
									<string name="ScriptGuid">{9AB159FC-88AA-4BA7-A32B-0C31A227A0EC}</string>
									<ProtectedString name="Source"><![CDATA[local Unit = require(script.Parent.Fabric.Unit)

return function(fabric, roact)
	local roactUnit = require(script.FabricComponent)(fabric, roact)

	local function createElement(instance, props, children)
		local componentProps = {}

		if props then
			for key, value in pairs(props) do
				if getmetatable(key) == Unit then
					componentProps[key] = value
					props[key] = nil
				end
			end
		end

		if next(componentProps) then
			-- we create a roactUnit to attach fabric units to the instance
			return roact.createElement(roactUnit, {
				units = componentProps,
				createRef = function(root)
					return root(instance, props, children)
				end
			})
		else
			return roact.createElement(instance, props, children)
		end
	end

	local function setupRender(staticUnit)
		if staticUnit.render then
			staticUnit.effects = staticUnit.effects or {}
			staticUnit.effects._roactRender = function(self)
				local rootElement = staticUnit.render(self, createElement)

				if rootElement == nil and self._roactHandle then
					roact.unmount(self._roactHandle)
					self._roactHandle = nil
					return
				end

				if self._roactHandle == nil then
					self._roactHandle = roact.mount(rootElement, self.ref)

					self:on("destroy", function()
						roact.unmount(self._roactHandle)
						self._roactHandle = nil
					end)
				else
					roact.update(self._roactHandle, rootElement)
				end
			end
		end
	end

	fabric:on("unitRegistered", setupRender)
	fabric:on("unitHotReloaded", setupRender)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX67C39EF47F0147B3936995FC76C1BD7C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">FabricComponent</string>
										<string name="ScriptGuid">{6ABC4482-429D-41B9-8D6C-CA0E39104970}</string>
										<ProtectedString name="Source"><![CDATA[return function(fabric, roact)
		local FabricComponent = roact.Component:extend("FabricComponent")

		function FabricComponent:init()
				self.ref = roact.createRef()
		end

		function FabricComponent:render()
				local child = roact.oneChild(self.props[roact.Children])
				assert(not child, "FabricComponent cannot have any children!")
				assert(type(self.props.createRef) == "function", "FabricComponent requires a 'createRef' callback as a prop!")
				assert(self.props.units, "FabricComponent requires a 'units' table as a prop mapping component name -> base layer.")

				local rootCalled = false
				local createRoot = function(component, props, children)
						assert(rootCalled == false, "createRoot can only be called once!")
						props = props or {}
						rootCalled = true
						props[roact.Ref] = self.ref
						return roact.createElement(component, props, children)
				end

				local root = self.props.createRef(createRoot)

				return root
		end

		function FabricComponent:didMount()
			local ref = self.ref:getValue()
			assert(ref, "You must call createRoot in the passed createRef function!")
			for name, baseLayer in pairs(self.props.units) do
				local unit = fabric:getOrCreateUnitByRef(name, ref)
				unit:mergeBaseLayer(baseLayer)
			end
		end

		function FabricComponent:didUpdate()
			local ref = self.ref:getValue()
			assert(ref, "You must call createRoot in the passed createRef function!")
			for name, baseLayer in pairs(self.props.units) do
				local unit = fabric:getOrCreateUnitByRef(name, ref)
				unit:mergeBaseLayer(baseLayer)
			end
		end

		return FabricComponent
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX35B0AFCA756F4F11B96F44D9C5D82D88">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ServiceUnits</string>
									<string name="ScriptGuid">{09402514-0C26-4A60-AAD8-3CCF309F8206}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

return function(fabric)
	local deferredCreation

	fabric:on("unitRegistered", function(staticUnit)
		if staticUnit.isService == true then
			if deferredCreation == nil then
				deferredCreation = {}

				local connection

				connection = RunService.Heartbeat:Connect(function()
					connection:Disconnect()

					for _, staticUnitToCreate in ipairs(deferredCreation) do
						fabric:getOrCreateUnitByRef(staticUnitToCreate, game):mergeBaseLayer({})
					end

					deferredCreation = nil
				end)
			end

			table.insert(deferredCreation, staticUnit)
		end
	end)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX22DA2597DC374804B37CEF4DC5F23C64">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Shared</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX44D0475C6FAA41199845479C69F1C0D0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ClientTestRPC</string>
										<string name="ScriptGuid">{CCE13C7D-7AAA-4B6D-A32F-88C38DD4CEA5}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local __TestRPC = Instance.new("RemoteFunction")
__TestRPC.Name = "__TestRPC"
__TestRPC.Parent = ReplicatedStorage

return function(name, ...)
	local plr = Players:GetPlayers()[1]
	while not plr do
		wait()
		plr = Players:GetPlayers()[1]
	end
	return __TestRPC:InvokeClient(plr, name, ...)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCD7BA22FDDC54AF9AC6B5FFF4139C767">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Symbol</string>
										<string name="ScriptGuid">{20DFA12F-93D2-44A8-9F87-12F48F2BBD85}</string>
										<ProtectedString name="Source"><![CDATA[local Symbol = {
	_symbols = {}
}

function Symbol.named(name)
	Symbol._symbols[name] = Symbol._symbols[name] or {}

	return Symbol._symbols[name]
end

return Symbol]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0389FFB4F8F64B74A30EEB83F3FF4802">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Util</string>
										<string name="ScriptGuid">{837B8E3A-E627-4B1A-93AC-34D2E4EBB3B1}</string>
										<ProtectedString name="Source"><![CDATA[local Util = {}

function Util.assign(toObj, ...)
	for _, fromObj in ipairs({...}) do
		for key, value in pairs(fromObj) do
			toObj[key] = value
		end
	end

	return toObj
end

function Util.makeToString(staticName)
	return function(self)
		return ("%s(%s)"):format(staticName, getmetatable(self).name)
	end
end

function Util.concat(list, ...)
	local args = { ... }
	local result = {}
	for i = 1, #list do
		result[i] = list[i]
	end
	for i = 1, #args do
		local value = args[i]
		for j = 1, #value do
			result[#result + 1] = value[j]
		end
	end
	return result
end

function Util.callCounter()
	return setmetatable({
		call = function(self, key)
			self[key] += 1
		end
	}, {
		__index = function(self, key)
			self[key] = 0
			return 0
		end
	})
end

function Util.deepCopy(t)
	if type(t) == "table" then
		local n = {}
		for i,v in pairs(t) do
			n[i] = Util.deepCopy(v)
		end
		return n
	else
		return t
	end
end

function Util.deepEquals(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = Util.deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

function Util.requireAllInAnd(instance, callback, self)
	for _, object in ipairs(instance:GetChildren()) do
		if object:IsA("ModuleScript") then
			callback(self, require(object))
		else
			Util.requireAllInAnd(object, callback, self)
		end
	end
end

--- Maps values of an array through a callback and returns an array of mapped values
function Util.mapArray(array, callback)
	local results = {}

	for i, v in ipairs(array) do
		results[i] = callback(v, i)
	end

	return results
end

--- Maps arguments #2-n through callback and returns values as tuple
function Util.mapTuple(callback, ...)
	local results = {}
	for i, value in ipairs({...}) do
		results[i] = callback(value)
	end
	return unpack(results)
end

return Util
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX05AA0265D6554017ACDC364DFC937136">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tags</string>
									<string name="ScriptGuid">{42AB4CA5-360C-44B0-A51C-B890C94CA3E4}</string>
									<ProtectedString name="Source"><![CDATA[local TagWatcher = require(script.TagWatcher)

return function (fabric)
	fabric.tags = TagWatcher.new(fabric)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX38A032EB5196432B9661B5D0DCF34A02">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">TagWatcher</string>
										<string name="ScriptGuid">{41201C8E-0B9C-4AE0-8CAC-C60FFA1C0715}</string>
										<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

local TagWatcher = {}
TagWatcher.__index = TagWatcher

function TagWatcher.new(fabric)
	local self = setmetatable({
		fabric = fabric;
		_tags = {};
		_deferredCreation = nil;
		_deferredRegistration = nil;
	}, TagWatcher)

	fabric:on("unitRegistered", function(staticUnit)
		if staticUnit.tag then
			if self._deferredRegistration == nil then
				self._deferredRegistration = {}

				local connection
				connection = self.fabric.Heartbeat:Connect(function()
					connection:Disconnect()

					for _, item in ipairs(self._deferredRegistration) do
						self:listenForTag(item.tag, item)
					end

					self._deferredRegistration = nil
				end)
			end

			table.insert(self._deferredRegistration, staticUnit)
		end
	end)

	return self
end

function TagWatcher:_deferCreation(staticUnit, instance, data)
	if self._deferredCreation == nil then
		self._deferredCreation = {}

		local connection
		connection = self.fabric.Heartbeat:Connect(function()
			connection:Disconnect()

			for _, item in ipairs(self._deferredCreation) do
				self.fabric:getOrCreateUnitByRef(item.staticUnit, item.instance):mergeBaseLayer(item.data)
			end

			self._deferredCreation = nil
		end)
	end

	table.insert(self._deferredCreation, {
		staticUnit = staticUnit;
		instance = instance;
		data = data;
	})
end

function TagWatcher:listenForTag(tag, staticUnit)
	self.fabric:debug("Creating units for tag", tag)
	assert(self._tags[tag] == nil, ("Tag %q is already in use!"):format(tag))
	self._tags[tag] = true

	local function addFromTag(instance)
		local data = {}

		if
			RunService:IsClient()
			and staticUnit.units
			and staticUnit.units.Replicated
		then
			-- Create unit and let Replicated unit subscribe
			self.fabric._collection:getOrCreateUnitByRef(staticUnit, instance)
		else
			if
				instance:FindFirstChild(staticUnit.name)
				and instance[staticUnit.name].ClassName == "ModuleScript"
			then
				data = require(instance[staticUnit.name])
			end

			self.fabric._collection:getOrCreateUnitByRef(staticUnit, instance)
			self:_deferCreation(staticUnit, instance, data)
		end
	end

	local function removeFromTag(instance)
		local unit = self.fabric:getUnitByRef(staticUnit, instance)

		if unit then
			unit:fire("destroy")
		end
	end

	CollectionService:GetInstanceRemovedSignal(tag):Connect(removeFromTag)
	CollectionService:GetInstanceAddedSignal(tag):Connect(addFromTag)
	for _, instance in ipairs(CollectionService:GetTagged(tag)) do
		addFromTag(instance)
	end
end

return TagWatcher
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCBBF6BBA498342C99F0D359348B8E728">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">TagWatcher.spec</string>
										<string name="ScriptGuid">{68CE8442-9F30-4C81-9C15-E70C774039EC}</string>
										<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local Workspace = game:GetService("Workspace")
local FabricLib = require(script.Parent.Parent)
local Fabric = FabricLib.Fabric

return function()
    local fabric, testInstance, invokeHeartbeat

	beforeEach(function()
		fabric = Fabric.new("tag watcher")
		FabricLib.useTags(fabric)
		do
			-- monkey patch heartbeat
			local heartbeatBindableEvent = Instance.new("BindableEvent")
			fabric.Heartbeat = heartbeatBindableEvent.Event
			invokeHeartbeat = function(...)
				heartbeatBindableEvent:Fire(...)
			end
		end

		testInstance = Instance.new("Part")
		testInstance.Parent = Workspace
    end)

    afterEach(function()
		testInstance:Destroy()
    end)

    it("shouldn't listen before registering", function()
        local newUnit = {
            name = "Test2",
            tag = "Test2",
        }
        local newUnit2 = {
            name = "Test3",
            tag = "Test3",
            units = {
                Test2 = {}
            },
        }
        fabric:registerUnit(newUnit2)
        CollectionService:AddTag(testInstance, "Test3")
        expect(CollectionService:HasTag(testInstance, "Test3")).to.equal(true)
        fabric:registerUnit(newUnit)
        invokeHeartbeat()
        local unit = fabric:getUnitByRef("Test3", testInstance)
        expect(unit).to.be.ok()
        expect(fabric:getUnitByRef("Test2", unit)).to.be.ok()
    end)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX259C98047C2843BCBCFB983997AA8561">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Promise</string>
								<string name="ScriptGuid">{A48F6382-5BBF-42CF-8F99-916074B53602}</string>
								<ProtectedString name="Source">return _G[script.Parent:WaitForChild(&quot;FabricLib&quot;)].Promise</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2A1A7095EEB945099A7CD6458F3AF407">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">t</string>
								<string name="ScriptGuid">{710502C5-773D-423C-B5E3-418D39755C53}</string>
								<ProtectedString name="Source"><![CDATA[local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
return TS.import(script, TS.getModule(script, "t").lib.ts).t]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXDE09E997A9084AF0B8928DD4A9A16E3F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">janitor</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX93BF65B2AD604879B7E6B47A37DD3994">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">src</string>
							<string name="ScriptGuid">{83602FEC-1EA6-45EF-8491-3B44802A6455}</string>
							<ProtectedString name="Source"><![CDATA[-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark

local TS = _G[script]

local Promise = TS.Promise
local Scheduler = require(script.Scheduler)

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local FastSpawn = Scheduler.FastSpawn
local Wait = Scheduler.Wait

local TypeDefaults = {
	["function"] = true;
	RBXScriptConnection = "Disconnect";
}

--[[**
	Instantiates a new Janitor object.
	@returns [Janitor]
**--]]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[[**
	Determines if the passed object is a Janitor.
	@param [any] Object The object you are checking.
	@returns [boolean] Whether or not the object is a Janitor.
**--]]
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [any] Object The object you want to clean up.
	@param [string | true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [any?] Index The index that can be used to clean up the object manually.
	@returns [any] The object that was passed.
**--]]
function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	self[Object] = MethodName or TypeDefaults[typeof(Object)] or "Destroy"
	return Object
end

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [Promise] PromiseObject The promise you want to add to the janitor.
	@returns [Promise]
**--]]
function Janitor.__index:AddPromise(PromiseObject)
	if not Promise.is(PromiseObject) then
		error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
	end

	if PromiseObject:getStatus() == Promise.Status.Started then
		local Id = newproxy(false)
		local NewPromise = self:Add(Promise.resolve(PromiseObject), "cancel", Id)
		NewPromise:finallyCall(self.Remove, self, Id)
		return NewPromise
	else
		return PromiseObject
	end
end

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [any] Index The index you want to remove.
	@returns [Janitor] The same janitor, for chaining reasons.
**--]]
function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using `__index`.
	@param [any] Index The index that the object is stored under.
	@returns [any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [void]
**--]]
function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, MethodName in next, self do
			if Object == IndicesReference then
				continue
			end

			if MethodName == true then
				Object()
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [void]
**--]]
function Janitor.__index:Destroy()
	self:Cleanup()
	table.clear(self)
	setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

--- Makes the Janitor clean up when the instance is destroyed
-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
-- @author Corecii
local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	self.Connected = false
	self.Connection:Disconnect()
end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [Instance] Object The instance you want to link the Janitor to.
	@param [boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Reference = Instance.new("ObjectValue")
	Reference.Value = Object

	local ManualDisconnect = setmetatable({}, Disconnect)
	local Connection
	local function ChangedFunction(Obj, Par)
		if not Reference.Value then
			ManualDisconnect.Connected = false
			return self:Cleanup()
		elseif Obj == Reference.Value and not Par then
			Obj = nil
			Wait(0.03)

			if (not Reference.Value or not Reference.Value.Parent) and ManualDisconnect.Connected then
				if not Connection.Connected then
					ManualDisconnect.Connected = false
					return self:Cleanup()
				else
					while true do
						Wait(0.2)
						if not ManualDisconnect.Connected then
							return
						elseif not Connection.Connected then
							ManualDisconnect.Connected = false
							return self:Cleanup()
						elseif Reference.Value.Parent then
							return
						end
					end
				end
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection
	Object = nil
	FastSpawn(ChangedFunction, Reference.Value, Reference.Value.Parent)

	if AllowMultiple then
		self:Add(ManualDisconnect, "Disconnect")
	else
		self:Add(ManualDisconnect, "Disconnect", LinkToInstanceIndex)
	end

	return ManualDisconnect
end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [...Instance] ... All the instances you want linked.
	@returns [Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

return {
	Janitor = Janitor,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXC4F7B3E411824FB994C0B62E69039E90">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Scheduler</string>
								<string name="ScriptGuid">{8EF4C5C6-4F65-4397-9B57-27AD69C7893A}</string>
								<ProtectedString name="Source"><![CDATA[-- Scheduler
-- Original by Validark
-- Rewritten to fit the style of the repo by pobammer

-- Original: https://github.com/Validark/Roblox-TS-Libraries/tree/master/delay-spawn-wait

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local TimeFunction = RunService:IsRunning() and time or os.clock

local Scheduler = {
	TimeFunction = TimeFunction;
}

local Queue = {}
local CurrentLength = 0
local Connection

local function HeartbeatStep()
	local ClockTick = TimeFunction()

	repeat
		local Current = Queue[1]
		if Current == nil or Current.EndTime > ClockTick then
			break
		end

		local Done = CurrentLength == 1

		if Done then
			Queue[1] = nil
			CurrentLength = 0
			Connection = Connection:Disconnect()
		else
			local LastNode = Queue[CurrentLength]
			Queue[CurrentLength] = nil
			CurrentLength -= 1
			local TargetIndex = 1

			while true do
				local ChildIndex = 2 * TargetIndex
				if ChildIndex > CurrentLength then
					break
				end

				local MinChild = Queue[ChildIndex]
				local RightChildIndex = ChildIndex + 1

				if RightChildIndex <= CurrentLength then
					local RightChild = Queue[RightChildIndex]
					if RightChild.EndTime < MinChild.EndTime then
						ChildIndex = RightChildIndex
						MinChild = RightChild
					end
				end

				if LastNode.EndTime < MinChild.EndTime then
					break
				end

				Queue[TargetIndex] = MinChild
				TargetIndex = ChildIndex
			end

			Queue[TargetIndex] = LastNode
		end

		local Arguments = Current.Arguments
		local Function = Current.Function

		if typeof(Function) == "Instance" then
			if Arguments then
				Function:Fire(table.unpack(Arguments, 2, Arguments[1]))
			else
				Function:Fire(TimeFunction() - Current.StartTime)
			end
		else
			local BindableEvent = Instance.new("BindableEvent")

			if Arguments then
				BindableEvent.Event:Connect(function()
					Function(table.unpack(Arguments, 2, Arguments[1]))
				end)
			else
				BindableEvent.Event:Connect(Function)
			end

			BindableEvent:Fire(TimeFunction() - Current.StartTime)
			BindableEvent:Destroy()
		end
	until Done
end

--[[**
	"Overengineered" `delay` reimplementation. Takes parameters. This should take significantly less time to execute than the original.
	@param [number?] DelayTime The amount of time to delay for.
	@param [function] Function The function to call.
	@param [...?] ... Optional arguments to call the function with.
	@returns [void]
**--]]
function Scheduler.Delay(Seconds, Function, ...)
	-- If seconds is nil, -INF, INF, NaN, or less than MINIMUM_DELAY, assume seconds is MINIMUM_DELAY.
	if Seconds == nil or Seconds <= 0 or Seconds == math.huge then
		Seconds = 0
	end

	local StartTime = TimeFunction()
	local EndTime = StartTime + Seconds
	local Length = select("#", ...)

	if Connection == nil then -- first is nil when connection is nil
		Connection = Heartbeat:Connect(HeartbeatStep)
	end

	local Node = {
		Function = Function;
		StartTime = StartTime;
		EndTime = EndTime;
		Arguments = Length > 0 and {Length + 1, ...};
	}

	local TargetIndex = CurrentLength + 1
	CurrentLength = TargetIndex

	while true do
		local ParentIndex = (TargetIndex - TargetIndex % 2) / 2
		if ParentIndex < 1 then
			break
		end

		local ParentNode = Queue[ParentIndex]
		if ParentNode.EndTime < Node.EndTime then
			break
		end

		Queue[TargetIndex] = ParentNode
		TargetIndex = ParentIndex
	end

	Queue[TargetIndex] = Node
end

local Scheduler_Delay = Scheduler.Delay

--[[**
	Overengineered `wait` reimplementation. Uses `Scheduler.Delay`.
	@param [number?] Seconds The amount of time to yield for.
	@returns [number] The actual time yielded.
**--]]
function Scheduler.Wait(Seconds)
	local BindableEvent = Instance.new("BindableEvent")
	Scheduler_Delay(math.max(Seconds or 0.03, 0.029), BindableEvent)
	return BindableEvent.Event:Wait()
end

--[[**
	Spawns the passed function immediately using a BindableEvent. This keeps the traceback as well, and will throw an error if the function errors.
	@param [function] Function The function you are calling.
	@param [...?] ... The optional arguments to call the function with.
	@returns [void]
**--]]
function Scheduler.FastSpawn(Function, ...)
	local Arguments = table.pack(...)
	local BindableEvent = Instance.new("BindableEvent")
	BindableEvent.Event:Connect(function()
		Function(table.unpack(Arguments, 1, Arguments.n))
	end)

	BindableEvent:Fire()
	BindableEvent:Destroy()
end

return Scheduler
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX64DD3B01D7EE43138BF97C43127D3B9B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">net</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX83041A9A7237461EB7D34CFA20F996F6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">out</string>
							<string name="ScriptGuid">{65BDE045-75DA-42B2-9DCE-BE5C13BEFA44}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local NetServerContext = TS.import(script, script, "server")
local NetClientContext = TS.import(script, script, "client")
local NetDefinitions = TS.import(script, script, "definitions").default
local NetMiddleware = TS.import(script, script, "middleware").NetMiddleware
local NetSerialization = TS.import(script, script, "serialization")
local BUILD_TYPE = "TS"
--[[
	*
	* Networking Library for Roblox
	* @version 2.0
]]
local Net = {}
do
	local _0 = Net
	--[[
		*
		* An object that contains a `Serialize` method.
		* @internal Still in development
	]]
	--[[
		*
		* A serialized representation of the object
		* @internal Still in development
	]]
	--[[
		*
		* Legacy client API for Net
	]]
	local Client = NetClientContext
	_0.Client = Client
	--[[
		*
		* Legacy server API for Net
	]]
	local Server = NetServerContext
	_0.Server = Server
	--[[
		*
		* The definitions API for Net
	]]
	local Definitions = NetDefinitions
	_0.Definitions = Definitions
	--[[
		*
		* The version of RbxNet
	]]
	local VERSION = "2.1.1" .. " (" .. ("production" == "development" and "DEV " .. BUILD_TYPE or BUILD_TYPE) .. ")"
	_0.VERSION = VERSION
	--[[
		*
		* Built-in middlewares
	]]
	local Middleware = NetMiddleware
	_0.Middleware = Middleware
	--[[
		*
		* Middleware function type for Net
	]]
	--[[
		*
		* Network serialization namespace
		* @internal Still in development
	]]
	local Serialization = NetSerialization
	_0.Serialization = Serialization
end
return Net
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX0384A418CC3D4466B6101B8D6E99AC84">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">client</string>
								<string name="ScriptGuid">{2C38A6D8-9221-4129-AE15-465C0BD49241}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ClientAsyncFunction").default
local Event = TS.import(script, script, "ClientEvent").default
local GameMessagingEvent = TS.import(script, script, "ClientMessagingEvent").default
local config = TS.import(script, script.Parent, "configuration")
local ClientEvent = TS.import(script, script, "ClientEvent").default
local ClientAsyncFunction = TS.import(script, script, "ClientAsyncFunction").default
local _0 = TS.import(script, script, "ClientFunction")
local ClientFunction = _0.default
local Function = _0.default
local SetConfiguration = config.SetClientConfiguration
local GetConfiguration = config.GetConfiguration
local function GetEvent(id)
	return ClientEvent.new(id)
end
local GetEventAsync = TS.async(function(id)
	return ClientEvent:Wait(id)
end)
local GetFunctionAsync = TS.async(function(id)
	return ClientFunction:Wait(id)
end)
local GetAsyncFunctionAsync = TS.async(function(id)
	return ClientAsyncFunction:Wait(id)
end)
local function GetAsyncFunction(id)
	return ClientAsyncFunction.new(id)
end
return {
	GetEvent = GetEvent,
	GetEventAsync = GetEventAsync,
	GetFunctionAsync = GetFunctionAsync,
	GetAsyncFunctionAsync = GetAsyncFunctionAsync,
	GetAsyncFunction = GetAsyncFunction,
	SetConfiguration = SetConfiguration,
	GetConfiguration = GetConfiguration,
	Event = Event,
	AsyncFunction = AsyncFunction,
	GameMessagingEvent = GameMessagingEvent,
	Function = Function,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX8B3E282BB4CE43F081C4CE5FC66C1314">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ClientAsyncFunction</string>
									<string name="ScriptGuid">{0C4BF67D-9762-4AE9-B2AF-7331066E143D}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "configuration")
local DebugLog = _0.DebugLog
local DebugWarn = _0.DebugWarn
local _1 = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _1.getRemoteOrThrow
local IS_SERVER = _1.IS_SERVER
local waitForRemote = _1.waitForRemote
local HttpService = game:GetService("HttpService")
--[[
	*
	* An event that behaves like a function
	* @rbxts client
]]
local ClientAsyncFunction
do
	ClientAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ClientAsyncFunction"
		end,
	})
	ClientAsyncFunction.__index = ClientAsyncFunction
	function ClientAsyncFunction.new(...)
		local self = setmetatable({}, ClientAsyncFunction)
		self:constructor(...)
		return self
	end
	function ClientAsyncFunction:constructor(name)
		self.timeout = 10
		self.listeners = {}
		self.instance = getRemoteOrThrow("AsyncRemoteFunction", name)
		local _2 = not IS_SERVER
		assert(_2, "Cannot create a Net.ClientAsyncFunction on the Server!")
	end
	function ClientAsyncFunction:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("AsyncRemoteFunction", name, 60))
			resolve(ClientAsyncFunction.new(name))
		end))
	end
	function ClientAsyncFunction:SetCallTimeout(timeout)
		local _2 = timeout > 0
		assert(_2, "timeout must be a positive number")
		self.timeout = timeout
	end
	function ClientAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ClientAsyncFunction:SetCallback(callback)
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		self.connector = self.instance.OnClientEvent:Connect(TS.async(function(...)
			local args = { ... }
			local _2 = args
			local eventId = _2[1]
			local data = _2[2]
			local _3 = eventId
			local _4 = type(_3) == "string"
			if _4 then
				local _5 = data
				_4 = type(_5) == "table"
			end
			if _4 then
				local result = callback(unpack(data))
				if TS.Promise.is(result) then
					local _5 = result
					local _6 = function(promiseResult)
						self.instance:FireServer(eventId, promiseResult)
					end
					_5:andThen(_6):catch(function(err)
						warn("[rbx-net] Failed to send response to server: " .. err)
					end)
				else
					self.instance:FireServer(eventId, result)
				end
			else
				warn("Recieved message without eventId")
			end
		end))
	end
	ClientAsyncFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		local id = HttpService:GenerateGUID(false)
		local _2 = self.instance
		local _3 = {}
		for _4, _5 in pairs(args) do
			_3[_4] = _5
		end
		_2:FireServer(id, _3)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			DebugLog("Connected CallServerAsync EventId", id)
			local connection
			connection = self.instance.OnClientEvent:Connect(function(...)
				local recvArgs = { ... }
				local _4 = recvArgs
				local eventId = _4[1]
				local data = _4[2]
				local _5 = eventId
				local _6 = type(_5) == "string"
				if _6 then
					_6 = data ~= nil
				end
				if _6 then
					if eventId == id then
						DebugLog("Disconnected CallServerAsync EventId", eventId)
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _4 = self.listeners
			local _5 = id
			local _6 = {
				connection = connection,
				timeout = self.timeout,
			}
			-- ▼ Map.set ▼
			_4[_5] = _6
			-- ▲ Map.set ▲
			repeat
				do
					game:GetService("RunService").Heartbeat:Wait()
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			local _7 = self.listeners
			local _8 = id
			-- ▼ Map.delete ▼
			_7[_8] = nil
			-- ▲ Map.delete ▲
			if tick() >= startTime and connection.Connected then
				DebugWarn("(timeout) Disconnected CallServerAsync EventId", id)
				connection:Disconnect()
				reject("Request to server timed out after " .. tostring(self.timeout) .. " seconds")
			end
		end)
	end)
end
return {
	default = ClientAsyncFunction,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX99E3DDB8D2ED4BD495B6345DE2C197C9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ClientEvent</string>
									<string name="ScriptGuid">{AC269EC1-48D9-42D9-A9DD-7DD8A0F1E754}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _0.getRemoteOrThrow
local IS_SERVER = _0.IS_SERVER
local waitForRemote = _0.waitForRemote
--[[
	*
	* Interface for client listening events
]]
--[[
	*
	* Interface for client sender events
]]
local ClientEvent
do
	ClientEvent = setmetatable({}, {
		__tostring = function()
			return "ClientEvent"
		end,
	})
	ClientEvent.__index = ClientEvent
	function ClientEvent.new(...)
		local self = setmetatable({}, ClientEvent)
		self:constructor(...)
		return self
	end
	function ClientEvent:constructor(name)
		self.instance = getRemoteOrThrow("RemoteEvent", name)
		local _1 = not IS_SERVER
		assert(_1, "Cannot fetch NetClientEvent on the server!")
	end
	function ClientEvent:GetInstance()
		return self.instance
	end
	function ClientEvent:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteEvent", name, 60))
			resolve(ClientEvent.new(name))
		end))
	end
	function ClientEvent:SendToServer(...)
		local args = { ... }
		self.instance:FireServer(unpack(args))
	end
	function ClientEvent:Connect(callback)
		return self.instance.OnClientEvent:Connect(callback)
	end
end
local default = ClientEvent
return {
	default = default,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFEFD38E3F400440186BEFA04308764AD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ClientFunction</string>
									<string name="ScriptGuid">{303E563D-6EBF-4CEB-97D9-FA7146939A65}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _0.getRemoteOrThrow
local IS_SERVER = _0.IS_SERVER
local waitForRemote = _0.waitForRemote
local ClientFunction
do
	ClientFunction = setmetatable({}, {
		__tostring = function()
			return "ClientFunction"
		end,
	})
	ClientFunction.__index = ClientFunction
	function ClientFunction.new(...)
		local self = setmetatable({}, ClientFunction)
		self:constructor(...)
		return self
	end
	function ClientFunction:constructor(name)
		self.instance = getRemoteOrThrow("RemoteFunction", name)
		local _1 = not IS_SERVER
		assert(_1, "Cannot create a Net.ClientFunction on the Server!")
	end
	function ClientFunction:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteFunction", name, 60))
			resolve(ClientFunction.new(name))
		end))
	end
	function ClientFunction:CallServer(...)
		local args = { ... }
		return self.instance:InvokeServer(unpack(args))
	end
	ClientFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		return TS.Promise.defer(function(resolve)
			local result = self.instance:InvokeServer(unpack(args))
			resolve(result)
		end)
	end)
end
return {
	default = ClientFunction,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8E7B3BB173E04E59AFA4F7D315F60E8E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ClientMessagingEvent</string>
									<string name="ScriptGuid">{16F0AC0D-AA26-41D9-9DE7-C9AF4FA83ABE}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local getGlobalRemoteId = TS.import(script, script.Parent.Parent, "internal").getGlobalRemote
local ClientEvent = TS.import(script, script.Parent, "ClientEvent").default
--[[
	*
	* Client counter-part to GlobalServerEvent
]]
local ClientMessagingEvent
do
	ClientMessagingEvent = setmetatable({}, {
		__tostring = function()
			return "ClientMessagingEvent"
		end,
	})
	ClientMessagingEvent.__index = ClientMessagingEvent
	function ClientMessagingEvent.new(...)
		local self = setmetatable({}, ClientMessagingEvent)
		self:constructor(...)
		return self
	end
	function ClientMessagingEvent:constructor(name)
		self.instance = ClientEvent.new(getGlobalRemoteId(name))
	end
	function ClientMessagingEvent:Connect(callback)
		self.instance:Connect(callback)
	end
end
return {
	default = ClientMessagingEvent,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX6218869CBFB94625A6DC7C0FE536E5D1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">configuration</string>
								<string name="ScriptGuid">{C1B0803A-D5D0-4845-BA46-62C3B9DC500D}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local IS_CLIENT = TS.import(script, script.Parent, "internal").IS_CLIENT
local runService = game:GetService("RunService")
local IS_SERVER = runService:IsServer()
local Configuration = {
	ServerThrottleResetTimer = 60,
	EnableDebugMessages = "production" == "development",
	ServerThrottleMessage = "Request limit exceeded ({limit}) by {player} via {remote}",
}
local NetConfig = {}
do
	local _0 = NetConfig
	-- * @internal
	local DebugEnabled = "production" == "development"
	_0.DebugEnabled = DebugEnabled
	local function SetClient(config)
		local _1 = IS_CLIENT
		assert(_1, "Use SetClient on the client!")
		local _2 = {}
		for _3, _4 in pairs(Configuration) do
			_2[_3] = _4
		end
		for _3, _4 in pairs(config) do
			_2[_3] = _4
		end
		Configuration = _2
	end
	_0.SetClient = SetClient
	local function Set(config)
		local _1 = IS_SERVER
		assert(_1, "Use Set on the server!")
		local _2 = {}
		for _3, _4 in pairs(Configuration) do
			_2[_3] = _4
		end
		for _3, _4 in pairs(config) do
			_2[_3] = _4
		end
		Configuration = _2
	end
	_0.Set = Set
	local function Get()
		return Configuration
	end
	_0.Get = Get
	--[[
		*
		* @deprecated
		* @rbxts client
	]]
	local function SetClientConfiguration(key, value)
		local _1 = IS_CLIENT
		assert(_1, "Use SetConfiguration on the server!")
		if key == "EnableDebugMessages" then
			Configuration.EnableDebugMessages = value
		end
	end
	_0.SetClientConfiguration = SetClientConfiguration
	--[[
		*
		* @rbxts server
		* @deprecated
		*
	]]
	local function SetConfiguration(key, value)
		local _1 = IS_SERVER
		assert(_1, "Cannot set configuration on client!")
		Configuration[key] = value
	end
	_0.SetConfiguration = SetConfiguration
	--[[
		*
		* @deprecated
	]]
	local function GetConfiguration(key)
		return Configuration[key]
	end
	_0.GetConfiguration = GetConfiguration
	-- * @internal
	local function DebugWarn(...)
		local message = { ... }
		if DebugEnabled then
			warn("[rbx-net-debug]", unpack(message))
		end
	end
	_0.DebugWarn = DebugWarn
	-- * @internal
	local function DebugLog(...)
		local message = { ... }
		if DebugEnabled then
			print("[rbx-net-debug]", unpack(message))
		end
	end
	_0.DebugLog = DebugLog
end
return NetConfig
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE3219DC5FF8C46669F8DF1A439EA7DFC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">definitions</string>
								<string name="ScriptGuid">{99704840-45BB-43AA-A158-2253EFFB9D43}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
-- eslint-disable @typescript-eslint/no-explicit-any
local DeclarationTypeCheck = TS.import(script, script, "Types").DeclarationTypeCheck
local ServerDefinitionBuilder = TS.import(script, script, "ServerDefinitionBuilder").ServerDefinitionBuilder
local ClientDefinitionBuilder = TS.import(script, script, "ClientDefinitionBuilder").ClientDefinitionBuilder
local warnOnce = TS.import(script, script.Parent, "internal").warnOnce
local NamespaceBuilder = TS.import(script, script, "NamespaceBuilder").NamespaceBuilder
local NetDefinitions = {}
do
	local _0 = NetDefinitions
	--[[
		*
		* Validates the specified declarations to ensure they're valid before usage
		* @param declarations The declarations
	]]
	local function validateDeclarations(declarations)
		for _, declaration in pairs(declarations) do
			local _1 = DeclarationTypeCheck.check(declaration.Type)
			local _2 = DeclarationTypeCheck.errorMessage
			assert(_1, _2)
		end
	end
	--[[
		*
		* Creates definitions for Remote instances that can be used on both the client and server.
		* @description https://docs.vorlias.com/rbx-net/docs/2.0/definitions#definitions-oh-my
		* @param declarations
	]]
	local function Create(declarations, globalMiddleware)
		validateDeclarations(declarations)
		local _1 = {
			Server = ServerDefinitionBuilder.new(declarations, globalMiddleware),
			Client = ClientDefinitionBuilder.new(declarations),
		}
		return _1
	end
	_0.Create = Create
	--[[
		*
		* Defines a namespace of remote definitions, which can be retrieved via `GetNamespace(namespaceId)`
		*
		* E.g.
		* ```ts
		* const Remotes = Net.Definitions.Create({
		* 		ExampleGroup: Net.Definitions.Namespace({
		* 			ExampleGroupRemote: Net.Definitions.ServerToClientEvent<[message: string]>(),
		* 		}),
		* });
		* const ExampleGroupRemote = Remotes.Server.GetNamespace("ExampleGroup").Create("ExampleGroupRemote");
		* ```
		*
		* This is useful for categorizing remotes by feature.
	]]
	local function Namespace(declarations)
		return {
			Type = "Namespace",
			Definitions = NamespaceBuilder.new(declarations),
		}
	end
	_0.Namespace = Namespace
	--[[
		*
		* Defines a function in which strictly the client can call the server asynchronously
		*
		* `Client` [`Calls`] -> `Server` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Server` [`Responds to Call`] -> `Client` [`Recieves Response`]
	]]
	local function ServerAsyncFunction(mw)
		return {
			Type = "AsyncFunction",
			ServerMiddleware = mw,
		}
	end
	_0.ServerAsyncFunction = ServerAsyncFunction
	--[[
		*
		* Defines a function in which strictly the server can call the client asynchronously
		*
		* `Server` [`Calls`] -> `Client` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Client` [`Responds to Call`] -> `Server` [`Recieves Response`]
	]]
	local function ClientAsyncFunction()
		return {
			Type = "AsyncFunction",
		}
	end
	_0.ClientAsyncFunction = ClientAsyncFunction
	--[[
		*
		* Defines a regular function in which strictly the client can call the server synchronously
		*
		* (Synchronous) `Client` [`Calls`, `Recieves Response`] <- (yields for response) -> `Server` [`Recieves Call`, `Responds`]
	]]
	local function ServerFunction(mw)
		return {
			Type = "Function",
			ServerMiddleware = mw,
		}
	end
	_0.ServerFunction = ServerFunction
	--[[
		*
		* Defines an event in which strictly the server fires an event that is recieved by clients
		*
		* `Server` [`Sends`] => `Client(s)` [`Recieves`]
		*
		* On the client, this will give an event that can use `Connect`.
		*
		* On the server, this will give an event that can use `SendToPlayer`, `SendToAllPlayers`, `SendToAllPlayersExcept`
		*
	]]
	local function ServerToClientEvent()
		return {
			ServerMiddleware = {},
			Type = "Event",
		}
	end
	_0.ServerToClientEvent = ServerToClientEvent
	--[[
		*
		* Defines an event in which strictly clients fire an event that's recieved by the server
		*
		* `Client(s)` [`Sends`] => `Server` [`Recieves`]
		*
		* On the client, this will give an event that can use `SendToServer`.
		*
		* On the server, this will give an event that can use `Connect`.
		*
		* @param mw The middleware of this event.
	]]
	local function ClientToServerEvent(mw)
		return {
			Type = "Event",
			ServerMiddleware = mw,
		}
	end
	_0.ClientToServerEvent = ClientToServerEvent
	--[[
		*
		* Defines a remote event that can be fired both from the client and server
		*
		* This should only be required in rare use cases where `ClientToServerEvent` or `ServerToClientEvent` is not sufficient.
	]]
	local function BidirectionalEvent()
		return {
			Type = "Event",
			ServerMiddleware = {},
		}
	end
	_0.BidirectionalEvent = BidirectionalEvent
	-- / REGION deprecated members
	--[[
		*
		* Creates a definition for a function
		* @deprecated
	]]
	local function Function(mw)
		warnOnce("Definition '" .. "Function" .. "' is deprecated, use '" .. "ServerFunction" .. "' in your declarations - https://github.com/roblox-aurora/rbx-net/issues/35")
		return {
			Type = "Function",
			ServerMiddleware = mw,
		}
	end
	_0.Function = Function
	--[[
		*
		* Creates a definition for an event
		*
		*
		* ### If the event is fired by the client to the server, use `ClientToServerEvent`.
		* ### If the event is fired by the server to the client, use `ServerToClientEvent`.
		* ### If the event is both fired by client and server, use `BidirectionalEvent`.
		*
		* @deprecated This will be removed in future - please redesign your definitions
		*
	]]
	local function Event(mw)
		warnOnce("Definition '" .. "Event" .. "' is deprecated, use '" .. "ServerToClientEvent" .. "', '" .. "ClientToServerEvent" .. "' or '" .. "BidirectionalEvent" .. "' in your declarations - https://github.com/roblox-aurora/rbx-net/issues/35")
		return {
			Type = "Event",
			ServerMiddleware = mw,
		}
	end
	_0.Event = Event
	--[[
		*
		* Creates a definition for an async function
		*
		* ### If the function callback is on the server, use `AsyncServerFunction`.
		* ### If the function callback is on the client, use `AsyncClientFunction`.
		*
		* @deprecated This will be removed in future - please redesign your definitions
	]]
	local function AsyncFunction(mw)
		warnOnce("Definition '" .. "AsyncFunction" .. "' is deprecated, use '" .. "ServerAsyncFunction" .. "' or '" .. "ClientAsyncFunction" .. "' in your declarations - https://github.com/roblox-aurora/rbx-net/issues/35")
		return {
			Type = "AsyncFunction",
			ServerMiddleware = mw,
		}
	end
	_0.AsyncFunction = AsyncFunction
end
local default = NetDefinitions
return {
	default = default,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX854E47DE44444D1084A73895E9B22280">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ClientDefinitionBuilder</string>
									<string name="ScriptGuid">{8F4F461D-9373-4202-AA95-7B00A3573FA5}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local ClientAsyncFunction = TS.import(script, script.Parent.Parent, "client", "ClientAsyncFunction").default
local ClientEvent = TS.import(script, script.Parent.Parent, "client", "ClientEvent").default
local ClientFunction = TS.import(script, script.Parent.Parent, "client", "ClientFunction").default
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local ClientDefinitionBuilder
do
	ClientDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ClientDefinitionBuilder"
		end,
	})
	ClientDefinitionBuilder.__index = ClientDefinitionBuilder
	function ClientDefinitionBuilder.new(...)
		local self = setmetatable({}, ClientDefinitionBuilder)
		self:constructor(...)
		return self
	end
	function ClientDefinitionBuilder:constructor(declarations, namespace)
		if namespace == nil then
			namespace = ""
		end
		self.namespace = namespace
		local _0 = declarationMap
		local _1 = self
		local _2 = declarations
		-- ▼ Map.set ▼
		_0[_1] = _2
		-- ▲ Map.set ▲
	end
	function ClientDefinitionBuilder:toString()
		return "[" .. "ClientDefinitionBuilder" .. "]"
	end
	function ClientDefinitionBuilder:Get(remoteId)
		local _0 = declarationMap
		local _1 = self
		local item = _0[_1][remoteId]
		local _2
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _3 = ":"
			if _3 == nil then
				_3 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_2 = (table.concat({ self.namespace, remoteId }, _3))
		else
			_2 = remoteId
		end
		remoteId = _2
		local _3 = item and item.Type
		local _4 = "'" .. remoteId .. "' is not defined in this definition."
		assert(_3, _4)
		if item.Type == "Function" then
			return ClientFunction.new(remoteId)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction.new(remoteId)
		elseif item.Type == "Event" then
			return ClientEvent.new(remoteId)
		end
		error("Invalid Type")
	end
	function ClientDefinitionBuilder:GetNamespace(groupName)
		local _0 = declarationMap
		local _1 = self
		local group = _0[_1][groupName]
		local _2 = group.Type == "Namespace"
		assert(_2)
		local _3 = group.Definitions
		local _4
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _5 = ":"
			if _5 == nil then
				_5 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_4 = table.concat({ self.namespace, groupName }, _5)
		else
			_4 = groupName
		end
		return _3:_buildClientDefinition(_4)
	end
	ClientDefinitionBuilder.WaitFor = TS.async(function(self, remoteId)
		local _0 = declarationMap
		local _1 = self
		local item = _0[_1][remoteId]
		local _2
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _3 = ":"
			if _3 == nil then
				_3 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_2 = (table.concat({ self.namespace, remoteId }, _3))
		else
			_2 = remoteId
		end
		remoteId = _2
		local _3 = item and item.Type
		local _4 = "'" .. remoteId .. "' is not defined in this definition."
		assert(_3, _4)
		if item.Type == "Function" then
			return ClientFunction:Wait(remoteId)
		elseif item.Type == "Event" then
			return ClientEvent:Wait(remoteId)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction:Wait(remoteId)
		end
		error("Invalid Type")
	end)
	function ClientDefinitionBuilder:OnEvent(name, fn)
		local result = self:Get(name)
		result:Connect(fn)
	end
	function ClientDefinitionBuilder:OnFunction(name, fn)
		local result = self:Get(name)
		result:SetCallback(fn)
	end
	function ClientDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ClientDefinitionBuilder = ClientDefinitionBuilder,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD29D50D810664F4EA77A75F2DD752637">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">NamespaceBuilder</string>
									<string name="ScriptGuid">{822490BF-A413-4B60-B3F0-CDA056BF1AED}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local ClientDefinitionBuilder = TS.import(script, script.Parent, "ClientDefinitionBuilder").ClientDefinitionBuilder
local ServerDefinitionBuilder = TS.import(script, script.Parent, "ServerDefinitionBuilder").ServerDefinitionBuilder
local RunService = game:GetService("RunService")
-- Isolate the definitions since we don't need to access them anywhere else.
local declarationMap = setmetatable({}, {
	__mode = "k",
})
--[[
	*
	* A namespace builder. Internally used to construct definition builders
]]
local NamespaceBuilder
do
	NamespaceBuilder = setmetatable({}, {
		__tostring = function()
			return "NamespaceBuilder"
		end,
	})
	NamespaceBuilder.__index = NamespaceBuilder
	function NamespaceBuilder.new(...)
		local self = setmetatable({}, NamespaceBuilder)
		self:constructor(...)
		return self
	end
	function NamespaceBuilder:constructor(declarations)
		local _0 = declarationMap
		local _1 = self
		local _2 = declarations
		-- ▼ Map.set ▼
		_0[_1] = _2
		-- ▲ Map.set ▲
	end
	function NamespaceBuilder:_buildServerDefinition(globalMiddleware, namespace)
		local _0 = RunService:IsServer()
		assert(_0)
		local _1 = declarationMap
		local _2 = self
		return ServerDefinitionBuilder.new(_1[_2], globalMiddleware, namespace)
	end
	function NamespaceBuilder:_buildClientDefinition(namespace)
		local _0 = RunService:IsClient()
		assert(_0)
		local _1 = declarationMap
		local _2 = self
		return ClientDefinitionBuilder.new(_1[_2], namespace)
	end
end
return {
	NamespaceBuilder = NamespaceBuilder,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9594EE2E69224D70B093F0C42B5FD158">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ServerDefinitionBuilder</string>
									<string name="ScriptGuid">{3BF77463-E18A-4BE9-BD92-CBD92E108EBE}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local ServerAsyncFunction = TS.import(script, script.Parent.Parent, "server", "ServerAsyncFunction").default
local ServerEvent = TS.import(script, script.Parent.Parent, "server", "ServerEvent").default
local ServerFunction = TS.import(script, script.Parent.Parent, "server", "ServerFunction").default
local CollectionService = game:GetService("CollectionService")
-- Tidy up all the types here.
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local remoteEventCache = {}
local remoteAsyncFunctionCache = {}
local remoteFunctionCache = {}
local ServerDefinitionBuilder
do
	ServerDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ServerDefinitionBuilder"
		end,
	})
	ServerDefinitionBuilder.__index = ServerDefinitionBuilder
	function ServerDefinitionBuilder.new(...)
		local self = setmetatable({}, ServerDefinitionBuilder)
		self:constructor(...)
		return self
	end
	function ServerDefinitionBuilder:constructor(declarations, globalMiddleware, namespace)
		if namespace == nil then
			namespace = ""
		end
		self.globalMiddleware = globalMiddleware
		self.namespace = namespace
		local _0 = declarationMap
		local _1 = self
		local _2 = declarations
		-- ▼ Map.set ▼
		_0[_1] = _2
		-- ▲ Map.set ▲
	end
	function ServerDefinitionBuilder:toString()
		return "[" .. "ServerDefinitionBuilder" .. "]"
	end
	function ServerDefinitionBuilder:OnEvent(name, fn)
		local result = self:Create(name)
		result:Connect(fn)
	end
	function ServerDefinitionBuilder:GetNamespace(groupId)
		local _0 = declarationMap
		local _1 = self
		local group = _0[_1][groupId]
		local _2 = group.Type == "Namespace"
		assert(_2)
		local _3 = group.Definitions
		local _4 = self.globalMiddleware
		local _5
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _6 = ":"
			if _6 == nil then
				_6 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_5 = table.concat({ self.namespace, groupId }, _6)
		else
			_5 = groupId
		end
		return _3:_buildServerDefinition(_4, _5)
	end
	function ServerDefinitionBuilder:Create(remoteId)
		local _0 = declarationMap
		local _1 = self
		local item = _0[_1][remoteId]
		local _2
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _3 = ":"
			if _3 == nil then
				_3 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_2 = (table.concat({ self.namespace, remoteId }, _3))
		else
			_2 = remoteId
		end
		remoteId = _2
		local _3 = item and item.Type
		local _4 = "'" .. remoteId .. "' is not defined in this definition."
		assert(_3, _4)
		if item.Type == "Function" then
			local func
			-- This should make certain use cases cheaper
			local _5 = remoteFunctionCache
			local _6 = remoteId
			if _5[_6] ~= nil then
				local _7 = remoteFunctionCache
				local _8 = remoteId
				return _7[_8]
			else
				if item.ServerMiddleware then
					func = ServerFunction.new(remoteId, item.ServerMiddleware)
				else
					func = ServerFunction.new(remoteId)
				end
				CollectionService:AddTag(func:GetInstance(), "NetDefinitionManaged")
				local _7 = remoteFunctionCache
				local _8 = remoteId
				local _9 = func
				-- ▼ Map.set ▼
				_7[_8] = _9
				-- ▲ Map.set ▲
			end
			local _7 = self.globalMiddleware
			if _7 ~= nil then
				local _8 = function(mw)
					return func:_use(mw)
				end
				-- ▼ ReadonlyArray.forEach ▼
				for _9, _10 in ipairs(_7) do
					_8(_10, _9 - 1, _7)
				end
				-- ▲ ReadonlyArray.forEach ▲
			end
			return func
		elseif item.Type == "AsyncFunction" then
			local asyncFunction
			-- This should make certain use cases cheaper
			local _5 = remoteAsyncFunctionCache
			local _6 = remoteId
			if _5[_6] ~= nil then
				local _7 = remoteAsyncFunctionCache
				local _8 = remoteId
				return _7[_8]
			else
				if item.ServerMiddleware then
					asyncFunction = ServerAsyncFunction.new(remoteId, item.ServerMiddleware)
				else
					asyncFunction = ServerAsyncFunction.new(remoteId)
				end
				CollectionService:AddTag(asyncFunction:GetInstance(), "NetDefinitionManaged")
				local _7 = remoteAsyncFunctionCache
				local _8 = remoteId
				local _9 = asyncFunction
				-- ▼ Map.set ▼
				_7[_8] = _9
				-- ▲ Map.set ▲
			end
			local _7 = self.globalMiddleware
			if _7 ~= nil then
				local _8 = function(mw)
					return asyncFunction:_use(mw)
				end
				-- ▼ ReadonlyArray.forEach ▼
				for _9, _10 in ipairs(_7) do
					_8(_10, _9 - 1, _7)
				end
				-- ▲ ReadonlyArray.forEach ▲
			end
			return asyncFunction
		elseif item.Type == "Event" then
			local event
			-- This should make certain use cases cheaper
			local _5 = remoteEventCache
			local _6 = remoteId
			if _5[_6] ~= nil then
				local _7 = remoteEventCache
				local _8 = remoteId
				return _7[_8]
			else
				if item.ServerMiddleware then
					event = ServerEvent.new(remoteId, item.ServerMiddleware)
				else
					event = ServerEvent.new(remoteId)
				end
				CollectionService:AddTag(event:GetInstance(), "NetDefinitionManaged")
				local _7 = remoteEventCache
				local _8 = remoteId
				local _9 = event
				-- ▼ Map.set ▼
				_7[_8] = _9
				-- ▲ Map.set ▲
			end
			local _7 = self.globalMiddleware
			if _7 ~= nil then
				local _8 = function(mw)
					return event:_use(mw)
				end
				-- ▼ ReadonlyArray.forEach ▼
				for _9, _10 in ipairs(_7) do
					_8(_10, _9 - 1, _7)
				end
				-- ▲ ReadonlyArray.forEach ▲
			end
			return event
		end
		error("Invalid Type")
	end
	function ServerDefinitionBuilder:OnFunction(name, fn)
		local result = self:Create(name)
		result:SetCallback(fn)
	end
	function ServerDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ServerDefinitionBuilder = ServerDefinitionBuilder,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD0D9625A77C0410BAD96A72E255B522D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Types</string>
									<string name="ScriptGuid">{207EC862-4532-4AF1-99F7-E8164DBF53AA}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
--[[
	*
	* Types
	*
	* I will admit, this is a lot of type spaghetti. It makes the definitions work good though. :D
]]
local oneOf = TS.import(script, script.Parent.Parent, "internal", "validator").oneOf
--[[
	*
	* The DefinitionBuilders type
]]
--[[
	*
	* @deprecated
]]
--[[
	*
	* A declaration for an async client function
]]
--[[
	*
	* A declaration for an async server function
]]
-- * @deprecated
--[[
	*
	* A declaration for a client -> server event
]]
--[[
	*
	* A declaration for a server -> client event
]]
--[[
	*
	* A declaration for a Bidirectional event
]]
--[[
	*
	* A declaration group
]]
-- //////////////////////////////
-- * Inference Magic
-- /////////////////////////////
--[[
	*
	* This infers the client remote type based on the given value
]]
--[[
	*
	* This infers the server remote type based on the given value
]]
-- ///////////////////////////////////////
-- * Results
-- ///////////////////////////////////////
local DeclarationTypeCheck = oneOf("Event", "Function", "AsyncFunction", "Namespace")
return {
	DeclarationTypeCheck = DeclarationTypeCheck,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX81AB43941DD4428B80BD7AB555ABF7E4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">internal</string>
								<string name="ScriptGuid">{27876611-4F23-4909-AEA2-6E4CA6853691}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local HttpService = game:GetService("HttpService")
local runService = game:GetService("RunService")
local collectionService = game:GetService("CollectionService")
-- * @internal
local IS_SERVER = not runService:IsRunning() or runService:IsServer()
-- * @internal
local IS_CLIENT = runService:IsRunning() and runService:IsClient()
local IS_RUNNING = runService:IsRunning()
-- * @internal
local MAX_CLIENT_WAITFORCHILD_TIMEOUT = 10
-- * @internal
local function getGlobalRemote(name)
	return ":\\" .. name
end
-- * @internal
local function isLuaTable(value)
	local _0 = value
	return type(_0) == "table"
end
-- * @internal
local NetMiddlewareEvent
do
	NetMiddlewareEvent = setmetatable({}, {
		__tostring = function()
			return "NetMiddlewareEvent"
		end,
	})
	NetMiddlewareEvent.__index = NetMiddlewareEvent
	function NetMiddlewareEvent.new(...)
		local self = setmetatable({}, NetMiddlewareEvent)
		self:constructor(...)
		return self
	end
	function NetMiddlewareEvent:constructor(netInstance)
		self.netInstance = netInstance
	end
	function NetMiddlewareEvent:GetInstance()
		return self.netInstance:GetInstance()
	end
end
local REMOTES_FOLDER_NAME = "_NetManaged"
-- * @internal
-- * @internal
local ServerTickFunctions = {}
-- * @internal
local function findOrCreateFolder(parent, name)
	local folder = parent:FindFirstChild(name)
	if folder then
		return folder
	else
		folder = Instance.new("Folder", parent)
		folder.Name = name
		return folder
	end
end
-- const dist = $env<"TS" | "Luau" | "TestTS">("TYPE", "TS");
local location = script.Parent
local remoteFolder = findOrCreateFolder(location, REMOTES_FOLDER_NAME)
--[[
	*
	* Errors with variables formatted in a message
	* @param message The message
	* @param vars variables to pass to the error message
]]
local function errorft(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _0 = message
	local _1 = function(token)
		local _2 = vars[token]
		if _2 == nil then
			_2 = token
		end
		return _2
	end
	local _2 = string.gsub(_0, "{([%w_][%w%d_]*)}", _1)
	message = _2[1]
	error(message, 2)
end
local traceSet = {}
local function warnOnce(message)
	local trace = debug.traceback()
	local _0 = traceSet
	local _1 = trace
	if _0[_1] ~= nil then
		return nil
	end
	local _2 = traceSet
	local _3 = trace
	-- ▼ Set.add ▼
	_2[_3] = true
	-- ▲ Set.add ▲
	warn("[rbx-net] " .. message)
end
local function format(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _0 = message
	local _1 = function(token)
		local _2 = vars[token]
		if _2 == nil then
			_2 = token
		end
		return _2
	end
	local _2 = string.gsub(_0, "{([%w_][%w%d_]*)}", _1)
	message = _2[1]
	return message
end
-- * @internal
local findRemote
local function waitForRemote(remoteType, name, timeout)
	return TS.Promise.defer(function(resolve, reject)
		local i = 0
		local result
		repeat
			do
				local step = runService.Heartbeat:Wait()
				i += step
				result = findRemote(remoteType, name)
			end
		until not (i < timeout and not result)
		if result then
			resolve(result)
		else
			reject("Timed out while waiting for " .. remoteType .. " '" .. name .. "' after " .. tostring(timeout) .. " seconds.")
		end
	end)
end
-- * @internal
function findRemote(remoteType, name)
	if remoteType == "AsyncRemoteFunction" then
		local _0 = collectionService:GetTagged("NetManagedAsyncFunction")
		local _1 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _2 = nil
		for _3, _4 in ipairs(_0) do
			if _1(_4, _3 - 1, _0) == true then
				_2 = _4
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _2
	elseif remoteType == "RemoteEvent" then
		local _0 = collectionService:GetTagged("NetManagedEvent")
		local _1 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _2 = nil
		for _3, _4 in ipairs(_0) do
			if _1(_4, _3 - 1, _0) == true then
				_2 = _4
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _2
	elseif remoteType == "RemoteFunction" then
		local _0 = collectionService:GetTagged("NetManagedLegacyFunction")
		local _1 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _2 = nil
		for _3, _4 in ipairs(_0) do
			if _1(_4, _3 - 1, _0) == true then
				_2 = _4
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _2
	end
	error("Invalid Remote Access")
end
-- * @internal
local function getRemoteOrThrow(remoteType, name)
	local existing = findRemote(remoteType, name)
	if existing then
		return existing
	else
		error("Could not find Remote of type " .. remoteType .. ' called "' .. name .. '"')
	end
end
-- * @internal
local function findOrCreateRemote(remoteType, name)
	local existing = findRemote(remoteType, name)
	if existing then
		if collectionService:HasTag(existing, "NetDefinitionManaged") then
			warnOnce("Fetching " .. remoteType .. " '" .. name .. "', which is a DefinitionsManaged instance from a non-definitions context. This is considered unsafe.")
		end
		return existing
	else
		if not IS_SERVER then
			error("Creation of Events or Functions must be done on server!")
		end
		local remote
		if remoteType == "RemoteEvent" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedEvent")
		elseif remoteType == "AsyncRemoteFunction" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedAsyncFunction")
		elseif remoteType == "RemoteFunction" then
			remote = Instance.new("RemoteFunction")
			collectionService:AddTag(remote, "NetManagedLegacyFunction")
		else
			error("Invalid Remote Type: " .. remoteType)
		end
		remote.Name = name
		remote.Parent = remoteFolder
		return remote
	end
end
-- * @internal
local function checkArguments(types, args)
	if args == nil then
		warn("[net-types] Argument length is zero")
		return false
	end
	do
		local _0 = 0
		while _0 < #types do
			local i = _0
			local typeCheck = types[i + 1]
			local value = args[i + 1]
			if not typeCheck(value) then
				warn("[net-types] Argument at index " .. tostring(i) .. " was invalid type.")
				return false
			end
			_0 = i
			_0 += 1
		end
	end
	return true
end
if IS_SERVER then
	game:GetService("RunService").Stepped:Connect(function(time, step)
		for _, f in ipairs(ServerTickFunctions) do
			f()
		end
	end)
end
return {
	getGlobalRemote = getGlobalRemote,
	isLuaTable = isLuaTable,
	findOrCreateFolder = findOrCreateFolder,
	errorft = errorft,
	warnOnce = warnOnce,
	format = format,
	waitForRemote = waitForRemote,
	findRemote = findRemote,
	getRemoteOrThrow = getRemoteOrThrow,
	findOrCreateRemote = findOrCreateRemote,
	checkArguments = checkArguments,
	IS_SERVER = IS_SERVER,
	IS_CLIENT = IS_CLIENT,
	IS_RUNNING = IS_RUNNING,
	MAX_CLIENT_WAITFORCHILD_TIMEOUT = MAX_CLIENT_WAITFORCHILD_TIMEOUT,
	NetMiddlewareEvent = NetMiddlewareEvent,
	ServerTickFunctions = ServerTickFunctions,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX0E4DC72AB8264673B11AC35EF6B206C4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">tables</string>
									<string name="ScriptGuid">{897C8946-F25B-45E9-B089-7D710701CFCE}</string>
									<ProtectedString name="Source"><![CDATA[local function isMixed(t)
	assert(type(t) == "table")
	local mixed = false
	local _idxType

	for index, value in next, t do
		if _idxType and _idxType ~= type(index) then
			return true
		end

		_idxType = type(index)
		if type(value) == "table" then
			mixed = mixed and isMixed(value) and not (not getmetatable(value))
		end
	end

	return mixed
end

return {
	mixed = isMixed
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC18D44D12B014D1FB26D085396DCD152">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">validator</string>
									<string name="ScriptGuid">{3A6F613B-65CE-49DA-B5DD-7509F56D32D9}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local isMixed = TS.import(script, script.Parent, "tables").isMixed
local Workspace = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
-- * @internal
local isSerializable
local function validateArguments(...)
	local args = { ... }
	for index, value in ipairs(args) do
		if not isSerializable.check(value) then
			local _0 = isSerializable.errorMessage
			local _1 = index
			error(string.format(_0, _1), 2)
		end
		local _0 = value
		if typeof(_0) == "Instance" then
			if value:IsDescendantOf(ServerStorage) or value:IsDescendantOf(ServerScriptService) then
				error("[rbx-net] Instance at argument #" .. tostring(index) .. " is inside a server-only container and cannot be sent via remotes.")
			end
			if not value:IsDescendantOf(game) then
				error("[rbx-net] Instance at argument #" .. tostring(index) .. " is not a valid descendant of game, and wont replicate")
			end
		end
	end
end
-- * @internal
isSerializable = {
	errorMessage = "Argument #%d is not serializable. - see http://docs.vorlias.com/rbx-net/docs/2.0/serialization",
	check = function(value)
		-- Can't allow functions or threads
		local _0 = value
		local _1 = type(_0) == "function"
		if not _1 then
			local _2 = value
			_1 = type(_2) == "thread"
		end
		if _1 then
			return false
		end
		-- Can't allow metatabled objects
		local _2 = value
		local _3 = type(_2) == "table"
		if _3 then
			_3 = getmetatable(value) ~= nil
		end
		if _3 then
			return false
		end
		-- Ensure not a mixed table type
		local _4 = value
		if type(_4) == "table" then
			return not isMixed(value)
		end
		return true
	end,
}
-- * @internal
local function oneOf(...)
	local values = { ... }
	local _0 = {}
	local _1 = "errorMessage"
	-- ▼ ReadonlyArray.join ▼
	local _2 = ", "
	if _2 == nil then
		_2 = ", "
	end
	-- ▲ ReadonlyArray.join ▲
	_0[_1] = "Expected one of: " .. table.concat(values, _2)
	_0.check = function(value)
		local _3 = value
		if not (type(_3) == "string") then
			return false
		end
		for _, cmpValue in ipairs(values) do
			if value == cmpValue then
				return true
			end
		end
		return false
	end
	return _0
end
return {
	validateArguments = validateArguments,
	oneOf = oneOf,
	isSerializable = isSerializable,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX4B56AEC6DD944D1E90E2C5C5C29A0BA9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">messaging</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX4F2D8998FC5D439AB3F6864CD53124E2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MessagingEvent</string>
									<string name="ScriptGuid">{18A6C1B5-297E-4526-8206-EED3B3A16911}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local isLuaTable = _0.isLuaTable
local ServerTickFunctions = _0.ServerTickFunctions
-- const MessagingService = game.GetService("MessagingService");
local MessagingService = TS.import(script, script.Parent, "MessagingService")
local Players = game:GetService("Players")
local IS_STUDIO = game:GetService("RunService"):IsStudio()
--[[
	*
	* Checks if a value matches that of a subscription message
	* @param value The value
]]
local function isSubscriptionMessage(value)
	if isLuaTable(value) then
		local hasData = value.Data ~= nil
		return hasData
	else
		return false
	end
end
local function isJobTargetMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.jobId ~= nil
		end
	end
	return false
end
local globalMessageQueue = {}
local lastQueueTick = 0
local globalEventMessageCounter = 0
local globalSubscriptionCounter = 0
local MessagingEvent
local function processMessageQueue()
	if tick() >= lastQueueTick + 60 then
		globalEventMessageCounter = 0
		globalSubscriptionCounter = 0
		lastQueueTick = tick()
		while #globalMessageQueue > 0 do
			-- ▼ Array.pop ▼
			local _1 = #globalMessageQueue
			local _2 = globalMessageQueue[_1]
			globalMessageQueue[_1] = nil
			-- ▲ Array.pop ▲
			local message = _2
			MessagingService:PublishAsync(message.Name, message.Data)
			globalEventMessageCounter += 1
		end
		if globalEventMessageCounter >= MessagingEvent:GetMessageLimit() then
			warn("[rbx-net] Too many messages are being sent, any further messages will be queued!")
		end
	end
end
--[[
	*
	* Message Size: 1kB
	* MessagesPerMin: 150 + 60 * NUMPLAYERS
	* MessagesPerTopicMin: 30M
	* MessagesPerUniversePerMin: 30M
	* SubsPerServer: 5 + 2 * numPlayers
	* SubsPerUniverse: 10K
]]
--[[
	*
	* An event that works across all servers
	* @see https://developer.roblox.com/api-reference/class/MessagingService for limits, etc.
]]
do
	MessagingEvent = setmetatable({}, {
		__tostring = function()
			return "MessagingEvent"
		end,
	})
	MessagingEvent.__index = MessagingEvent
	function MessagingEvent.new(...)
		local self = setmetatable({}, MessagingEvent)
		self:constructor(...)
		return self
	end
	function MessagingEvent:constructor(name)
		self.name = name
	end
	function MessagingEvent:GetMessageLimit()
		return 150 + 60 * #Players:GetPlayers()
	end
	function MessagingEvent:GetSubscriptionLimit()
		return 5 + 2 * #Players:GetPlayers()
	end
	function MessagingEvent:sendToAllServersOrQueue(data)
		local limit = MessagingEvent:GetMessageLimit()
		if globalEventMessageCounter >= limit then
			warn("[rbx-net] Exceeded message limit of " .. tostring(limit) .. ", adding to queue...")
			local _1 = globalMessageQueue
			local _2 = {
				Name = self.name,
				Data = data,
			}
			-- ▼ Array.push ▼
			_1[#_1 + 1] = _2
			-- ▲ Array.push ▲
		else
			globalEventMessageCounter += 1
			-- Since this yields
			MessagingService:PublishAsync(self.name, data)
		end
	end
	function MessagingEvent:SendToServer(jobId, message)
		self:sendToAllServersOrQueue({
			jobId = jobId,
			message = message,
		})
	end
	function MessagingEvent:SendToAllServers(message)
		self:sendToAllServersOrQueue(message)
	end
	function MessagingEvent:Connect(handler)
		local limit = MessagingEvent:GetSubscriptionLimit()
		if globalSubscriptionCounter >= limit then
			error("[rbx-net] Exceeded Subscription limit of " .. tostring(limit) .. "!")
		end
		globalSubscriptionCounter += 1
		return MessagingService:SubscribeAsync(self.name, function(data, sent)
			local recieved = {
				Data = data,
				Sent = sent,
			}
			local _1 = recieved
			local Sent = _1.Sent
			if isJobTargetMessage(recieved) then
				local _2 = recieved
				local Data = _2.Data
				if game.JobId == Data.JobId then
					handler(Data.InnerData, Sent)
				end
			else
				handler(recieved.Data, Sent)
			end
		end)
	end
end
local _1 = ServerTickFunctions
local _2 = processMessageQueue
-- ▼ Array.push ▼
_1[#_1 + 1] = _2
-- ▲ Array.push ▲
return {
	isSubscriptionMessage = isSubscriptionMessage,
	default = MessagingEvent,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX968D8D1DC9F04D95AA81861DD345963D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MessagingService</string>
									<string name="ScriptGuid">{D18357CF-B225-4AD2-84B4-672360ACADB3}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local MessagingService = game:GetService("MessagingService")

local MockMessagingService = {}
local topics = {}

function MockMessagingService:PublishAsync(topicName, message)
	local topic = topics[topicName]
	if topic then
		topic:Fire(
			{
				Sent = tick(),
				Data = message
			}
		)
	end
end

function MockMessagingService:SubscribeAsync(topicName, callback)
	local topic = topics[topicName]
	if not topic then
		topic = Instance.new("BindableEvent")
		topic.Parent = script
		topic.Name = topicName
		topics[topicName] = topic
	end

	return topic.Event:Connect(callback)
end

local service
if RunService:IsStudio() then
    service = MockMessagingService
else
    service = MessagingService
end


return service]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXFFD0B59A9BFD484A8298334B01300CE8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">middleware</string>
								<string name="ScriptGuid">{226ECEFE-E305-4C81-A407-D8E069EDFBAE}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local createLoggerMiddleware = TS.import(script, script, "LoggerMiddleware")
local createRateLimiter = TS.import(script, script, "RateLimitMiddleware").default
local NetTypeCheckingMiddleware = TS.import(script, script, "TypeCheckMiddleware")
local NetMiddleware = {}
do
	local _0 = NetMiddleware
	local RateLimit = createRateLimiter
	_0.RateLimit = RateLimit
	local Logging = createLoggerMiddleware
	_0.Logging = Logging
	-- * The type checking middleware
	local TypeChecking = NetTypeCheckingMiddleware
	_0.TypeChecking = TypeChecking
	--[[
		*
		* Creates a global read-only middleware for use in `Net.Definitions` global middleware.
	]]
	local function Global(middleware)
		local _1 = function(processNext, event)
			return function(sender, ...)
				local args = { ... }
				middleware(event:GetInstance().Name, args, sender)
				return processNext(sender, unpack(args))
			end
		end
		return _1
	end
	_0.Global = Global
end
local createTypeChecker = NetTypeCheckingMiddleware
return {
	NetMiddleware = NetMiddleware,
	createRateLimiter = createRateLimiter,
	createTypeChecker = createTypeChecker,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX309D7218C93B4F0D8F591E401F3C647E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">LoggerMiddleware</string>
									<string name="ScriptGuid">{6B28A3DC-2E9A-40CD-B77C-241B9E59E0DD}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio()

local function defaultLogger(name, args)
    if IS_STUDIO then
        local str = {};
        for _, arg in ipairs(args) do
            table.insert(str, HttpService:JSONEncode(arg))
        end
        print("[rbx-net] Called", name, "with arguments", "[ " .. table.concat(str, ", ") .. " ]")
    end
end

return function(options)
    options = options or {}
    local logger = options.Logger or defaultLogger

    return function (next, event)
        local name = options.Name or event:GetInstance().Name
        return function(player, ...)
            logger(name, {...})
            return next(player, ...)
        end
    end
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX13943F8858694E1E8A0D077E4E057B6F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">RateLimitMiddleware</string>
									<string name="ScriptGuid">{92F1962A-A3A3-4C55-BFDD-5052A73EDDC2}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local format = _0.format
local IS_SERVER = _0.IS_SERVER
local ServerTickFunctions = _0.ServerTickFunctions
local throttler = TS.import(script, script, "throttle")
local GetConfiguration = TS.import(script, script.Parent.Parent, "configuration").GetConfiguration
local throttles = {}
local function rateLimitWarningHandler(rateLimitError)
	warn("[rbx-net]", rateLimitError.Message)
end
--[[
	*
	* Creates a throttle middleware for this event
	*
	* Will limit the amount of requests a player can make to this event
	*
	* _NOTE: Must be used before **other** middlewares as it's not a type altering middleware_
	* @param maxRequestsPerMinute The maximum requests per minute
]]
local function createRateLimiter(options)
	local maxRequestsPerMinute = options.MaxRequestsPerMinute
	local _1 = options.ErrorHandler
	if _1 == nil then
		_1 = rateLimitWarningHandler
	end
	local errorHandler = _1
	return function(processNext, event)
		local instance = event:GetInstance()
		local _2 = throttles
		local _3 = event
		local throttle = _2[_3]
		if throttle == nil then
			throttle = throttler:Get(instance:GetFullName())
		end
		return function(player, ...)
			local args = { ... }
			local count = throttle:Get(player)
			if count >= maxRequestsPerMinute then
				local _4 = errorHandler
				if _4 ~= nil then
					_4({
						Message = format(GetConfiguration("ServerThrottleMessage"), {
							player = player.UserId,
							remote = instance.Name,
							limit = maxRequestsPerMinute,
						}),
						MaxRequestsPerMinute = maxRequestsPerMinute,
						RemoteId = instance.Name,
						UserId = player.UserId,
					})
				end
			else
				throttle:Increment(player)
				return processNext(player, unpack(args))
			end
		end
	end
end
if IS_SERVER then
	local lastTick = 0
	local _1 = ServerTickFunctions
	local _2 = function()
		if tick() > lastTick + GetConfiguration("ServerThrottleResetTimer") then
			lastTick = tick()
			throttler:Clear()
		end
	end
	-- ▼ Array.push ▼
	_1[#_1 + 1] = _2
	-- ▲ Array.push ▲
end
local default = createRateLimiter
return {
	rateLimitWarningHandler = rateLimitWarningHandler,
	default = default,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX2C487D326E33454697BDB27AA3381C92">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">throttle</string>
										<string name="ScriptGuid">{FCC41517-D705-468A-97DD-BF8A17698D84}</string>
										<ProtectedString name="Source"><![CDATA[local Throttle = {
	counters = {}
}
local RequestCounter = {}
RequestCounter.__index = RequestCounter

function RequestCounter.new()
	local self = {
		counter = {}
	}

	return setmetatable(self, RequestCounter)
end

function RequestCounter:Get(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]
	return playerQueue or 0
end

function RequestCounter:Increment(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]

	if not counter[player.UserId] then
		counter[player.UserId] = 1
	else
		counter[player.UserId] = playerQueue + 1
	end
end

function RequestCounter:__tostring()
	return "RequestCounter"
end

function RequestCounter:ClearAll()
	self.counter = {}
end

function Throttle:Get(name)
	local existing = self.counters[name]
	if (existing) then
		return existing
	else
		local newCounter = RequestCounter.new()
		self.counters[name] = newCounter
		return newCounter
	end
end

function Throttle:Clear()
	for _, counter in pairs(self.counters) do
		counter:ClearAll()
	end
end

return Throttle
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX4D79250E351C44FBBC03066619182E16">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TypeCheckMiddleware</string>
									<string name="ScriptGuid">{30DFB7A4-3FE4-483C-82BD-967665AD333C}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio();

local function defaultErrorHandler(event, args, index)
    local name = event:GetInstance().Name
    if IS_STUDIO then
        warn("[TypeCheckMiddleware] Call to " .. name .. " failed")
        warn("\tRecieved: " .. HttpService:JSONEncode(args))
        warn("\tInvalid argument at index " .. tostring(index))
    end
end

local MiddlewareGlobal = {}
MiddlewareGlobal.__index = MiddlewareGlobal
MiddlewareGlobal.defaultErrorHandler = defaultErrorHandler

local function typeCheckMiddleware(...)
    local checks = {...}
    local MiddlewareInstance = {}
    MiddlewareInstance.__index = MiddlewareInstance;

    function MiddlewareInstance:next(next, event)
        local errorHandler = self.errorHandler or MiddlewareGlobal.defaultErrorHandler
        --  what's returned as callbackFn
        return function(player, ...)
            local args = {...}
            for index, check in ipairs(checks) do
                if not check(args[index]) then
                    pcall(errorHandler, event, args, index)
                    return false
                end
            end

            -- Invoke the next middleware OR the callback (if none left)
            return next(player, ...)
        end
    end

    function MiddlewareInstance.__tostring()
        return "TypeCheckMiddleware"
    end

    function MiddlewareInstance:WithErrorHandler(fn)
        self.errorHandler = fn
        return self
    end

    function MiddlewareInstance:__call(...)
        return self:next(...)
    end
    
    return setmetatable({}, MiddlewareInstance)
    -- ^ The middleware
end

function MiddlewareGlobal.__call(_, ...)
    return typeCheckMiddleware(...)
end

function MiddlewareGlobal.SetDefaultErrorHandler(_, fn)
    MiddlewareGlobal.defaultErrorHandler = fn
end

return setmetatable({}, MiddlewareGlobal)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX8AC5F23DE0B745C2B9C62D85BD19FF23">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">serialization</string>
								<string name="ScriptGuid">{9770CDCB-0704-4C3B-B482-01AC7FE8A2E6}</string>
								<ProtectedString name="Source"><![CDATA[local Serializer = {}

function Serializer.Serialize(object)
    if type(object) == "number" or type(object) == "string" or type(object) == "boolean" then
        return object
    end
    if type(object) ~= "table" then
        error("Cannot serialize type: " .. type(object), 2);
    end
    if object["Serialize"] ~= nil then
        return object:Serialize()
    end
    local serialized = {}
    for index, value in pairs(object) do
        if type(value) == "table" then
            serialized[index] = Serializer.Serialize(value)
        else
            serialized[index] = value;
        end
    end
    return serialized
end

local function isMixed(t)
	assert(type(t) == "table")
	local mixed = false
	local _idxType

	for index, value in next, t do
		if _idxType and _idxType ~= type(index) then
			return true
		end

		_idxType = type(index)
		if type(value) == "table" then
			mixed = mixed and isMixed(value) and not (not getmetatable(value))
		end
	end

	return mixed
end

function Serializer.IsSerializable(value)
    local _type = type(value)
	if _type == "number" or _type == "boolean" or _type == "string" then
		return true
	elseif _type == "table" then
		return not isMixed(value) and not getmetatable(value)
	elseif _type == "userdata" and typeof(_type) ~= "userdata" then -- Instances / Value Types
		return true
	else
		return false
	end
end

function Serializer.Deserialize(serialized, deserializer)
    assert(type(serialized) == "table")
    if deserializer then
        if type(deserializer) == "table" and deserializer["deserialize"] then
            return deserializer:deserialize(serialized)
        end
    end
end

return Serializer]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEA2CADA2917D41E08E4810D036D80E8B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">server</string>
								<string name="ScriptGuid">{279FFEE1-ECAF-47A8-9274-ABD6FE7C823F}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ServerAsyncFunction").default
local _0 = TS.import(script, script, "ServerEvent")
local ServerEvent = _0.default
local Event = _0.default
local GameMessagingEvent = TS.import(script, script, "ServerMessagingEvent").default
local CreateListener = TS.import(script, script, "CreateServerListener").default
local Function = TS.import(script, script, "ServerFunction").default
local config = TS.import(script, script.Parent, "configuration")
--[[
	*
	* Creates an event on the server
	*
	* Programmatically equivalent to `new Net.Server.Event(name, middleware)`
	*
	* @param name The name of the event
	* @param middleware The middleware attached to this event
]]
local function CreateEvent(name, middleware)
	return ServerEvent.new(name, middleware)
end
--[[
	*
	* Creates an event on the server
	* Same as `CreateEvent`, but type-wise removes `Connect`.
]]
local CreateSender = CreateEvent
--[[
	*
	* Creates a function on the server
	*
	* Programmatically equivalent to `new Net.Server.AsyncFunction(name, middleware)`
	*
	* @param name The name of the function
	* @param middleware The middleware attached to this function
]]
local function CreateAsyncFunction(name, middleware)
	if middleware == nil then
		middleware = {}
	end
	return AsyncFunction.new(name, middleware)
end
--[[
	*
	* An event declaration
]]
--[[
	*
	* Creates multiple server events by name, or declaration
	*
	* An example of a simple list of events is:
	*
	* ```ts
	* const [eventA, eventB] = Net.Server.CreateEvents("A", "B");
	* ```
	* Both `eventA` and `eventB` will be generic server events. If you want to include middleware, you can do:
	*
	* ```ts
	* const [eventA, middlewareEventB] = Net.Server.CreateEvents(
	* 	"A",
	* 	["B", createTypeChecker(t.string)]
	* )
	* ```
	* In this instance, it would be like doing `const middlewareEventB = new Net.Server.Event("B", [createTypeChecker(t.string)])`
	* Event A would still take any arguments, and Event B would take specific arguments (in this case, `string`)
]]
local function CreateEvents(...)
	local evts = { ... }
	local evtMap = {}
	for _, id in ipairs(evts) do
		local _1 = id
		if type(_1) == "string" then
			local _2 = evtMap
			local _3 = ServerEvent.new(id)
			-- ▼ Array.push ▼
			_2[#_2 + 1] = _3
			-- ▲ Array.push ▲
		else
			local _2 = id
			local name = _2[1]
			local middleware = { select(2, unpack(id)) }
			local _3 = evtMap
			local _4 = ServerEvent.new(name, middleware)
			-- ▼ Array.push ▼
			_3[#_3 + 1] = _4
			-- ▲ Array.push ▲
		end
	end
	return unpack(evtMap)
end
--[[
	*
	* Set a configuration value for the server
]]
local SetConfiguration = config.SetConfiguration
--[[
	*
	* Get a configuration value for the server
]]
local GetConfiguration = config.GetConfiguration
return {
	CreateEvent = CreateEvent,
	CreateAsyncFunction = CreateAsyncFunction,
	CreateEvents = CreateEvents,
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
	GameMessagingEvent = GameMessagingEvent,
	CreateListener = CreateListener,
	CreateSender = CreateSender,
	SetConfiguration = SetConfiguration,
	GetConfiguration = GetConfiguration,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX8FDFEA1F75D349DEA9B4217C1B501F3E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CreateServerListener</string>
									<string name="ScriptGuid">{68B67008-CEDD-48A1-87AC-0DC95DE3D1E1}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local ServerEventV2 = TS.import(script, script.Parent, "ServerEvent").default
local function isMiddlewareArgument(args)
	local _0 = #args > 1
	if _0 then
		local _1 = args[1]
		_0 = type(_1) == "table"
	end
	return _0
end
--[[
	*
	* Creates a server listening event
]]
local function createServerListener(id, ...)
	local args = { ... }
	local event
	if isMiddlewareArgument(args) then
		local _0 = args
		local middleware = _0[1]
		local connect = _0[2]
		event = ServerEventV2.new(id, middleware)
		return event:Connect(connect)
	else
		local _0 = args
		local connect = _0[1]
		event = ServerEventV2.new(id)
		return event:Connect(connect)
	end
end
return {
	default = createServerListener,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6D1C7C872E0C4740B2815E698502F960">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MiddlewareEvent</string>
									<string name="ScriptGuid">{5EF995D3-3AA4-4313-BF8B-42FEEFCE3BBB}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
-- * @internal
local MiddlewareEvent
do
	MiddlewareEvent = {}
	function MiddlewareEvent:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareEvent:_use(middleware)
		local _0 = (self.middlewares)
		local _1 = middleware
		-- ▼ Array.push ▼
		_0[#_0 + 1] = _1
		-- ▲ Array.push ▲
	end
	function MiddlewareEvent:_processMiddleware(callback)
		local _0 = self
		local middlewares = _0.middlewares
		local _1, _2 = TS.try(function()
			local _3 = middlewares
			local _4 = type(_3) == "table"
			local _5 = middlewares
			local _6 = "The middleware argument should be an array of middlewares not a " .. typeof(_5)
			assert(_4, _6)
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _1 then
			return unpack(_2)
		end
	end
end
local default = MiddlewareEvent
return {
	default = default,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX140458F77D874AC491D7CC3AE6244D3E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MiddlewareFunction</string>
									<string name="ScriptGuid">{E8FB327F-8A01-4CB6-B99D-513E84BFA189}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local MiddlewareFunction
do
	MiddlewareFunction = {}
	function MiddlewareFunction:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareFunction:_use(middleware)
		local _0 = (self.middlewares)
		local _1 = middleware
		-- ▼ Array.push ▼
		_0[#_0 + 1] = _1
		-- ▲ Array.push ▲
	end
	function MiddlewareFunction:_processMiddleware(callback)
		local _0 = self
		local middlewares = _0.middlewares
		local _1, _2 = TS.try(function()
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _1 then
			return unpack(_2)
		end
	end
end
local default = MiddlewareFunction
return {
	default = default,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7B3A693C8E174D4BA52CCBE0AE230985">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ServerAsyncFunction</string>
									<string name="ScriptGuid">{FACCF1B3-B8E3-419D-8AA6-30D5B8F604A7}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "configuration")
local DebugLog = _0.DebugLog
local DebugWarn = _0.DebugWarn
local _1 = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _1.findOrCreateRemote
local IS_CLIENT = _1.IS_CLIENT
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local HttpService = game:GetService("HttpService")
local function isEventArgs(value)
	if #value < 2 then
		return false
	end
	local _2 = value
	local eventId = _2[1]
	local data = _2[2]
	local _3 = eventId
	local _4 = type(_3) == "string"
	if _4 then
		local _5 = data
		_4 = type(_5) == "table"
	end
	return _4
end
--[[
	*
	* An asynchronous function for two way communication between the client and server
]]
local ServerAsyncFunction
do
	local super = MiddlewareEvent
	ServerAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ServerAsyncFunction"
		end,
		__index = super,
	})
	ServerAsyncFunction.__index = ServerAsyncFunction
	function ServerAsyncFunction.new(...)
		local self = setmetatable({}, ServerAsyncFunction)
		self:constructor(...)
		return self
	end
	function ServerAsyncFunction:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.timeout = 10
		self.listeners = {}
		self.instance = findOrCreateRemote("AsyncRemoteFunction", name)
		local _2 = not IS_CLIENT
		assert(_2, "Cannot create a NetServerAsyncFunction on the client!")
	end
	function ServerAsyncFunction:GetInstance()
		return self.instance
	end
	function ServerAsyncFunction:SetCallTimeout(timeout)
		local _2 = timeout > 0
		assert(_2, "timeout must be a positive number")
		self.timeout = timeout
		return self
	end
	function ServerAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ServerAsyncFunction:SetCallback(callback)
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		self.connector = self.instance.OnServerEvent:Connect(TS.async(function(player, ...)
			local args = { ... }
			if isEventArgs(args) then
				local _2 = args
				local eventId = _2[1]
				local data = _2[2]
				local _3 = self:_processMiddleware(callback)
				if _3 ~= nil then
					_3 = _3(player, unpack(data))
				end
				local result = _3
				if TS.Promise.is(result) then
					local _4 = result
					local _5 = function(promiseResult)
						self.instance:FireClient(player, eventId, promiseResult)
					end
					_4:andThen(_5):catch(function(err)
						warn("[rbx-net] Failed to send response to client: " .. err)
					end)
				else
					if result == nil then
						warn("[rbx-net-async] " .. self.instance.Name .. " returned undefined")
					end
					self.instance:FireClient(player, eventId, result)
				end
			else
				warn("[rbx-net-async] Recieved message without eventId")
			end
		end))
	end
	ServerAsyncFunction.CallPlayerAsync = TS.async(function(self, player, ...)
		local args = { ... }
		local id = HttpService:GenerateGUID(false)
		local _2 = self.instance
		local _3 = {}
		for _4, _5 in pairs(args) do
			_3[_4] = _5
		end
		_2:FireClient(player, id, _3)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			DebugLog("Connected CallPlayerAsync EventId", id)
			local connection
			connection = self.instance.OnServerEvent:Connect(function(fromPlayer, ...)
				local recvArgs = { ... }
				local _4 = recvArgs
				local eventId = _4[1]
				local data = _4[2]
				local _5 = eventId
				local _6 = type(_5) == "string"
				if _6 then
					_6 = data ~= nil
				end
				if _6 then
					if player == player and eventId == id then
						DebugLog("Disconnected CallPlayerAsync EventId", eventId)
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _4 = self.listeners
			local _5 = id
			local _6 = {
				connection = connection,
				timeout = self.timeout,
			}
			-- ▼ Map.set ▼
			_4[_5] = _6
			-- ▲ Map.set ▲
			repeat
				do
					game:GetService("RunService").Stepped:Wait()
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			local _7 = self.listeners
			local _8 = id
			-- ▼ Map.delete ▼
			_7[_8] = nil
			-- ▲ Map.delete ▲
			if tick() >= startTime and connection.Connected then
				DebugWarn("(timeout) Disconnected CallPlayerAsync EventId", id)
				connection:Disconnect()
				reject("Request to client timed out")
			end
		end)
	end)
end
local default = ServerAsyncFunction
return {
	default = default,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9340209742474033A2A1ED820D2D6ECF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ServerEvent</string>
									<string name="ScriptGuid">{150455FA-6D24-44C1-89F1-5AF33D8A4E94}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _0.findOrCreateRemote
local IS_CLIENT = _0.IS_CLIENT
local IS_RUNNING = _0.IS_RUNNING
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
--[[
	*
	* Interface for server listening events
]]
--[[
	*
	* Interface for server sender events
]]
local ServerEvent
do
	local super = MiddlewareEvent
	ServerEvent = setmetatable({}, {
		__tostring = function()
			return "ServerEvent"
		end,
		__index = super,
	})
	ServerEvent.__index = ServerEvent
	function ServerEvent.new(...)
		local self = setmetatable({}, ServerEvent)
		self:constructor(...)
		return self
	end
	function ServerEvent:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.instance = findOrCreateRemote("RemoteEvent", name)
		local _1 = not IS_CLIENT
		assert(_1, "Cannot create a NetServerEvent on the client!")
	end
	function ServerEvent:GetInstance()
		return self.instance
	end
	function ServerEvent:Connect(callback)
		local connection = self.instance.OnServerEvent:Connect(function(player, ...)
			local args = { ... }
			local _1 = self:_processMiddleware(callback)
			if _1 ~= nil then
				_1(player, unpack(args))
			end
		end)
		return connection
	end
	function ServerEvent:SendToAllPlayers(...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireAllClients(unpack(args))
	end
	function ServerEvent:SendToAllPlayersExcept(blacklist, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		local Players = game:GetService("Players")
		local _1 = blacklist
		local _2 = blacklist
		if typeof(_1) == "Instance" then
			local _3 = Players:GetPlayers()
			local _4 = function(p)
				return p ~= blacklist
			end
			-- ▼ ReadonlyArray.filter ▼
			local _5 = {}
			local _6 = 0
			for _7, _8 in ipairs(_3) do
				if _4(_8, _7 - 1, _3) == true then
					_6 += 1
					_5[_6] = _8
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			local otherPlayers = _5
			for _, player in ipairs(otherPlayers) do
				self.instance:FireClient(player, unpack(args))
			end
		elseif type(_2) == "table" then
			for _, player in ipairs(Players:GetPlayers()) do
				local _3 = blacklist
				local _4 = player
				if (table.find(_3, _4) or 0) - 1 == -1 then
					self.instance:FireClient(player, unpack(args))
				end
			end
		end
	end
	function ServerEvent:SendToPlayer(player, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireClient(player, unpack(args))
	end
	function ServerEvent:SendToPlayers(players, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		for _, player in ipairs(players) do
			self:SendToPlayer(player, unpack(args))
		end
	end
end
return {
	default = ServerEvent,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF167FAF8282E4BBDACFA04DAFF6B0F95">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ServerFunction</string>
									<string name="ScriptGuid">{42EEEAA2-1C1E-4BA8-A49B-3D6569BE6705}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _0.findOrCreateRemote
local IS_SERVER = _0.IS_SERVER
local MiddlewareFunction = TS.import(script, script.Parent, "MiddlewareFunction").default
local ServerFunction
do
	local super = MiddlewareFunction
	ServerFunction = setmetatable({}, {
		__tostring = function()
			return "ServerFunction"
		end,
		__index = super,
	})
	ServerFunction.__index = ServerFunction
	function ServerFunction.new(...)
		local self = setmetatable({}, ServerFunction)
		self:constructor(...)
		return self
	end
	function ServerFunction:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.instance = findOrCreateRemote("RemoteFunction", name)
		local _1 = IS_SERVER
		assert(_1, "Cannot create a Net.ServerFunction on the Client!")
	end
	function ServerFunction:GetInstance()
		return self.instance
	end
	function ServerFunction:SetCallback(callback)
		self.instance.OnServerInvoke = function(player, ...)
			local args = { ... }
			local _1 = self:_processMiddleware(callback)
			if _1 ~= nil then
				_1 = _1(player, unpack(args))
			end
			local result = _1
			if TS.Promise.is(result) then
				warn("[rbx-net] WARNING: Promises should be used with an AsyncFunction!")
				local success, value = result:await()
				if success then
					return value
				else
					error(value)
				end
			end
			return result
		end
	end
end
return {
	default = ServerFunction,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFEA5DC71D0934990941EF6AA132C3EDD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ServerMessagingEvent</string>
									<string name="ScriptGuid">{4430271F-002F-45B1-B5D3-8A5B28416D94}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "messaging", "MessagingEvent")
local MessagingEvent = _0.default
local isSubscriptionMessage = _0.isSubscriptionMessage
local _1 = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _1.getGlobalRemote
local IS_CLIENT = _1.IS_CLIENT
local isLuaTable = _1.isLuaTable
local ServerEvent = TS.import(script, script.Parent, "ServerEvent").default
local Players = game:GetService("Players")
local function isTargetedSubscriptionMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.InnerData ~= nil
		end
	end
	return false
end
--[[
	*
	* Similar to a ServerEvent, but works across all servers.
]]
local ServerMessagingEvent
do
	ServerMessagingEvent = setmetatable({}, {
		__tostring = function()
			return "ServerMessagingEvent"
		end,
	})
	ServerMessagingEvent.__index = ServerMessagingEvent
	function ServerMessagingEvent.new(...)
		local self = setmetatable({}, ServerMessagingEvent)
		self:constructor(...)
		return self
	end
	function ServerMessagingEvent:constructor(name)
		self.instance = ServerEvent.new(getGlobalRemote(name))
		self.event = MessagingEvent.new(name)
		local _2 = not IS_CLIENT
		assert(_2, "Cannot create a Net.GlobalServerEvent on the Client!")
		self.eventHandler = self.event:Connect(function(message)
			if isTargetedSubscriptionMessage(message) then
				self:recievedMessage(message.Data)
			else
				warn("[rbx-net] Recieved malformed message for ServerGameEvent: " .. name)
			end
		end)
	end
	function ServerMessagingEvent:getPlayersMatchingId(matching)
		local _2 = matching
		if type(_2) == "number" then
			return Players:GetPlayerByUserId(matching)
		else
			local players = {}
			for _, id in ipairs(matching) do
				local player = Players:GetPlayerByUserId(id)
				if player then
					local _3 = players
					local _4 = player
					-- ▼ Array.push ▼
					_3[#_3 + 1] = _4
					-- ▲ Array.push ▲
				end
			end
			return players
		end
	end
	function ServerMessagingEvent:recievedMessage(message)
		if message.TargetIds then
			local players = self:getPlayersMatchingId(message.TargetIds)
			if players then
				self.instance:SendToPlayers(players, unpack(message.InnerData))
			end
		elseif message.TargetId ~= nil then
			local player = self:getPlayersMatchingId(message.TargetId)
			if player then
				self.instance:SendToPlayer(player, unpack(message.InnerData))
			end
		else
			self.instance:SendToAllPlayers(unpack(message.InnerData))
		end
	end
	function ServerMessagingEvent:Disconnect()
		self.eventHandler:Disconnect()
	end
	function ServerMessagingEvent:SendToAllServers(...)
		local args = { ... }
		local _2 = self.event
		local _3 = {}
		local _4 = "data"
		local _5 = {}
		local _6 = #_5
		for _7, _8 in ipairs(args) do
			_5[_6 + _7] = _8
		end
		_3[_4] = _5
		_2:SendToAllServers(_3)
	end
	function ServerMessagingEvent:SendToServer(jobId, ...)
		local args = { ... }
		local _2 = self.event
		local _3 = {}
		local _4 = "data"
		local _5 = {}
		local _6 = #_5
		for _7, _8 in ipairs(args) do
			_5[_6 + _7] = _8
		end
		_3[_4] = _5
		_2:SendToServer(jobId, _3)
	end
	function ServerMessagingEvent:SendToPlayer(userId, ...)
		local args = { ... }
		local player = Players:GetPlayerByUserId(userId)
		-- If the player exists in this instance, just send it straight to them.
		if player then
			self.instance:SendToPlayer(player, unpack(args))
		else
			local _2 = self.event
			local _3 = {}
			local _4 = "data"
			local _5 = {}
			local _6 = #_5
			for _7, _8 in ipairs(args) do
				_5[_6 + _7] = _8
			end
			_3[_4] = _5
			_3.targetId = userId
			_2:SendToAllServers(_3)
		end
	end
	function ServerMessagingEvent:SendToPlayers(userIds, ...)
		local args = { ... }
		-- Check to see if any of these users are in this server first, and handle accordingly.
		for _, targetId in ipairs(userIds) do
			local player = Players:GetPlayerByUserId(targetId)
			if player then
				self.instance:SendToPlayer(player, unpack(args))
				local _2 = userIds
				local _3 = targetId
				table.remove(_2, _3 + 1)
			end
		end
		if #userIds > 0 then
			local _2 = self.event
			local _3 = {}
			local _4 = "data"
			local _5 = {}
			local _6 = #_5
			for _7, _8 in ipairs(args) do
				_5[_6 + _7] = _8
			end
			_3[_4] = _5
			_3.targetIds = userIds
			_2:SendToAllServers(_3)
		end
	end
end
return {
	default = ServerMessagingEvent,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX040942DD5EF44C7885C549C96401B906">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">roact</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4C71E93A0CD148C98A34DBF03139CCAC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">src</string>
							<string name="ScriptGuid">{173FFAD5-FC18-440D-B07E-325AE7114D6C}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXED3FD213C63A45A48E43F7E47F52409D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Binding</string>
								<string name="ScriptGuid">{350238D5-7A34-492E-98A9-1078C6AA70C7}</string>
								<ProtectedString name="Source"><![CDATA[local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEB74D14DF26F42168F0B5F7C936B36D3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Component</string>
								<string name="ScriptGuid">{BCDB0A03-BC1A-406B-913E-896BA317DBC5}</string>
								<ProtectedString name="Source"><![CDATA[local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "<Validator function did not supply a message>"
		error(("Property validation failed in %s: %s\n\n%s"):format(
			self.__componentName,
			tostring(failureReason),
			self:getElementTraceback() or "<enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2387B3D9836D4CC3B58057FB4D5942D8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ComponentLifecyclePhase</string>
								<string name="ScriptGuid">{C36E7D3E-97AF-436D-80CB-3A08F7B14434}</string>
								<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAEF9FB4DD50F482E94783358B6060B03">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Config</string>
								<string name="ScriptGuid">{ED41CFC5-B73B-42A4-85D0-828FDACDB939}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBB3B10E7D2F943A58B6289E4FE743C81">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ElementKind</string>
								<string name="ScriptGuid">{45F67D61-5323-4D24-9215-A11076FFFC56}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7BF6F4AC785A4BC3B07952709A0B3072">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ElementUtils</string>
								<string name="ScriptGuid">{A59A4702-04EC-4271-B731-E96D2111133C}</string>
								<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC0478ECDAAB542588C83E49DB682C12D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GlobalConfig</string>
								<string name="ScriptGuid">{AD35059A-FF3E-46E8-AC06-1B4CDC45C208}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX609D58F800EE437199D2540C1F75C35E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Logging</string>
								<string name="ScriptGuid">{461C7E03-49C1-44A3-9377-9E0D8D5BD6BC}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX64B12081BA1C43F0BDDFA7183CA9FF44">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">None</string>
								<string name="ScriptGuid">{EDE75056-374B-463D-9A24-00C85F2D3D3B}</string>
								<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4CFB85A4A2794A1DBBE76CFFD6E0AA2C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NoopRenderer</string>
								<string name="ScriptGuid">{FF970741-245E-476E-9CB7-A1E3BB123A92}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE5FF5D6872B643FAA9202CDF44DA0539">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Portal</string>
								<string name="ScriptGuid">{2679010B-C64B-4D52-ABD8-D05862225A8A}</string>
								<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXE9AAF428D5824F73B03BB0E98D630C05">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">PropMarkers</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX0AD064CE66D44870BEEE0EA565840BF0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Change</string>
									<string name="ScriptGuid">{F73C52BC-79E7-45F7-9C02-1B77BFC91ADA}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX70D3F98F300549499C390D8C3992C810">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Children</string>
									<string name="ScriptGuid">{694ECC83-1673-4D85-904D-0D60DF88A837}</string>
									<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA68AF509BC6E4C44BE148DE46B649764">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Event</string>
									<string name="ScriptGuid">{73195C1D-F654-4BD0-A79C-1EB1833EDFC8}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4FD67765501D47F78902F58F5AE158A9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Ref</string>
									<string name="ScriptGuid">{F38F7D2E-B4C0-4CFD-8748-201416EAC639}</string>
									<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX7771529D20874409938D98A291D7BDFE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PureComponent</string>
								<string name="ScriptGuid">{733C7BCA-3AF5-4126-9216-F746ADA45B7A}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX791D34F92AE14FDCB04040BB5AE4A182">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RobloxRenderer</string>
								<string name="ScriptGuid">{36D01171-775D-479C-96D2-32E267D1E849}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX372B4A6014E54DFBB4736B788EA61533">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SingleEventManager</string>
								<string name="ScriptGuid">{38CA3290-9F6B-46D8-8BAE-2AD0CC13C5AE}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(
			tostring(key),
			event
		), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index <= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX70EC0E31999A477087E4AB99AA0F7308">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Symbol</string>
								<string name="ScriptGuid">{1DB12376-A35A-476F-9A1C-9D6D474A4038}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0D6179C0F6EF4209AEDDCE857D891314">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Type</string>
								<string name="ScriptGuid">{BDCBF05D-637A-40E0-A55D-35C5000EB684}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB9DA082ECF134BBDA41FCA6AB647E764">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">assertDeepEqual</string>
								<string name="ScriptGuid">{E3ED432F-44F1-402A-990F-88E6384CE85B}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX86C0AD9764094DB5B139423871345A3C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">assign</string>
								<string name="ScriptGuid">{2B33C4BA-0A42-4E6E-AB79-304EA136BB0F}</string>
								<ProtectedString name="Source"><![CDATA[local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF22510C960ED41749278DFFDC06729A2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createContext</string>
								<string name="ScriptGuid">{92E6E91A-168B-4D7C-95F5-142F6D582065}</string>
								<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF506A02C8E574F53A65678E9D2263C93">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createElement</string>
								<string name="ScriptGuid">{0A107424-6A98-4F93-9BB4-52D3E46B21B0}</string>
								<ProtectedString name="Source"><![CDATA[local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFCB01116F82842DBA2CFFCC4E1E78395">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createFragment</string>
								<string name="ScriptGuid">{F425C98E-A32F-41FA-A695-B9E20D11FDBF}</string>
								<ProtectedString name="Source"><![CDATA[local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0B3F560D7BDD45A385B8E0D8FCA2B916">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createReconciler</string>
								<string name="ScriptGuid">{7D600332-42B6-4BEB-B839-687A39590323}</string>
								<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element
			or renderResult == nil
			or typeof(renderResult) == "boolean"
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEBA375B1CA5C4A6A9E0BB2040C23985F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createReconcilerCompat</string>
								<string name="ScriptGuid">{79787F3D-AC6E-496B-A42D-E92C94DC088B}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX193B218AF8DF41868F792A73DE2AB493">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createRef</string>
								<string name="ScriptGuid">{A4674DC5-16F7-4162-934F-3F3954E6182C}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0EA3C62E19DA47A2A552B012AC6B6172">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createSignal</string>
								<string name="ScriptGuid">{C12E470B-D461-42A1-A9B4-5A87F6F33F35}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0C9E6FAD55644088A5EA18516E8696ED">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createSpy</string>
								<string name="ScriptGuid">{83F30635-6630-47C4-A4DE-A6CB6B8E2F6F}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9B795E589E9B4CC282A40D63FB17EE29">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">getDefaultInstanceProperty</string>
								<string name="ScriptGuid">{B17B9A0A-8163-4520-AD88-925340A6C579}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX63239302735E4720B0274E933427A1F1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">internalAssert</string>
								<string name="ScriptGuid">{4F0D5D83-939F-4B72-8499-EBDDAFEC5D44}</string>
								<ProtectedString name="Source"><![CDATA[local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFFF3C835DAAD4224B0EF2E036D69CF3F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">invalidSetStateMessages</string>
								<string name="ScriptGuid">{7147FD7E-663D-4A7E-8E49-3594CF03D8CB}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1DB78A39FC754877A7E208CB3A0623EC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">oneChild</string>
								<string name="ScriptGuid">{EEEAFDDB-B48C-46AE-BB63-C908E3F50228}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX899EEA12EC0B4FC48F90A6E31FF60C7C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">strict</string>
								<string name="ScriptGuid">{7DC11349-FF12-4A00-9259-409E4EBA48B8}</string>
								<ProtectedString name="Source"><![CDATA[local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXB9648D263B2F48CA9232925A6A25A25F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">services</string>
						<string name="ScriptGuid">{0E13145F-E612-4077-8730-4C4915C6BF58}</string>
						<ProtectedString name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX701315F30D8C4C5791E69C401C9ABA1B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">spring</string>
						<string name="ScriptGuid">{D43DCC65-D696-4764-8F1B-163B6AB62B2D}</string>
						<ProtectedString name="Source"><![CDATA[-- Simulates the motion of a critically damped spring
-- @original fractality
-- @editor Validark

local Spring = {}
Spring.__index = Spring

local tau = math.pi * 2
local exp = math.exp
local sin = math.sin
local cos = math.cos
local sqrt = math.sqrt

local EPSILON = 1e-4

function Spring.new(position, angularFrequency, goal, dampingRatio)
	angularFrequency = angularFrequency or 10
	dampingRatio = dampingRatio or 1

	if dampingRatio * angularFrequency < 0 then
		error("Spring does not converge", 2)
	end

	return setmetatable({
		goal = goal or position,
		dampingRatio = dampingRatio,
		angularFrequency = angularFrequency,
	}, Spring):resetToPosition(position)
end

function Spring:resetToPosition(position)
	self.position = position
	self.velocity = position * 0 -- Match the original vector type
	return self
end

function Spring:update(deltaTime)
	local dampingRatio = self.dampingRatio
	local angularFrequency = self.angularFrequency * tau
	local goal = self.goal
	local p0 = self.position
	local v0 = self.velocity

	local offset = p0 - goal
	local decay = exp(-dampingRatio * angularFrequency * deltaTime)
	local position

	if dampingRatio == 1 then -- Critically damped
		position = (offset * (1 + angularFrequency * deltaTime) + v0 * deltaTime) * decay + goal
		self.velocity = (v0 * (1 - angularFrequency * deltaTime) - offset * (angularFrequency * angularFrequency * deltaTime)) * decay
	elseif dampingRatio < 1 then -- Underdamped
		local c = sqrt(1 - dampingRatio * dampingRatio)
		local i = cos(angularFrequency * c * deltaTime)
		local j = sin(angularFrequency * c * deltaTime)

		-- Damping ratios approaching 1 can cause division by small numbers.
		-- To fix that, group terms around z=j/c and find an approximation for z.
		-- Start with the definition of z:
		--    z = sin(deltaTime*angularFrequency*c)/c
		-- Substitute a=deltaTime*angularFrequency:
		--    z = sin(a*c)/c
		-- Take the Maclaurin expansion of z with respect to c:
		--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)
		--    z ≈ a - (a^3*c^2)/6 + (a^5*c^4)/120
		-- Rewrite in Horner form:
		--    z ≈ a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6

		local z
		if c > EPSILON then
			z = j / c
		else
			local a = deltaTime * angularFrequency
			z = a + ((a * a) * (c * c) * (c * c) / 20 - c * c) * (a * a * a) / 6
		end

		-- Frequencies approaching 0 present a similar problem.
		-- We want an approximation for y as angularFrequency approaches 0, where:
		--    y = sin(deltaTime*angularFrequency*c)/(angularFrequency*c)
		-- Substitute b=deltaTime*c:
		--    y = sin(b*c)/b
		-- Now reapply the process from z.

		local y
		if angularFrequency * c > EPSILON then
			y = j / (angularFrequency * c)
		else
			local b = angularFrequency * c
			y = deltaTime + ((deltaTime * deltaTime) * (b * b) * (b * b) / 20 - b * b) * (deltaTime * deltaTime * deltaTime) / 6
		end

		position = (offset * (i + dampingRatio * z) + v0 * y) * decay + goal
		self.velocity = (v0 * (i - z * dampingRatio) - offset * (z * angularFrequency)) * decay
	else -- Overdamped
		local c = sqrt(dampingRatio * dampingRatio - 1)

		local r1 = -angularFrequency * (dampingRatio - c)
		local r2 = -angularFrequency * (dampingRatio + c)

		local co2 = (v0 - offset * r1) / (2 * angularFrequency * c)
		local co1 = offset - co2

		local e1 = co1 * exp(r1 * deltaTime)
		local e2 = co2 * exp(r2 * deltaTime)

		position = e1 + e2 + goal
		self.velocity = e1 * r1 + e2 * r2
	end

	self.position = position
	return position
end

return Spring
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX83C3F2EA6C5644818F67D2218985BDB4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">t</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX9A94E3896ADB4C0A8C16250B0E5ADDD6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">lib</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5CCF414BB85441DBB6F3C2D9944CCD75">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ts</string>
								<string name="ScriptGuid">{52FC629D-CABF-4890-A78A-16CA01ED6ACB}</string>
								<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

local t = {}

function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

t.boolean = primitive("boolean")
t.thread = primitive("thread")
t.callback = primitive("function")
t["function"] = t.callback
t.none = primitive("nil")
t["nil"] = t.none
t.string = primitive("string")
t.table = primitive("table")
t.userdata = primitive("userdata")

function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

function t.nan(value)
	if value ~= value then
		return true
	else
		return false
	end
end

-- roblox types

t.Axes = primitive("Axes")
t.BrickColor = primitive("BrickColor")
t.CFrame = primitive("CFrame")
t.Color3 = primitive("Color3")
t.ColorSequence = primitive("ColorSequence")
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")
t.Faces = primitive("Faces")
t.Instance = primitive("Instance")
t.NumberRange = primitive("NumberRange")
t.NumberSequence = primitive("NumberSequence")
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")
t.PathWaypoint = primitive("PathWaypoint")
t.PhysicalProperties = primitive("PhysicalProperties")
t.Random = primitive("Random")
t.Ray = primitive("Ray")
t.Rect = primitive("Rect")
t.Region3 = primitive("Region3")
t.Region3int16 = primitive("Region3int16")
t.TweenInfo = primitive("TweenInfo")
t.UDim = primitive("UDim")
t.UDim2 = primitive("UDim2")
t.Vector2 = primitive("Vector2")
t.Vector3 = primitive("Vector3")
t.Vector3int16 = primitive("Vector3int16")
t.Enum = primitive("Enum")
t.EnumItem = primitive("EnumItem")
t.RBXScriptSignal = primitive("RBXScriptSignal")
t.RBXScriptConnection = primitive("RBXScriptConnection")

function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

t.exactly = t.literal

function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value >= min then
			return true
		else
			return false
		end
	end
end

function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value <= max then
			return true
		else
			return false
		end
	end
end

function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if min < value then
			return true
		else
			return false
		end
	end
end

function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value < max then
			return true
		else
			return false
		end
	end
end

t.numberPositive = t.numberMinExclusive(0)
t.numberNegative = t.numberMaxExclusive(0)

function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)
	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)
	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end
		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)
	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)

	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)
		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)

	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end
end

do
	local checkInterface = t.map(t.any, t.callback)

	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end
			return true
		end
	end

	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

function t.instanceOf(className)
	assert(t.string(className))

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		return true
	end
end

t.instance = t.instanceOf

function t.instanceIsA(className)
	assert(t.string(className))

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		return true
	end
end

function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX3ED79EDDD98D488AA3500BAA50217D97">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">testez</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3D42ACE3E9C3429F945C2AD467674EC3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">src</string>
							<string name="ScriptGuid">{400D37E5-CBCA-4367-99EB-A6284EC57B65}</string>
							<ProtectedString name="Source"><![CDATA[local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX40772642027D4A2CBD5FADF031B70079">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Context</string>
								<string name="ScriptGuid">{1834CF69-5504-425C-9676-4664953EC2BB}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD7EA767C680D4ABCBA400FA1DA2DDC48">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Expectation</string>
								<string name="ScriptGuid">{87F7BDC5-E658-4C10-B5C5-FDABC1DEDDC7}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (type(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is truthy
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called
]]
function Expectation:throw()
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	local message = formatMessage(self.successCondition,
		"Expected function to throw an error, but it did not.",
		("Expected function to succeed, but it threw an error: %s"):format(
			tostring(err)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5A4329D07B1140599416C7DE1D61804A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LifecycleHooks</string>
								<string name="ScriptGuid">{45E0E1A9-05C8-4641-B12A-ED2D0AA1F0AD}</string>
								<ProtectedString name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX92E038EF67B84EA5AEF8ACF4C7031D21">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Reporters</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX5B0BC91514614E318579C00857D726D7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TeamCityReporter</string>
									<string name="ScriptGuid">{C20BCB43-3EC0-403A-ABA4-51E0183706BC}</string>
									<ProtectedString name="Source"><![CDATA[local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX97C31ECBBC6A47F5BEFA3737B5A2327E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TextReporter</string>
									<string name="ScriptGuid">{AE81F99E-7B23-433A-9926-025FA501EDC6}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() < b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX427D471809324392A0980D080247EBDC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TextReporterQuiet</string>
									<string name="ScriptGuid">{A2BA41DE-9656-46AA-8F23-2A51FC539641}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX132E38BE968E4ECABA0C41AF40372789">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestBootstrap</string>
								<string name="ScriptGuid">{BDE49708-9758-40E8-95AE-DF6E75E5F1BD}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX69F45360ECBD41E5A6BAE842619163EF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestEnum</string>
								<string name="ScriptGuid">{E751B226-B070-460C-8CE9-E14A9E9D51BA}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0F1F34C7B30947FA8EAF89DBF4FB3459">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestPlan</string>
								<string name="ScriptGuid">{8BCFA7D3-834A-4115-8627-2E519BC729AA}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = Expectation.new

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, debug.traceback)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBE251FB3C9864AED972C477D300B1E41">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestPlanner</string>
								<string name="ScriptGuid">{811B9EC7-B22C-4663-90BD-1F39250867A3}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting < b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF2CEDCAB17D34A62838445FC6E6085F7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestResults</string>
								<string name="ScriptGuid">{41A417AE-C676-472D-8F65-1BBCE2CB6768}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3E1C3ABB5C8F4F1D959E5BD7AF15D258">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestRunner</string>
								<string name="ScriptGuid">{95539AE8-E07C-4660-9A2C-14B875115E9A}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local Expectation = require(script.Parent.Expectation)
local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

function TestRunner.environment.expect(...)
	return Expectation.new(...)
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. message .. "\n" .. debug.traceback()
		end

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. message .. "\n" .. debug.traceback()
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		do
			local success, errorMessage = runCallback(childPlanNode.callback)
			if not success then
				return false, errorMessage
			end
		end

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			session:pushNode(childPlanNode)

			if childPlanNode.type == TestEnum.NodeType.It then
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
			end

			session:popNode()
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBF0953D80FC9423BB74AA85625383FDA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestSession</string>
								<string name="ScriptGuid">{282BAB42-6D3D-4828-9F1A-F88BAAD13301}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)

	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)
	table.insert(self.contextStack, context)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXDED8BC9AFA0A498C875E1E93B0CB82DE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">types</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX0F5D99FEB6F042C2B9B89F7F319535CD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">include</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX4AE7992B927D482DAEDE2E048DD7BF30">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">generated</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXB629A7F39F7843B9B20B74BA96277EF4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">validate-tree</string>
						<string name="ScriptGuid">{AE9D3342-2827-43C4-9FA5-8FB7A6C838F7}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0-beta.11
local TS = _G[script]
-- * Defines a Rojo-esque tree type which defines an abstract object tree.
-- * Evaluates a Rojo-esque tree and transforms it into an indexable type.
local function getService(serviceName)
	-- @ts-expect-error
	return game:GetService(serviceName)
end
--[[
	* Returns whether a given Instance matches a particular Rojo-esque InstanceTree.
	* @param object The object which needs validation
	* @param tree The tree to validate
	* @param violators
]]
local function validateTree(object, tree, violators)
	if tree["$className"] ~= nil and not object:IsA(tree["$className"]) then
		return false
	end
	local matches = true
	local _0 = object
	if _0.ClassName == "DataModel" then
		for serviceName, classOrTree in pairs(tree) do
			if serviceName ~= "$className" then
				local result = { pcall(getService, serviceName) }
				if not result[1] then
					if violators then
						matches = false
						local _1 = violators
						local _2 = 'game.GetService("' .. serviceName .. '")'
						-- ▼ Array.push ▼
						_1[#_1 + 1] = _2
						-- ▲ Array.push ▲
					end
					return false
				end
				local _1 = result
				local value = _1[2]
				local _2 = value
				if _2 then
					local _3 = classOrTree
					local _4 = type(_3) == "string"
					if not _4 then
						_4 = validateTree(value, classOrTree, violators)
					end
					_2 = _4
				end
				if _2 then
					if value.Name ~= serviceName then
						value.Name = serviceName
					end
				else
					if violators then
						matches = false
						local _3 = violators
						local _4 = 'game.GetService("' .. serviceName .. '")'
						-- ▼ Array.push ▼
						_3[#_3 + 1] = _4
						-- ▲ Array.push ▲
					else
						return false
					end
				end
			end
		end
	else
		local whitelistedKeys = {
			["$className"] = true,
		}
		for _, child in ipairs(object:GetChildren()) do
			local childName = child.Name
			if childName ~= "$className" then
				local classOrTree = tree[childName]
				local _1 = classOrTree
				local _2
				if type(_1) == "string" then
					_2 = child:IsA(classOrTree)
				else
					_2 = classOrTree and validateTree(child, classOrTree, violators)
				end
				if _2 then
					local _3 = whitelistedKeys
					local _4 = childName
					-- ▼ Set.add ▼
					_3[_4] = true
					-- ▲ Set.add ▲
				end
			end
		end
		for key in pairs(tree) do
			local _1 = whitelistedKeys
			local _2 = key
			if not (_1[_2] ~= nil) then
				if violators then
					matches = false
					local _3 = violators
					local _4 = object:GetFullName() .. "." .. key
					-- ▼ Array.push ▼
					_3[#_3 + 1] = _4
					-- ▲ Array.push ▲
				else
					return false
				end
			end
		end
	end
	return matches
end
--[[
	* Yields until a given tree of objects exists within an object.
	* @param tree Must be an object tree similar to ones considered valid by Rojo.
	* Every tree must have a `$className` member, and can have any number of keys which represent
	* the name of a child instance, which should have a corresponding value which is this same kind of tree.
	* There is also a shorthand syntax available, where setting a key equal to a className is equivalent
	* to an object with `$className` defined. Hence `Things: "Folder"` is equivalent to `Things: { $className: "Folder" }`
]]
local yieldForTree = TS.async(function(object, tree)
	if validateTree(object, tree) then
		return object
	else
		return TS.await(TS.Promise.new(function(resolve, _, onCancel)
			local connections = {}
			local warner = TS.Promise.delay(5)
			local function cleanup()
				for _, connection in ipairs(connections) do
					connection:Disconnect()
				end
				warner:cancel()
			end
			onCancel(cleanup)
			local function updateTreeForDescendant(violators)
				if validateTree(object, tree, violators) then
					cleanup()
					resolve(object)
					return true
				end
			end
			for _, descendant in ipairs(object:GetDescendants()) do
				local _0 = connections
				local _1 = descendant:GetPropertyChangedSignal("Name"):Connect(updateTreeForDescendant)
				-- ▼ Array.push ▼
				_0[#_0 + 1] = _1
				-- ▲ Array.push ▲
			end
			local _0 = connections
			local _1 = object.DescendantAdded:Connect(function(descendant)
				local _2 = connections
				local _3 = descendant:GetPropertyChangedSignal("Name"):Connect(updateTreeForDescendant)
				-- ▼ Array.push ▼
				_2[#_2 + 1] = _3
				-- ▲ Array.push ▲
				updateTreeForDescendant()
			end)
			-- ▼ Array.push ▼
			_0[#_0 + 1] = _1
			-- ▲ Array.push ▲
			local _2 = warner
			local _3 = function()
				local violators = {}
				if not updateTreeForDescendant(violators) then
					-- ▼ ReadonlyArray.join ▼
					local _4 = ", "
					if _4 == nil then
						_4 = ", "
					end
					-- ▲ ReadonlyArray.join ▲
					warn("[yieldForTree] Infinite yield possible. Waiting for: " .. table.concat(violators, _4))
				end
			end
			_2:andThen(_3)
		end))
	end
end)
return {
	validateTree = validateTree,
	yieldForTree = yieldForTree,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX1089CA7FAEFF422FA507FA4A3834345B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">node_modules</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX1BA8AA37870E44C9B211F4B7702E73B6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">@rbxts</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXD4C06EE864584AB1846A066C76FF0B19">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">compiler-types</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX6AF5BE8FB96C4759A1DD03BF3A773A71">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">types</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX497F145F27F64EE5A642CA6A8E6A5CA2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">yield-for-character</string>
						<string name="ScriptGuid">{D2033BA4-B3C5-47CA-A5B6-952F8BEEF85C}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.0.0-beta.11
local TS = _G[script]
local yieldForTree = TS.import(script, TS.getModule(script, "validate-tree")).yieldForTree
local CharacterRigR6 = {
	["$className"] = "Model",
	Head = {
		["$className"] = "Part",
		FaceCenterAttachment = "Attachment",
		FaceFrontAttachment = "Attachment",
		HairAttachment = "Attachment",
		HatAttachment = "Attachment",
		Mesh = "SpecialMesh",
		face = "Decal",
	},
	HumanoidRootPart = {
		["$className"] = "Part",
		RootAttachment = "Attachment",
		RootJoint = "Motor6D",
	},
	Humanoid = {
		["$className"] = "Humanoid",
		Animator = "Animator",
		HumanoidDescription = "HumanoidDescription",
	},
	["Left Arm"] = {
		["$className"] = "Part",
		LeftGripAttachment = "Attachment",
		LeftShoulderAttachment = "Attachment",
	},
	["Left Leg"] = {
		["$className"] = "Part",
		LeftFootAttachment = "Attachment",
	},
	["Right Arm"] = {
		["$className"] = "Part",
		RightGripAttachment = "Attachment",
		RightShoulderAttachment = "Attachment",
	},
	["Right Leg"] = {
		["$className"] = "Part",
		RightFootAttachment = "Attachment",
	},
	Torso = {
		["$className"] = "Part",
		["Left Hip"] = "Motor6D",
		["Left Shoulder"] = "Motor6D",
		["Right Hip"] = "Motor6D",
		["Right Shoulder"] = "Motor6D",
		Neck = "Motor6D",
		BodyBackAttachment = "Attachment",
		BodyFrontAttachment = "Attachment",
		LeftCollarAttachment = "Attachment",
		NeckAttachment = "Attachment",
		RightCollarAttachment = "Attachment",
		WaistBackAttachment = "Attachment",
		WaistCenterAttachment = "Attachment",
		WaistFrontAttachment = "Attachment",
	},
	["Body Colors"] = "BodyColors",
}
local CharacterRigR15 = {
	["$className"] = "Model",
	HumanoidRootPart = {
		["$className"] = "Part",
		RootRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		OriginalSize = "Vector3Value",
	},
	LeftHand = {
		["$className"] = "MeshPart",
		LeftWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftGripAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftWrist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftLowerArm = {
		["$className"] = "MeshPart",
		LeftElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftElbow = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftUpperArm = {
		["$className"] = "MeshPart",
		LeftShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulderAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulder = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightHand = {
		["$className"] = "MeshPart",
		RightWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightGripAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightWrist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightLowerArm = {
		["$className"] = "MeshPart",
		RightElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightElbow = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightUpperArm = {
		["$className"] = "MeshPart",
		RightShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulderAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulder = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	UpperTorso = {
		["$className"] = "MeshPart",
		WaistRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		BodyFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		BodyBackAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftCollarAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightCollarAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Waist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftFoot = {
		["$className"] = "MeshPart",
		LeftAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftAnkle = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftLowerLeg = {
		["$className"] = "MeshPart",
		LeftKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftKnee = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftUpperLeg = {
		["$className"] = "MeshPart",
		LeftHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftHip = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightFoot = {
		["$className"] = "MeshPart",
		RightAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightAnkle = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightLowerLeg = {
		["$className"] = "MeshPart",
		RightKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightKnee = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightUpperLeg = {
		["$className"] = "MeshPart",
		RightHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightHip = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LowerTorso = {
		["$className"] = "MeshPart",
		RootRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistCenterAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistBackAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Root = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	Humanoid = {
		["$className"] = "Humanoid",
		Animator = "Animator",
		BodyTypeScale = "NumberValue",
		BodyProportionScale = "NumberValue",
		BodyWidthScale = "NumberValue",
		BodyHeightScale = "NumberValue",
		BodyDepthScale = "NumberValue",
		HeadScale = "NumberValue",
		HumanoidDescription = "HumanoidDescription",
	},
	Head = {
		["$className"] = "Part",
		Mesh = {
			["$className"] = "SpecialMesh",
			OriginalSize = "Vector3Value",
		},
		FaceCenterAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		FaceFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		HairAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		HatAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Neck = "Motor6D",
		face = "Decal",
		OriginalSize = "Vector3Value",
	},
	["Body Colors"] = "BodyColors",
}
-- * Yields until every member of CharacterRigR6 exists
local function yieldForR6CharacterDescendants(character)
	return yieldForTree(character, CharacterRigR6)
end
-- * Yields until every member of CharacterRigR15 exists
local function yieldForR15CharacterDescendants(character)
	return yieldForTree(character, CharacterRigR15)
end
local default = yieldForR15CharacterDescendants
return {
	yieldForR6CharacterDescendants = yieldForR6CharacterDescendants,
	yieldForR15CharacterDescendants = yieldForR15CharacterDescendants,
	CharacterRigR6 = CharacterRigR6,
	CharacterRigR15 = CharacterRigR15,
	default = default,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXCDB37A78AED343D39FE4A3D5220CB72E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">node_modules</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXF01D874E814B45BC928627CB2F51D1B9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">@rbxts</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXA5686C4582FD4A92B8FDA915A6B9F17A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">compiler-types</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX49032CD6135E49C2BA6E615DB01FD313">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">types</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX70B2156542004C9C8F7D13303088BA2A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">knit</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB49696BE76D84BB2BC562AA4DF004BEE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">src</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local exports = {}

if RunService:IsServer() then
	exports.KnitServer = require(script.Knit.KnitServer)
else
	script.Knit.KnitServer:Destroy()
	exports.KnitClient = require(script.Knit.KnitClient)
end

exports.RemoteProperty = require(script.Knit.Util.Remote.RemoteProperty)
exports.RemoteSignal = require(script.Knit.Util.Remote.RemoteSignal)
exports.ClientRemoteProperty = require(script.Knit.Util.Remote.ClientRemoteProperty)
exports.ClientRemoteSignal = require(script.Knit.Util.Remote.ClientRemoteSignal)

exports.Component = require(script.Knit.Util.Component)
exports.Loader = require(script.Knit.Util.Loader)
exports.Maid = require(script.Knit.Util.Maid)
exports.Option = require(script.Knit.Util.Option)
exports.Promise = require(script.Knit.Util.Promise)
exports.Ser = require(script.Knit.Util.Ser)
exports.Signal = require(script.Knit.Util.Signal)
exports.Streamable = require(script.Knit.Util.Streamable)
exports.StreamableUtil = require(script.Knit.Util.StreamableUtil)
exports.Symbol = require(script.Knit.Util.Symbol)
exports.TableUtil = require(script.Knit.Util.TableUtil)
exports.Thread = require(script.Knit.Util.Thread)

return exports
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA4D2723F80ED47ADAC58028B6029912D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Knit</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[if (game:GetService("RunService"):IsServer()) then
	return require(script.KnitServer)
else
	script.KnitServer:Destroy()
	return require(script.KnitClient)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX2DD9B131381848A0AA2638C0A68ACCD8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">KnitClient</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--[[

	Knit.CreateController(controller): Controller
	Knit.AddControllers(folder): Controller[]
	Knit.AddControllersDeep(folder): Controller[]
	Knit.GetService(serviceName): Service
	Knit.GetController(controllerName): Controller
	Knit.Start(): Promise<void>
	Knit.OnStart(): Promise<void>

--]]

local KnitClient = {}

KnitClient.Version = script.Parent.Version.Value
KnitClient.Player = game:GetService("Players").LocalPlayer
KnitClient.Controllers = {}
KnitClient.Util = script.Parent.Util

local Promise = require(KnitClient.Util.Promise)
local Thread = require(KnitClient.Util.Thread)
local Loader = require(KnitClient.Util.Loader)
local Ser = require(KnitClient.Util.Ser)
local ClientRemoteSignal = require(KnitClient.Util.Remote.ClientRemoteSignal)
local ClientRemoteProperty = require(KnitClient.Util.Remote.ClientRemoteProperty)
local TableUtil = require(KnitClient.Util.TableUtil)

local services = {}
local servicesFolder = script.Parent:WaitForChild("Services")

local started = false
local startedComplete = false
local onStartedComplete = Instance.new("BindableEvent")


local function BuildService(serviceName, folder)
	local service = {}
	if (folder:FindFirstChild("RF")) then
		for _,rf in ipairs(folder.RF:GetChildren()) do
			if (rf:IsA("RemoteFunction")) then
				service[rf.Name] = function(self, ...)
					return Ser.DeserializeArgsAndUnpack(rf:InvokeServer(Ser.SerializeArgsAndUnpack(...)))
				end
				service[rf.Name .. "Promise"] = function(self, ...)
					local args = Ser.SerializeArgs(...)
					return Promise.new(function(resolve)
						resolve(Ser.DeserializeArgsAndUnpack(rf:InvokeServer(table.unpack(args, 1, args.n))))
					end)
				end
			end
		end
	end
	if (folder:FindFirstChild("RE")) then
		for _,re in ipairs(folder.RE:GetChildren()) do
			if (re:IsA("RemoteEvent")) then
				service[re.Name] = ClientRemoteSignal.new(re)
			end
		end
	end
	if (folder:FindFirstChild("RP")) then
		for _,rp in ipairs(folder.RP:GetChildren()) do
			if (rp:IsA("ValueBase") or rp:IsA("RemoteEvent")) then
				service[rp.Name] = ClientRemoteProperty.new(rp)
			end
		end
	end
	services[serviceName] = service
	return service
end


function KnitClient.CreateController(controller)
	assert(type(controller) == "table", "Controller must be a table; got " .. type(controller))
	assert(type(controller.Name) == "string", "Controller.Name must be a string; got " .. type(controller.Name))
	assert(#controller.Name > 0, "Controller.Name must be a non-empty string")
	assert(KnitClient.Controllers[controller.Name] == nil, "Service \"" .. controller.Name .. "\" already exists")
	TableUtil.Extend(controller, {
		_knit_is_controller = true;
	})
	KnitClient.Controllers[controller.Name] = controller
	return controller
end


function KnitClient.AddControllers(folder)
	return Loader.LoadChildren(folder)
end


function KnitClient.AddControllersDeep(folder)
	return Loader.LoadDescendants(folder)
end


function KnitClient.GetService(serviceName)
	assert(type(serviceName) == "string", "ServiceName must be a string; got " .. type(serviceName))
	local folder = servicesFolder:FindFirstChild(serviceName)
	assert(folder ~= nil, "Could not find service \"" .. serviceName .. "\"")
	return services[serviceName] or BuildService(serviceName, folder)
end


function KnitClient.GetController(controllerName)
	return KnitClient.Controllers[controllerName]
end


function KnitClient.Start()

	if (started) then
		return Promise.Reject("Knit already started")
	end

	started = true

	local controllers = KnitClient.Controllers

	return Promise.new(function(resolve)

		-- Init:
		local promisesStartControllers = {}
		for _,controller in pairs(controllers) do
			if (type(controller.KnitInit) == "function") then
				table.insert(promisesStartControllers, Promise.new(function(r)
					controller:KnitInit()
					r()
				end))
			end
		end

		resolve(Promise.All(promisesStartControllers))

	end):Then(function()

		-- Start:
		for _,controller in pairs(controllers) do
			if (type(controller.KnitStart) == "function") then
				Thread.SpawnNow(controller.KnitStart, controller)
			end
		end

		startedComplete = true
		onStartedComplete:Fire()

		Thread.Spawn(function()
			onStartedComplete:Destroy()
		end)

	end)

end


function KnitClient.OnStart()
	if (startedComplete) then
		return Promise.Resolve()
	else
		return Promise.new(function(resolve)
			if (startedComplete) then
				resolve()
				return
			end
			onStartedComplete.Event:Wait()
			resolve()
		end)
	end
end


return KnitClient]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX768BA02CB4DA4CE1A4D892401B68525F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">KnitServer</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--[[

	Knit.CreateService(service): Service
	Knit.AddServices(folder): Service[]
	Knit.AddServicesDeep(folder): Service[]
	Knit.Start(): Promise<void>
	Knit.OnStart(): Promise<void>

--]]


local KnitServer = {}

KnitServer.Version = script.Parent.Version.Value
KnitServer.Services = {}
KnitServer.Util = script.Parent.Util


local knitRepServiceFolder = Instance.new("Folder")
knitRepServiceFolder.Name = "Services"

local Promise = require(KnitServer.Util.Promise)
local Thread = require(KnitServer.Util.Thread)
local Signal = require(KnitServer.Util.Signal)
local Loader = require(KnitServer.Util.Loader)
local Ser = require(KnitServer.Util.Ser)
local RemoteSignal = require(KnitServer.Util.Remote.RemoteSignal)
local RemoteProperty = require(KnitServer.Util.Remote.RemoteProperty)
local TableUtil = require(KnitServer.Util.TableUtil)

local started = false
local startedComplete = false
local onStartedComplete = Instance.new("BindableEvent")


local function CreateRepFolder(serviceName)
	local folder = Instance.new("Folder")
	folder.Name = serviceName
	return folder
end


local function GetFolderOrCreate(parent, name)
	local f = parent:FindFirstChild(name)
	if (not f) then
		f = Instance.new("Folder")
		f.Name = name
		f.Parent = parent
	end
	return f
end


local function AddToRepFolder(service, remoteObj, folderOverride)
	if (folderOverride) then
		remoteObj.Parent = GetFolderOrCreate(service._knit_rep_folder, folderOverride)
	elseif (remoteObj:IsA("RemoteFunction")) then
		remoteObj.Parent = GetFolderOrCreate(service._knit_rep_folder, "RF")
	elseif (remoteObj:IsA("RemoteEvent")) then
		remoteObj.Parent = GetFolderOrCreate(service._knit_rep_folder, "RE")
	elseif (remoteObj:IsA("ValueBase")) then
		remoteObj.Parent = GetFolderOrCreate(service._knit_rep_folder, "RP")
	else
		error("Invalid rep object: " .. remoteObj.ClassName)
	end
	if (not service._knit_rep_folder.Parent) then
		service._knit_rep_folder.Parent = knitRepServiceFolder
	end
end


function KnitServer.IsService(object)
	return type(object) == "table" and object._knit_is_service == true
end


function KnitServer.CreateService(service)
	assert(type(service) == "table", "Service must be a table; got " .. type(service))
	assert(type(service.Name) == "string", "Service.Name must be a string; got " .. type(service.Name))
	assert(#service.Name > 0, "Service.Name must be a non-empty string")
	assert(KnitServer.Services[service.Name] == nil, "Service \"" .. service.Name .. "\" already exists")
	TableUtil.Extend(service, {
		_knit_is_service = true;
		_knit_rf = {};
		_knit_re = {};
		_knit_rp = {};
		_knit_rep_folder = CreateRepFolder(service.Name);
	})
	if (type(service.Client) ~= "table") then
		service.Client = {Server = service}
	else
		if (service.Client.Server ~= service) then
			service.Client.Server = service
		end
	end
	KnitServer.Services[service.Name] = service
	return service
end


function KnitServer.AddServices(folder)
	return Loader.LoadChildren(folder)
end


function KnitServer.AddServicesDeep(folder)
	return Loader.LoadDescendants(folder)
end


function KnitServer.GetService(serviceName)
	assert(type(serviceName) == "string", "ServiceName must be a string; got " .. type(serviceName))
	return assert(KnitServer.Services[serviceName], "Could not find service \"" .. serviceName .. "\"")
end


function KnitServer.BindRemoteEvent(service, eventName, remoteEvent)
	assert(service._knit_re[eventName] == nil, "RemoteEvent \"" .. eventName .. "\" already exists")
	local re = remoteEvent._remote
	re.Name = eventName
	service._knit_re[eventName] = re
	AddToRepFolder(service, re)
end


function KnitServer.BindRemoteFunction(service, funcName, func)
	assert(service._knit_rf[funcName] == nil, "RemoteFunction \"" .. funcName .. "\" already exists")
	local rf = Instance.new("RemoteFunction")
	rf.Name = funcName
	service._knit_rf[funcName] = rf
	AddToRepFolder(service, rf)
	function rf.OnServerInvoke(...)
		return Ser.SerializeArgsAndUnpack(func(service.Client, Ser.DeserializeArgsAndUnpack(...)))
	end
end


function KnitServer.BindRemoteProperty(service, propName, prop)
	assert(service._knit_rp[propName] == nil, "RemoteProperty \"" .. propName .. "\" already exists")
	prop._object.Name = propName
	service._knit_rp[propName] = prop
	AddToRepFolder(service, prop._object, "RP")
end


function KnitServer.Start()

	if (started) then
		return Promise.Reject("Knit already started")
	end

	started = true

	local services = KnitServer.Services

	return Promise.new(function(resolve)

		-- Bind remotes:
		for _,service in pairs(services) do
			for k,v in pairs(service.Client) do
				if (type(v) == "function") then
					KnitServer.BindRemoteFunction(service, k, v)
				elseif (RemoteSignal.Is(v)) then
					KnitServer.BindRemoteEvent(service, k, v)
				elseif (RemoteProperty.Is(v)) then
					KnitServer.BindRemoteProperty(service, k, v)
				elseif (Signal.Is(v)) then
					warn("Found Signal instead of RemoteSignal (Knit.Util.RemoteSignal). Please change to RemoteSignal. [" .. service.Name .. ".Client." .. k .. "]")
				end
			end
		end

		-- Init:
		local promisesInitServices = {}
		for _,service in pairs(services) do
			if (type(service.KnitInit) == "function") then
				table.insert(promisesInitServices, Promise.new(function(r)
					service:KnitInit()
					r()
				end))
			end
		end

		resolve(Promise.All(promisesInitServices))

	end):Then(function()

		-- Start:
		for _,service in pairs(services) do
			if (type(service.KnitStart) == "function") then
				Thread.SpawnNow(service.KnitStart, service)
			end
		end

		startedComplete = true
		onStartedComplete:Fire()

		Thread.Spawn(function()
			onStartedComplete:Destroy()
		end)

		-- Expose service remotes to everyone:
		knitRepServiceFolder.Parent = script.Parent

	end)

end


function KnitServer.OnStart()
	if (startedComplete) then
		return Promise.Resolve()
	else
		return Promise.new(function(resolve)
			if (startedComplete) then
				resolve()
				return
			end
			onStartedComplete.Event:Wait()
			resolve()
		end)
	end
end


return KnitServer]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX14E0D388CC9540C88A331EB65A297A70">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Util</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX079662FCF34A4FA88D0AB104446B8268">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Component</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Component
-- Stephen Leitnick
-- July 25, 2020

--[[

	Component.Auto(folder)
		-> Create components automatically from descendant modules of this folder
		-> Each module must have a '.Tag' string property
		-> Each module optionally can have '.RenderPriority' number property

	component = Component.FromTag(tag)
		-> Retrieves an existing component from the tag name

	component = Component.new(tag, class [, renderPriority])
		-> Creates a new component from the tag name, class module, and optional render priority

	component:GetAll()
	component:GetFromInstance(instance)
	component:GetFromID(id)
	component:Filter(filterFunc)
	component:WaitFor(instanceOrName)
	component:Destroy()

	component.Added(obj)
	component.Removed(obj)

	-----------------------------------------------------------------------

	A component class must look something like this:

		-- DEFINE
		local MyComponent = {}
		MyComponent.__index = MyComponent

		-- CONSTRUCTOR
		function MyComponent.new(instance)
			local self = setmetatable({}, MyComponent)
			return self
		end

		-- FIELDS AFTER CONSTRUCTOR COMPLETES
		MyComponent.Instance: Instance

		-- OPTIONAL LIFECYCLE HOOKS
		function MyComponent:Init() end                     -> Called right after constructor
		function MyComponent:Deinit() end                   -> Called right before deconstructor
		function MyComponent:HeartbeatUpdate(dt) ... end    -> Updates every heartbeat
		function MyComponent:SteppedUpdate(dt) ... end      -> Updates every physics step
		function MyComponent:RenderUpdate(dt) ... end       -> Updates every render step

		-- DESTRUCTOR
		function MyComponent:Destroy()
		end


	A component is then registered like so:

		local Component = require(Knit.Util.Component)
		local MyComponent = require(somewhere.MyComponent)
		local tag = "MyComponent"

		local myComponent = Component.new(tag, MyComponent)


	Components can be listened and queried:

		myComponent.Added:Connect(function(instanceOfComponent)
			-- New MyComponent constructed
		end)

		myComponent.Removed:Connect(function(instanceOfComponent)
			-- New MyComponent deconstructed
		end)

--]]


local Maid = require(script.Parent.Maid)
local Signal = require(script.Parent.Signal)
local Promise = require(script.Parent.Promise)
local Thread = require(script.Parent.Thread)
local TableUtil = require(script.Parent.TableUtil)
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IS_SERVER = RunService:IsServer()
local DEFAULT_WAIT_FOR_TIMEOUT = 60
local ATTRIBUTE_ID_NAME = "ComponentServerId"

-- Components will only work on instances parented under these descendants:
local DESCENDANT_WHITELIST = {workspace, Players}

local Component = {}
Component.__index = Component

local componentsByTag = {}


local function FastRemove(tbl, i)
	local n = #tbl
	tbl[i] = tbl[n]
	tbl[n] = nil
end


local function IsDescendantOfWhitelist(instance)
	for _,v in ipairs(DESCENDANT_WHITELIST) do
		if (instance:IsDescendantOf(v)) then
			return true
		end
	end
	return false
end


function Component.FromTag(tag)
	return componentsByTag[tag]
end


function Component.Auto(folder)
	local function Setup(moduleScript)
		local m = require(moduleScript)
		assert(type(m) == "table", "Expected table for component")
		assert(type(m.Tag) == "string", "Expected .Tag property")
		Component.new(m.Tag, m, m.RenderPriority)
	end
	for _,v in ipairs(folder:GetDescendants()) do
		if (v:IsA("ModuleScript")) then
			Setup(v)
		end
	end
	folder.DescendantAdded:Connect(function(v)
		if (v:IsA("ModuleScript")) then
			Setup(v)
		end
	end)
end


function Component.new(tag, class, renderPriority)

	assert(type(tag) == "string", "Argument #1 (tag) should be a string; got " .. type(tag))
	assert(type(class) == "table", "Argument #2 (class) should be a table; got " .. type(class))
	assert(type(class.new) == "function", "Class must contain a .new constructor function")
	assert(type(class.Destroy) == "function", "Class must contain a :Destroy function")
	assert(componentsByTag[tag] == nil, "Component already bound to this tag")

	local self = setmetatable({}, Component)

	self.Added = Signal.new()
	self.Removed = Signal.new()

	self._maid = Maid.new()
	self._lifecycleMaid = Maid.new()
	self._tag = tag
	self._class = class
	self._objects = {}
	self._instancesToObjects = {}
	self._hasHeartbeatUpdate = (type(class.HeartbeatUpdate) == "function")
	self._hasSteppedUpdate = (type(class.SteppedUpdate) == "function")
	self._hasRenderUpdate = (type(class.RenderUpdate) == "function")
	self._hasInit = (type(class.Init) == "function")
	self._hasDeinit = (type(class.Deinit) == "function")
	self._renderPriority = renderPriority or Enum.RenderPriority.Last.Value
	self._lifecycle = false
	self._nextId = 0

	self._maid:GiveTask(CollectionService:GetInstanceAddedSignal(tag):Connect(function(instance)
		if (IsDescendantOfWhitelist(instance)) then
			self:_instanceAdded(instance)
		end
	end))

	self._maid:GiveTask(CollectionService:GetInstanceRemovedSignal(tag):Connect(function(instance)
		self:_instanceRemoved(instance)
	end))

	self._maid:GiveTask(self._lifecycleMaid)

	do
		local b = Instance.new("BindableEvent")
		for _,instance in ipairs(CollectionService:GetTagged(tag)) do
			if (IsDescendantOfWhitelist(instance)) then
				local c = b.Event:Connect(function()
					self:_instanceAdded(instance)
				end)
				b:Fire()
				c:Disconnect()
			end
		end
		b:Destroy()
	end

	componentsByTag[tag] = self
	self._maid:GiveTask(function()
		componentsByTag[tag] = nil
	end)

	return self

end


function Component:_startHeartbeatUpdate()
	local all = self._objects
	self._heartbeatUpdate = RunService.Heartbeat:Connect(function(dt)
		for _,v in ipairs(all) do
			v:HeartbeatUpdate(dt)
		end
	end)
	self._lifecycleMaid:GiveTask(self._heartbeatUpdate)
end


function Component:_startSteppedUpdate()
	local all = self._objects
	self._steppedUpdate = RunService.Stepped:Connect(function(_, dt)
		for _,v in ipairs(all) do
			v:SteppedUpdate(dt)
		end
	end)
	self._lifecycleMaid:GiveTask(self._steppedUpdate)
end


function Component:_startRenderUpdate()
	local all = self._objects
	self._renderName = (self._tag .. "RenderUpdate")
	RunService:BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		for _,v in ipairs(all) do
			v:RenderUpdate(dt)
		end
	end)
	self._lifecycleMaid:GiveTask(function()
		RunService:UnbindFromRenderStep(self._renderName)
	end)
end


function Component:_startLifecycle()
	self._lifecycle = true
	if (self._hasHeartbeatUpdate) then
		self:_startHeartbeatUpdate()
	end
	if (self._hasSteppedUpdate) then
		self:_startSteppedUpdate()
	end
	if (self._hasRenderUpdate) then
		self:_startRenderUpdate()
	end
end


function Component:_stopLifecycle()
	self._lifecycle = false
	self._lifecycleMaid:DoCleaning()
end


function Component:_instanceAdded(instance)
	if (self._instancesToObjects[instance]) then return end
	if (not self._lifecycle) then
		self:_startLifecycle()
	end
	self._nextId = (self._nextId + 1)
	local id = (self._tag .. tostring(self._nextId))
	if (IS_SERVER) then
		instance:SetAttribute(ATTRIBUTE_ID_NAME, id)
	end
	local obj = self._class.new(instance)
	obj.Instance = instance
	obj._id = id
	self._instancesToObjects[instance] = obj
	table.insert(self._objects, obj)
	if (self._hasInit) then
		Thread.Spawn(function()
			if (self._instancesToObjects[instance] ~= obj) then return end
			obj:Init()
		end)
	end
	self.Added:Fire(obj)
	return obj
end


function Component:_instanceRemoved(instance)
	self._instancesToObjects[instance] = nil
	for i,obj in ipairs(self._objects) do
		if (obj.Instance == instance) then
			if (self._hasDeinit) then
				obj:Deinit()
			end
			if (IS_SERVER and instance.Parent and instance:GetAttribute(ATTRIBUTE_ID_NAME) ~= nil) then
				instance:SetAttribute(ATTRIBUTE_ID_NAME, nil)
			end
			self.Removed:Fire(obj)
			obj:Destroy()
			obj._destroyed = true
			FastRemove(self._objects, i)
			break
		end
	end
	if (#self._objects == 0 and self._lifecycle) then
		self:_stopLifecycle()
	end
end


function Component:GetAll()
	return TableUtil.CopyShallow(self._objects)
end


function Component:GetFromInstance(instance)
	return self._instancesToObjects[instance]
end


function Component:GetFromID(id)
	for _,v in ipairs(self._objects) do
		if (v._id == id) then
			return v
		end
	end
	return nil
end


function Component:Filter(filterFunc)
	return TableUtil.Filter(self._objects, filterFunc)
end


function Component:WaitFor(instance, timeout)
	local isName = (type(instance) == "string")
	local function IsInstanceValid(obj)
		return ((isName and obj.Instance.Name == instance) or ((not isName) and obj.Instance == instance))
	end
	for _,obj in ipairs(self._objects) do
		if (IsInstanceValid(obj)) then
			return Promise.resolve(obj)
		end
	end
	local lastObj = nil
	return Promise.FromEvent(self.Added, function(obj)
		lastObj = obj
		return IsInstanceValid(obj)
	end):Then(function()
		return lastObj
	end):Timeout(timeout or DEFAULT_WAIT_FOR_TIMEOUT)
end


function Component:Destroy()
	self._maid:Destroy()
end


return Component]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXEBDA41C18A0249A5B3D980E5A4AB9469">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">EnumList</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- EnumList
-- Stephen Leitnick
-- January 08, 2021

--[[

	enumList = EnumList.new(name: string, enums: string[])

	enumList:Is(item)


	Example:

		direction = EnumList.new("Direction", {"Up", "Down", "Left", "Right"})
		leftDir = direction.Left
		print("IsDirection", direction:Is(leftDir))

--]]


local Symbol = require(script.Parent.Symbol)

local EnumList = {}


function EnumList.new(name, enums)
	local scope = Symbol.new(name)
	local enumItems = {}
	for _,enumName in ipairs(enums) do
		enumItems[enumName] = Symbol.new(enumName, scope)
	end
	local self = setmetatable({
		_scope = scope;
	}, {
		__index = function(_t, k)
			if (enumItems[k]) then
				return enumItems[k]
			elseif (EnumList[k]) then
				return EnumList[k]
			else
				error("Unknown " .. name .. ": " .. tostring(k), 2)
			end
		end;
		__newindex = function()
			error("Cannot add new " .. name, 2)
		end;
	})
	return self
end


function EnumList:Is(obj)
	return Symbol.IsInScope(obj, self._scope)
end


return EnumList]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX394F739401044AACB6AF5D8AA45E245B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Loader</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Loader
-- Stephen Leitnick
-- January 10, 2021

--[[

	Loads all ModuleScripts within the given parent.

	Loader.LoadChildren(parent: Instance): module[]
	Loader.LoadDescendants(parent: Instance): module[]

--]]


local Loader = {}


function Loader.LoadChildren(parent)
	local modules = {}
	for _,child in ipairs(parent:GetChildren()) do
		if (child:IsA("ModuleScript")) then
			local m = require(child)
			table.insert(modules, m)
		end
	end
	return modules
end


function Loader.LoadDescendants(parent)
	local modules = {}
	for _,descendant in ipairs(parent:GetDescendants()) do
		if (descendant:IsA("ModuleScript")) then
			local m = require(descendant)
			table.insert(modules, m)
		end
	end
	return modules
end


return Loader]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7EE5E15BD13F479D9A93DC380E8A7CC7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Maid</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Maid
-- Author: Quenty
-- Source: https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Events/Maid.lua
-- License: MIT (https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md)
-- This module has been modified for use in AeroGameFramework

--[[

	maid = Maid.new()

	maid:GiveTask(task)
		> task is an event connection, function, or instance/table with a 'Destroy' method

	maid:GivePromise(promise)
		> Give the maid a promise as a task, which will call 'promise:Cancel()' on cleanup

	maid:DoCleaning()
		> Alias for Destroy

	maid:Destroy()
		> Goes through each task & disconnects events, destroys instances, and calls functions

--]]

local Promise = require(script.Parent.Promise)


local Maid = {}
Maid.ClassName = "Maid"


function Maid.new()
	local self = setmetatable({
		_tasks = {};
	}, Maid)
	return self
end


--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if (Maid[index]) then
		return Maid[index]
	else
		return self._tasks[index]
	end
end


--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if (Maid[index] ~= nil) then
		error(("'%s' is reserved"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]
	tasks[index] = newTask

	if (oldTask) then
		if (type(oldTask) == "function") then
			oldTask()
		elseif (typeof(oldTask) == "RBXScriptConnection") then
			oldTask:Disconnect()
		elseif (oldTask.Destroy) then
			oldTask:Destroy()
		elseif (Promise.Is(oldTask)) then
			oldTask:Cancel()
		end
	end
end


--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = (#self._tasks + 1)
	self[taskId] = task

	if (type(task) == "table" and (not task.Destroy) and (not Promise.Is(task))) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end


function Maid:GivePromise(promise)
	assert(Promise.Is(promise), "Expected promise")
	if (promise:GetStatus() ~= Promise.Status.Started) then
		return promise
	end
	local newPromise = Promise.Resolve(promise)
	local id = self:GiveTask(newPromise)
	newPromise:Finally(function()
		self[id] = nil
	end)
	return newPromise
end


--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, task in pairs(tasks) do
		if (typeof(task) == "RBXScriptConnection") then
			tasks[index] = nil
			task:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, task = next(tasks)
	while (task ~= nil) do
		tasks[index] = nil
		if (type(task) == "function") then
			task()
		elseif (typeof(task) == "RBXScriptConnection") then
			task:Disconnect()
		elseif (task.Destroy) then
			task:Destroy()
		elseif (Promise.Is(task)) then
			task:Cancel()
		end
		index, task = next(tasks)
	end
end


--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXD253DC7AF2584D3E84A8A1483818521D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Option</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Option
-- Stephen Leitnick
-- August 28, 2020

--[[

	MatchTable {
		Some: (value: any) -> any
		None: () -> any
	}

	CONSTRUCTORS:

		Option.Some(anyNonNilValue): Option<any>
		Option.Wrap(anyValue): Option<any>


	STATIC FIELDS:

		Option.None: Option<None>


	STATIC METHODS:

		Option.Is(obj): boolean


	METHODS:

		opt:Match(): (matches: MatchTable) -> any
		opt:IsSome(): boolean
		opt:IsNone(): boolean
		opt:Unwrap(): any
		opt:Expect(errMsg: string): any
		opt:ExpectNone(errMsg: string): void
		opt:UnwrapOr(default: any): any
		opt:UnwrapOrElse(default: () -> any): any
		opt:And(opt2: Option<any>): Option<any>
		opt:AndThen(predicate: (unwrapped: any) -> Option<any>): Option<any>
		opt:Or(opt2: Option<any>): Option<any>
		opt:OrElse(orElseFunc: () -> Option<any>): Option<any>
		opt:XOr(opt2: Option<any>): Option<any>
		opt:Contains(value: any): boolean

	--------------------------------------------------------------------

	Options are useful for handling nil-value cases. Any time that an
	operation might return nil, it is useful to instead return an
	Option, which will indicate that the value might be nil, and should
	be explicitly checked before using the value. This will help
	prevent common bugs caused by nil values that can fail silently.


	Example:

	local result1 = Option.Some(32)
	local result2 = Option.Some(nil)
	local result3 = Option.Some("Hi")
	local result4 = Option.Some(nil)
	local result5 = Option.None

	-- Use 'Match' to match if the value is Some or None:
	result1:Match {
		Some = function(value) print(value) end;
		None = function() print("No value") end;
	}

	-- Raw check:
	if result2:IsSome() then
		local value = result2:Unwrap() -- Explicitly call Unwrap
		print("Value of result2:", value)
	end

	if result3:IsNone() then
		print("No result for result3")
	end

	-- Bad, will throw error bc result4 is none:
	local value = result4:Unwrap()

--]]


local CLASSNAME = "Option"

local Option = {}
Option.__index = Option


function Option._new(value)
	local self = setmetatable({
		ClassName = CLASSNAME;
		_v = value;
		_s = (value ~= nil);
	}, Option)
	return self
end


function Option.Some(value)
	assert(value ~= nil, "Option.Some() value cannot be nil")
	return Option._new(value)
end


function Option.Wrap(value)
	if (value == nil) then
		return Option.None
	else
		return Option.Some(value)
	end
end


function Option.Is(obj)
	return (type(obj) == "table" and getmetatable(obj) == Option)
end


function Option.Assert(obj)
	assert(Option.Is(obj), "Result was not of type Option")
end


function Option.Deserialize(data) -- type data = {ClassName: string, Value: any}
	assert(type(data) == "table" and data.ClassName == CLASSNAME, "Invalid data for deserializing Option")
	return (data.Value == nil and Option.None or Option.Some(data.Value))
end


function Option:Serialize()
	return {
		ClassName = self.ClassName;
		Value = self._v;
	}
end


function Option:Match(matches)
	local onSome = matches.Some
	local onNone = matches.None
	assert(type(onSome) == "function", "Missing 'Some' match")
	assert(type(onNone) == "function", "Missing 'None' match")
	if (self:IsSome()) then
		return onSome(self:Unwrap())
	else
		return onNone()
	end
end


function Option:IsSome()
	return self._s
end


function Option:IsNone()
	return (not self._s)
end


function Option:Expect(msg)
	assert(self:IsSome(), msg)
	return self._v
end


function Option:ExpectNone(msg)
	assert(self:IsNone(), msg)
end


function Option:Unwrap()
	return self:Expect("Cannot unwrap option of None type")
end


function Option:UnwrapOr(default)
	if (self:IsSome()) then
		return self:Unwrap()
	else
		return default
	end
end


function Option:UnwrapOrElse(defaultFunc)
	if (self:IsSome()) then
		return self:Unwrap()
	else
		return defaultFunc()
	end
end


function Option:And(optB)
	if (self:IsSome()) then
		return optB
	else
		return Option.None
	end
end


function Option:AndThen(andThenFunc)
	if (self:IsSome()) then
		local result = andThenFunc(self:Unwrap())
		Option.Assert(result)
		return result
	else
		return Option.None
	end
end


function Option:Or(optB)
	if (self:IsSome()) then
		return self
	else
		return optB
	end
end


function Option:OrElse(orElseFunc)
	if (self:IsSome()) then
		return self
	else
		local result = orElseFunc()
		Option.Assert(result)
		return result
	end
end


function Option:XOr(optB)
	local someOptA = self:IsSome()
	local someOptB = optB:IsSome()
	if (someOptA == someOptB) then
		return Option.None
	elseif (someOptA) then
		return self
	else
		return optB
	end
end


function Option:Filter(predicate)
	if (self:IsNone() or not predicate(self._v)) then
		return Option.None
	else
		return self
	end
end


function Option:Contains(value)
	return (self:IsSome() and self._v == value)
end


function Option:__tostring()
	if (self:IsSome()) then
		return ("Option<" .. typeof(self._v) .. ">")
	else
		return "Option<None>"
	end
end


function Option:__eq(opt)
	if (Option.Is(opt)) then
		if (self:IsSome() and opt:IsSome()) then
			return (self:Unwrap() == opt:Unwrap())
		elseif (self:IsNone() and opt:IsNone()) then
			return true
		end
	end
	return false
end


Option.None = Option._new()


return Option]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX987E41E1284E4664A601549D76F5C31C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Promise</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- hack to use roblox-ts's copy of roblox-lua-promise

local TS = _G[script.Parent.Parent.Parent]
local Promise = TS.Promise

-- Knit modifies roblox-lua-promise to add PascalCase API
Promise.Defer = Promise.defer
Promise.Async = Promise.defer
Promise.Resolve = Promise.resolve
Promise.Reject = Promise.reject
Promise.Try = Promise.try
Promise.All = Promise.all
Promise.Some = Promise.some
Promise.Any = Promise.any
Promise.AllSettled = Promise.allSettled
Promise.Race = Promise.race
Promise.Each = Promise.each
Promise.Is = Promise.is
Promise.Promisify = Promise.promisify
Promise.Delay = Promise.delay
Promise.prototype.Timeout = Promise.prototype.timeout
Promise.prototype.GetStatus = Promise.prototype.getStatus
Promise.prototype.AndThen = Promise.prototype.andThen
Promise.prototype.Then = Promise.prototype.andThen
Promise.prototype.Catch = Promise.prototype.catch
Promise.prototype.Tap = Promise.prototype.tap
Promise.prototype.AndThenCall = Promise.prototype.andThenCall
Promise.prototype.ThenCall = Promise.prototype.andThenCall
Promise.prototype.AndThenReturn = Promise.prototype.andThenReturn
Promise.prototype.ThenReturn = Promise.prototype.andThenReturn
Promise.prototype.Cancel = Promise.prototype.cancel
Promise.prototype.Finally = Promise.prototype.finally
Promise.prototype.FinallyCall = Promise.prototype.finallyCall
Promise.prototype.FinallyReturn = Promise.prototype.finallyReturn
Promise.prototype.Done = Promise.prototype.done
Promise.prototype.DoneCall = Promise.prototype.doneCall
Promise.prototype.DoneReturn = Promise.prototype.doneReturn
Promise.prototype.AwaitStatus = Promise.prototype.awaitStatus
Promise.prototype.Await = Promise.prototype.await
Promise.prototype.Expect = Promise.prototype.expect
Promise.prototype.AwaitValue = Promise.prototype.expect
Promise.prototype.Now = Promise.prototype.now
Promise.Retry = Promise.retry
Promise.FromEvent = Promise.fromEvent

return Promise
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXEC3BEEE871DE4DA292FB2C882624CC1D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">Remote</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXD39DDE2FCB0B4A98B5285EE99B7DC9E3">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">ClientRemoteProperty</string>
											<string name="ScriptGuid"></string>
											<ProtectedString name="Source"><![CDATA[-- ClientRemoteProperty
-- Stephen Leitnick
-- January 07, 2021

--[[

	remoteProperty = ClientRemoteProperty.new(valueObject: Instance)

	remoteProperty:Get(): any
	remoteProperty:Destroy(): void

	remoteProperty.Changed(newValue: any): Connection

--]]


local IS_SERVER = game:GetService("RunService"):IsServer()
local Signal = require(script.Parent.Parent.Signal)

local ClientRemoteProperty = {}
ClientRemoteProperty.__index = ClientRemoteProperty


function ClientRemoteProperty.new(object)

	assert(not IS_SERVER, "ClientRemoteProperty can only be created on the client")

	local self = setmetatable({
		_object = object;
		_value = nil;
		_isTable = object:IsA("RemoteEvent");
	}, ClientRemoteProperty)

	local function SetValue(v)
		self._value = v
	end

	if (self._isTable) then
		self.Changed = Signal.new()
		self._change = object.OnClientEvent:Connect(function(tbl)
			SetValue(tbl)
			self.Changed:Fire(tbl)
		end)
		SetValue(object.TableRequest:InvokeServer())
	else
		SetValue(object.Value)
		self.Changed = object.Changed
		self._change = object.Changed:Connect(SetValue)
	end

	return self

end


function ClientRemoteProperty:Get()
	return self._value
end


function ClientRemoteProperty:Destroy()
	self._change:Disconnect()
	if (self._isTable) then
		self.Changed:Destroy()
	end
end


return ClientRemoteProperty]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX5DCFBA5C3ED8456099A90844D905E63C">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">ClientRemoteSignal</string>
											<string name="ScriptGuid"></string>
											<ProtectedString name="Source"><![CDATA[-- ClientRemoteSignal
-- Stephen Leitnick
-- January 07, 2021

--[[

	remoteSignal = ClientRemoteSignal.new(remoteEvent: RemoteEvent)

	remoteSignal:Connect(handler: (...args: any)): Connection
	remoteSignal:Fire(...args: any): void
	remoteSignal:Wait(): (...any)
	remoteSignal:Destroy(): void

--]]


local IS_SERVER = game:GetService("RunService"):IsServer()

local Ser = require(script.Parent.Parent.Ser)

--------------------------------------------------------------
-- Connection

local Connection = {}
Connection.__index = Connection

function Connection.new(event, connection)
	local self = setmetatable({
		_conn = connection;
		_event = event;
		Connected = true;
	}, Connection)
	return self
end

function Connection:IsConnected()
	if (self._conn) then
		return self._conn.Connected
	end
	return false
end

function Connection:Disconnect()
	if (self._conn) then
		self._conn:Disconnect()
		self._conn = nil
	end
	if (not self._event) then return end
	self.Connected = false
	local connections = self._event._connections
	for i,c in ipairs(connections) do
		if (c == self) then
			connections[i] = connections[#connections]
			connections[#connections] = nil
			break
		end
	end
	self._event = nil
end

Connection.Destroy = Connection.Disconnect

-- End Connection
--------------------------------------------------------------
-- ClientRemoteSignal

local ClientRemoteSignal = {}
ClientRemoteSignal.__index = ClientRemoteSignal


function ClientRemoteSignal.Is(object)
	return (type(object) == "table" and getmetatable(object) == ClientRemoteSignal)
end


function ClientRemoteSignal.new(remoteEvent)
	assert(not IS_SERVER, "ClientRemoteSignal can only be created on the client")
	assert(typeof(remoteEvent) == "Instance", "Argument #1 (RemoteEvent) expected Instance; got " .. typeof(remoteEvent))
	assert(remoteEvent:IsA("RemoteEvent"), "Argument #1 (RemoteEvent) expected RemoteEvent; got" .. remoteEvent.ClassName)
	local self = setmetatable({
		_remote = remoteEvent;
		_connections = {};
	}, ClientRemoteSignal)
	return self
end


function ClientRemoteSignal:Fire(...)
	self._remote:FireServer(Ser.SerializeArgsAndUnpack(...))
end


function ClientRemoteSignal:Wait()
	return Ser.DeserializeArgsAndUnpack(self._remote.OnClientEvent:Wait())
end


function ClientRemoteSignal:Connect(handler)
	local connection = Connection.new(self, self._remote.OnClientEvent:Connect(function(...)
		handler(Ser.DeserializeArgsAndUnpack(...))
	end))
	table.insert(self._connections, connection)
	return connection
end


function ClientRemoteSignal:Destroy()
	for _,c in ipairs(self._connections) do
		if (c._conn) then
			c._conn:Disconnect()
		end
	end
	self._connections = nil
	self._remote = nil
end


return ClientRemoteSignal]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX690C09784E2F468CBDF6BAB340C02B62">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">RemoteProperty</string>
											<string name="ScriptGuid"></string>
											<ProtectedString name="Source"><![CDATA[-- RemoteProperty
-- Stephen Leitnick
-- January 07, 2021

--[[

	remoteProperty = RemoteProperty.new(value: any [, overrideClass: string])

	remoteProperty:Get(): any
	remoteProperty:Set(value: any): void
	remoteProperty:Replicate(): void   [Only for table values]
	remoteProperty:Destroy(): void

	remoteProperty.Changed(newValue: any): Connection

--]]


local Signal = require(script.Parent.Parent.Signal)

local IS_SERVER = game:GetService("RunService"):IsServer()

local typeClassMap = {
	boolean = "BoolValue";
	string = "StringValue";
	table = "RemoteEvent";
	CFrame = "CFrameValue";
	Color3 = "Color3Value";
	BrickColor = "BrickColorValue";
	number = "NumberValue";
	Instance = "ObjectValue";
	Ray = "RayValue";
	Vector3 = "Vector3Value";
	["nil"] = "ObjectValue";
}


local RemoteProperty = {}
RemoteProperty.__index = RemoteProperty


function RemoteProperty.Is(object)
	return (type(object) == "table" and getmetatable(object) == RemoteProperty)
end


function RemoteProperty.new(value, overrideClass)

	assert(IS_SERVER, "RemoteProperty can only be created on the server")

	if (overrideClass ~= nil) then
		assert(type(overrideClass) == "string", "OverrideClass must be a string; got " .. type(overrideClass))
		assert(overrideClass:match("Value$"), "OverrideClass must be of super type ValueBase (e.g. IntValue); got " .. overrideClass)
	end

	local t = typeof(value)
	local class = overrideClass or typeClassMap[t]
	assert(class, "RemoteProperty does not support type \"" .. t .. "\"")

	local self = setmetatable({
		_value = value;
		_type = t;
		_isTable = (t == "table");
		_object = Instance.new(class);
	}, RemoteProperty)

	if (self._isTable) then
		local req = Instance.new("RemoteFunction")
		req.Name = "TableRequest"
		req.Parent = self._object
		function req.OnServerInvoke(_player)
			return self._value
		end
		self.Changed = Signal.new()
	else
		self.Changed = self._object.Changed
	end

	self:Set(value)

	return self

end


function RemoteProperty:Replicate()
	if (self._isTable) then
		self:Set(self._value)
	end
end


function RemoteProperty:Set(value)
	if (self._isTable) then
		self._object:FireAllClients(value)
		self.Changed:Fire(value)
	else
		self._object.Value = value
	end
	self._value = value
end


function RemoteProperty:Get()
	return self._value
end


function RemoteProperty:Destroy()
	self._object:Destroy()
end


return RemoteProperty]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX64572F9F3DB4475D836EB70EAB179ED5">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">RemoteSignal</string>
											<string name="ScriptGuid"></string>
											<ProtectedString name="Source"><![CDATA[-- RemoteSignal
-- Stephen Leitnick
-- January 07, 2021

--[[

	remoteSignal = RemoteSignal.new()

	remoteSignal:Connect(handler: (player: Player, ...args: any) -> void): RBXScriptConnection
	remoteSignal:Fire(player: Player, ...args: any): void
	remoteSignal:FireAll(...args: any): void
	remoteSignal:FireExcept(player: Player, ...args: any): void
	remoteSignal:Wait(): (...any)
	remoteSignal:Destroy(): void

--]]


local IS_SERVER = game:GetService("RunService"):IsServer()

local Players = game:GetService("Players")
local Ser = require(script.Parent.Parent.Ser)

local RemoteSignal = {}
RemoteSignal.__index = RemoteSignal


function RemoteSignal.Is(object)
	return (type(object) == "table" and getmetatable(object) == RemoteSignal)
end


function RemoteSignal.new()
	assert(IS_SERVER, "RemoteSignal can only be created on the server")
	local self = setmetatable({
		_remote = Instance.new("RemoteEvent");
	}, RemoteSignal)
	return self
end


function RemoteSignal:Fire(player, ...)
	self._remote:FireClient(player, Ser.SerializeArgsAndUnpack(...))
end


function RemoteSignal:FireAll(...)
	self._remote:FireAllClients(Ser.SerializeArgsAndUnpack(...))
end


function RemoteSignal:FireExcept(player, ...)
	local args = Ser.SerializeArgs(...)
	for _,plr in ipairs(Players:GetPlayers()) do
		if (plr ~= player) then
			self._remote:FireClient(plr, Ser.UnpackArgs(args))
		end
	end
end


function RemoteSignal:Wait()
	return self._remote.OnServerEvent:Wait()
end


function RemoteSignal:Connect(handler)
	return self._remote.OnServerEvent:Connect(function(player, ...)
		handler(player, Ser.DeserializeArgsAndUnpack(...))
	end)
end


function RemoteSignal:Destroy()
	self._remote:Destroy()
	self._remote = nil
end


return RemoteSignal]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBX48F516B49A4D468697A9B00F3F40EFCE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Ser</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Ser
-- Stephen Leitnick
-- August 28, 2020

--[[

	Ser is a serialization/deserialization utility module that is used
	by Knit to automatically serialize/deserialize values passing
	through remote functions and remote events.


	Ser.Classes = {
		[ClassName] = {
			Serialize = (value) -> serializedValue
			Deserialize = (value) => deserializedValue
		}
	}

	Ser.SerializeArgs(...)            -> table
	Ser.SerializeArgsAndUnpack(...)   -> Tuple
	Ser.DeserializeArgs(...)          -> table
	Ser.DeserializeArgsAndUnpack(...) -> Tuple
	Ser.Serialize(value: any)         -> any
	Ser.Deserialize(value: any)       -> any
	Ser.UnpackArgs(args: table)       -> Tuple

--]]


local Option = require(script.Parent.Option)

local Ser = {}

Ser.Classes = {
	Option = {
		Serialize = function(opt) return opt:Serialize() end;
		Deserialize = Option.Deserialize;
	};
}


function Ser.SerializeArgs(...)
	local args = table.pack(...)
	for i,arg in ipairs(args) do
		if (type(arg) == "table") then
			local ser = Ser.Classes[arg.ClassName]
			if (ser) then
				args[i] = ser.Serialize(arg)
			end
		end
	end
	return args
end


function Ser.SerializeArgsAndUnpack(...)
	local args = Ser.SerializeArgs(...)
	return table.unpack(args, 1, args.n)
end


function Ser.DeserializeArgs(...)
	local args = table.pack(...)
	for i,arg in ipairs(args) do
		if (type(arg) == "table") then
			local ser = Ser.Classes[arg.ClassName]
			if (ser) then
				args[i] = ser.Deserialize(arg)
			end
		end
	end
	return args
end


function Ser.DeserializeArgsAndUnpack(...)
	local args = Ser.DeserializeArgs(...)
	return table.unpack(args, 1, args.n)
end


function Ser.Serialize(value)
	if (type(value) == "table") then
		local ser = Ser.Classes[value.ClassName]
		if (ser) then
			value = ser.Serialize(value)
		end
	end
	return value
end


function Ser.Deserialize(value)
	if (type(value) == "table") then
		local ser = Ser.Classes[value.ClassName]
		if (ser) then
			value = ser.Deserialize(value)
		end
	end
	return value
end


function Ser.UnpackArgs(args)
	return table.unpack(args, 1, args.n)
end


return Ser]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB216D5DF76844106AF398273116EA77E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Signal</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Signal
-- Stephen Leitnick
-- Based off of Anaminus' Signal class: https://gist.github.com/Anaminus/afd813efc819bad8e560caea28942010

--[[

	signal = Signal.new([maid: Maid])
	signal = Signal.Proxy(rbxSignal: RBXScriptSignal [, maid: Maid])

	Signal.Is(object: any): boolean

	signal:Fire(...)
	signal:Wait()
	signal:WaitPromise()
	signal:Destroy()
	signal:DisconnectAll()

	connection = signal:Connect((...) -> void)

	connection:Disconnect()
	connection:IsConnected()

--]]

local Promise = require(script.Parent.Promise)

local Connection = {}
Connection.__index = Connection

function Connection.new(signal, connection)
	local self = setmetatable({
		_signal = signal;
		_conn = connection;
		Connected = true;
	}, Connection)
	return self
end

function Connection:Disconnect()
	if (self._conn) then
		self._conn:Disconnect()
		self._conn = nil
	end
	if (not self._signal) then return end
	self.Connected = false
	local connections = self._signal._connections
	local connectionIndex = table.find(connections, self)
	if (connectionIndex) then
		local n = #connections
		connections[connectionIndex] = connections[n]
		connections[n] = nil
	end
	self._signal = nil
end

function Connection:IsConnected()
	if (self._conn) then
		return self._conn.Connected
	end
	return false
end

Connection.Destroy = Connection.Disconnect

--------------------------------------------

local Signal = {}
Signal.__index = Signal


function Signal.new(maid)
	local self = setmetatable({
		_bindable = Instance.new("BindableEvent");
		_connections = {};
		_args = {};
		_threads = 0;
		_id = 0;
	}, Signal)
	if (maid) then
		maid:GiveTask(self)
	end
	return self
end


function Signal.Proxy(rbxScriptSignal, maid)
	assert(typeof(rbxScriptSignal) == "RBXScriptSignal", "Argument #1 must be of type RBXScriptSignal")
	local signal = Signal.new(maid)
	signal:_setProxy(rbxScriptSignal)
	return signal
end


function Signal.Is(obj)
	return (type(obj) == "table" and getmetatable(obj) == Signal)
end


function Signal:_setProxy(rbxScriptSignal)
	assert(typeof(rbxScriptSignal) == "RBXScriptSignal", "Argument #1 must be of type RBXScriptSignal")
	self:_clearProxy()
	self._proxyHandle = rbxScriptSignal:Connect(function(...)
		self:Fire(...)
	end)
end


function Signal:_clearProxy()
	if (self._proxyHandle) then
		self._proxyHandle:Disconnect()
		self._proxyHandle = nil
	end
end


function Signal:Fire(...)
	local totalListeners = (#self._connections + self._threads)
	if (totalListeners == 0) then return end
	local id = self._id
	self._id += 1
	self._args[id] = {totalListeners, {n = select("#", ...), ...}}
	self._threads = 0
	self._bindable:Fire(id)
end


function Signal:Wait()
	self._threads += 1
	local id = self._bindable.Event:Wait()
	local args = self._args[id]
	args[1] -= 1
	if (args[1] <= 0) then
		self._args[id] = nil
	end
	return table.unpack(args[2], 1, args[2].n)
end


function Signal:WaitPromise()
	return Promise.new(function(resolve)
		resolve(self:Wait())
	end)
end


function Signal:Connect(handler)
	local connection = Connection.new(self, self._bindable.Event:Connect(function(id)
		local args = self._args[id]
		args[1] -= 1
		if (args[1] <= 0) then
			self._args[id] = nil
		end
		handler(table.unpack(args[2], 1, args[2].n))
	end))
	table.insert(self._connections, connection)
	return connection
end


function Signal:DisconnectAll()
	for _,c in ipairs(self._connections) do
		if (c._conn) then
			c._conn:Disconnect()
		end
	end
	self._connections = {}
	self._args = {}
end


function Signal:Destroy()
	self:DisconnectAll()
	self:_clearProxy()
	self._bindable:Destroy()
end


return Signal]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3D2552EFB0DE46F29F96CD70E62B8CB4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Streamable</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Streamable
-- Stephen Leitnick
-- March 03, 2021

--[[

	streamable = Streamable.new(parent: Instance, childName: string)

	streamable:Observe(handler: (child: Instance, maid: Maid) -> void): Connection
	streamable:Destroy()

--]]


local Maid = require(script.Parent.Maid)
local Signal = require(script.Parent.Signal)
local Thread = require(script.Parent.Thread)


local Streamable = {}
Streamable.__index = Streamable


function Streamable.new(parent, childName)

	local self = setmetatable({}, Streamable)

	self._maid = Maid.new()
	self._shown = Signal.new(self._maid)
	self._shownMaid = Maid.new()
	self._maid:GiveTask(self._shownMaid)

	self.Instance = parent:FindFirstChild(childName)

	local function OnInstanceSet()
		local instance = self.Instance
		self._shown:Fire(instance, self._shownMaid)
		self._shownMaid:GiveTask(instance:GetPropertyChangedSignal("Parent"):Connect(function()
			if (not instance.Parent) then
				self._shownMaid:DoCleaning()
			end
		end))
		self._shownMaid:GiveTask(function()
			if (self.Instance == instance) then
				self.Instance = nil
			end
		end)
	end

	local function OnChildAdded(child)
		if (child.Name == childName and not self.Instance) then
			self.Instance = child
			OnInstanceSet()
		end
	end

	self._maid:GiveTask(parent.ChildAdded:Connect(OnChildAdded))
	if (self.Instance) then
		OnInstanceSet()
	end

	return self

end


function Streamable:Observe(handler)
	if (self.Instance) then
		Thread.SpawnNow(handler, self.Instance, self._shownMaid)
	end
	return self._shown:Connect(handler)
end


function Streamable:Destroy()
	self._maid:Destroy()
end


return Streamable]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9CB69594C9184CF0B73FE8A4CFE298BE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">StreamableUtil</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- StreamableUtil
-- Stephen Leitnick
-- March 03, 2021

--[[

	StreamableUtil.Compound(observers: {Observer}, handler: ({[child: string]: Instance}, maid: Maid) -> void): Maid

	Example:

		local streamable1 = Streamable.new(someModel, "SomeChild")
		local streamable2 = Streamable.new(anotherModel, "AnotherChild")

		StreamableUtil.Compound({S1 = streamable1, S2 = streamable2}, function(streamables, maid)
			local someChild = streamables.S1.Instance
			local anotherChild = streamables.S2.Instance
			maid:GiveTask(function()
				-- Cleanup
			end)
		end)

--]]


local Maid = require(script.Parent.Maid)


local StreamableUtil = {}


function StreamableUtil.Compound(streamables, handler)
	local compoundMaid = Maid.new()
	local observeAllMaid = Maid.new()
	local allAvailable = false
	local function Check()
		if (allAvailable) then return end
		for _,streamable in pairs(streamables) do
			if (not streamable.Instance) then
				return
			end
		end
		allAvailable = true
		handler(streamables, observeAllMaid)
	end
	local function Cleanup()
		if (not allAvailable) then return end
		allAvailable = false
		observeAllMaid:DoCleaning()
	end
	for _,streamable in pairs(streamables) do
		compoundMaid:GiveTask(streamable:Observe(function(_child, maid)
			Check()
			maid:GiveTask(function()
				Cleanup()
			end)
		end))
	end
	compoundMaid:GiveTask(Cleanup)
	return compoundMaid
end


return StreamableUtil]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXAA261C6266EB49DC9E4D521BDA9FCA48">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Symbol</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Symbol
-- Stephen Leitnick
-- December 27, 2020

--[[

	symbol = Symbol.new(id: string [, scope: Symbol])

	Symbol.Is(obj: any): boolean
	Symbol.IsInScope(obj: any, scope: Symbol): boolean

--]]


local CLASSNAME = "Symbol"

local Symbol = {}
Symbol.__index = Symbol


function Symbol.new(id, scope)
	assert(id ~= nil, "Symbol ID cannot be nil")
	if (scope ~= nil) then
		assert(Symbol.Is(scope), "Scope must be a Symbol or nil")
	end
	local self = setmetatable({
		ClassName = CLASSNAME;
		_id = id;
		_scope = scope;
	}, Symbol)
	return self
end


function Symbol.Is(obj)
	return (type(obj) == "table" and getmetatable(obj) == Symbol)
end


function Symbol.IsInScope(obj, scope)
	return (Symbol.Is(obj) and obj._scope == scope)
end


function Symbol:__tostring()
	return ("Symbol<%s>"):format(self._id)
end


return Symbol]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX628AC6FEE77C4C83AD57BE5DC73B9DFD">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">TableUtil</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Table Util
-- Stephen Leitnick
-- September 13, 2017

--[[

	TableUtil.Copy(Table tbl)
	TableUtil.CopyShallow(Table tbl)
	TableUtil.Sync(Table tbl, Table templateTbl)
	TableUtil.Print(Table tbl, String label, Boolean deepPrint)
	TableUtil.FastRemove(Table tbl, Number index)
	TableUtil.FastRemoveFirstValue(Table tbl, Variant value)
	TableUtil.Map(Table tbl, Function callback)
	TableUtil.Filter(Table tbl, Function callback)
	TableUtil.Reduce(Table tbl, Function callback [, Number initialValue])
	TableUtil.Assign(Table target, ...Table sources)
	TableUtil.Extend(Table target, Table extension)
	TableUtil.IndexOf(Table tbl, Variant item)
	TableUtil.Reverse(Table tbl)
	TableUtil.Shuffle(Table tbl)
	TableUtil.IsEmpty(Table tbl)
	TableUtil.EncodeJSON(Table tbl)
	TableUtil.DecodeJSON(String json)

	EXAMPLES:

		Copy:

			Performs a deep copy of the given table. In other words,
			all nested tables will also get copied.

			local tbl = {"a", "b", "c"}
			local tblCopy = TableUtil.Copy(tbl)


		CopyShallow:

			Performs a shallow copy of the given table. In other words,
			all nested tables will not be copied, but only moved by
			reference. Thus, a nested table in both the original and
			the copy will be the same.

			local tbl = {"a", "b", "c"}
			local tblCopy = TableUtil.CopyShallow(tbl)


		Sync:

			Synchronizes a table to a template table. If the table does not have an
			item that exists within the template, it gets added. If the table has
			something that the template does not have, it gets removed.

			local tbl1 = {kills = 0; deaths = 0; points = 0}
			local tbl2 = {points = 0}
			TableUtil.Sync(tbl2, tbl1)  -- In words: "Synchronize table2 to table1"
			print(tbl2.deaths)


		Print:

			Prints out the table to the output in an easy-to-read format. Good for
			debugging tables. If deep printing, avoid cyclical references.

			local tbl = {a = 32; b = 64; c = 128; d = {x = 0; y = 1; z = 2}}
			TableUtil.Print(tbl, "My Table", true)


		FastRemove:

			Removes an item from an array at a given index. Only use this if you do
			NOT care about the order of your array. This works by simply popping the
			last item in the array and overwriting the given index with the last
			item. This is O(1), compared to table.remove's O(n) speed.

			local tbl = {"hello", "there", "this", "is", "a", "test"}
			TableUtil.FastRemove(tbl, 2)   -- Remove "there" in the array
			print(table.concat(tbl, " "))  -- > hello test is a


		FastRemoveFirstValue:

			Calls FastRemove on the first index that holds the given value.

			local tbl = {"abc", "hello", "hi", "goodbye", "hello", "hey"}
			local removed, atIndex = TableUtil.FastRemoveFirstValue(tbl, "hello")
			if (removed) then
				print("Removed at index " .. atIndex)
				print(table.concat(tbl, " "))  -- > abc hi goodbye hello hey
			else
				print("Did not find value")
			end


		Map:

			This allows you to construct a new table by calling the given function
			on each item in the table.

			local peopleData = {
				{firstName = "Bob"; lastName = "Smith"};
				{firstName = "John"; lastName = "Doe"};
				{firstName = "Jane"; lastName = "Doe"};
			}

			local people = TableUtil.Map(peopleData, function(item)
				return {Name = item.firstName .. " " .. item.lastName}
			end)

			-- 'people' is now an array that looks like: { {Name = "Bob Smith"}; ... }


		Filter:

			This allows you to create a table based on the given table and a filter
			function. If the function returns 'true', the item remains in the new
			table; if the function returns 'false', the item is discluded from the
			new table.

			local people = {
				{Name = "Bob Smith"; Age = 42};
				{Name = "John Doe"; Age = 34};
				{Name = "Jane Doe"; Age = 37};
			}

			local peopleUnderForty = TableUtil.Filter(people, function(item)
				return item.Age < 40
			end)


		Reduce:

			This allows you to reduce an array to a single value. Useful for quickly
			summing up an array.

			local tbl = {40, 32, 9, 5, 44}
			local tblSum = TableUtil.Reduce(tbl, function(accumulator, value)
				return accumulator + value
			end)
			print(tblSum)  -- > 130


		Assign:

			This allows you to assign values from multiple tables into one. The
			Assign function is very similar to JavaScript's Object.Assign() and
			is useful for things such as composition-designed systems.

			local function Driver()
				return {
					Drive = function(self) self.Speed = 10 end;
				}
			end

			local function Teleporter()
				return {
					Teleport = function(self, pos) self.Position = pos end;
				}
			end

			local function CreateCar()
				local state = {
					Speed = 0;
					Position = Vector3.new();
				}
				-- Assign the Driver and Teleporter components to the car:
				return TableUtil.Assign({}, Driver(), Teleporter())
			end

			local car = CreateCar()
			car:Drive()
			car:Teleport(Vector3.new(0, 10, 0))


		Extend:

			Extends on all elements from one table to another.

			local t1 = {"a", "b", "c"}
			local t2 = {"d", "e", "f"}

			TableUtil.Extend(t1, t2)
			print(t1)  --> { "a", "b", "c", "d", "e", "f" }


		IndexOf:

			Returns the index of the given item in the table. If not found, this
			will return nil.

			This is the same as table.find, which Roblox added after this method
			was written. To keep backwards compatibility, this method will continue
			to exist, but will point directly to table.find.

			local tbl = {"Hello", 32, true, "abc"}
			local abcIndex = TableUtil.IndexOf(tbl, "abc")     -- > 4
			local helloIndex = TableUtil.IndexOf(tbl, "Hello") -- > 1
			local numberIndex = TableUtil.IndexOf(tbl, 64)     -- > nil


		Reverse:

			Creates a reversed version of the array. Note: This is a shallow
			copy, so existing references will remain within the new table.

			local tbl = {2, 4, 6, 8}
			local rblReversed = TableUtil.Reverse(tbl)  -- > {8, 6, 4, 2}


		Shuffle:

			Shuffles (i.e. randomizes) an array. This uses the Fisher-Yates algorithm.

			local tbl = {1, 2, 3, 4, 5, 6, 7, 8, 9}
			TableUtil.Shuffle(tbl)
			print(table.concat(tbl, ", "))  -- e.g. > 3, 6, 9, 2, 8, 4, 1, 7, 5

--]]



local TableUtil = {}

local http = game:GetService("HttpService")

local IndexOf = table.find


local function CopyTable(t)
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = CopyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end


local function CopyTableShallow(t)
	local tCopy = table.create(#t)
	for k,v in pairs(t) do tCopy[k] = v end
	return tCopy
end


local function Sync(tbl, templateTbl)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(type(templateTbl) == "table", "Second argument must be a table")

	-- If 'tbl' has something 'templateTbl' doesn't, then remove it from 'tbl'
	-- If 'tbl' has something of a different type than 'templateTbl', copy from 'templateTbl'
	-- If 'templateTbl' has something 'tbl' doesn't, then add it to 'tbl'
	for k,v in pairs(tbl) do

		local vTemplate = templateTbl[k]

		-- Remove keys not within template:
		if (vTemplate == nil) then
			tbl[k] = nil

		-- Synchronize data types:
		elseif (type(v) ~= type(vTemplate)) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end

		-- Synchronize sub-tables:
		elseif (type(v) == "table") then
			Sync(v, vTemplate)
		end

	end

	-- Add any missing keys:
	for k,vTemplate in pairs(templateTbl) do

		local v = tbl[k]

		if (v == nil) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end
		end

	end

end


local function FastRemove(t, i)
	local n = #t
	t[i] = t[n]
	t[n] = nil
end


local function Map(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	for k,v in pairs(t) do
		newT[k] = f(v, k, t)
	end
	return newT
end


local function Filter(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	if (#t > 0) then
		local n = 0
		for i,v in ipairs(t) do
			if f(v, i, t) then
				newT[i] = v
			end
		end
	else
		for k,v in pairs(t) do
			if f(v, k, t) then
				newT[k] = v
			end
		end
	end
	return newT
end


local function Reduce(t, f, init)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	assert(init == nil or type(init) == "number", "Third argument must be a number or nil")
	local result = (init or 0)
	for k,v in pairs(t) do
		result = f(result, v, k, t)
	end
	return result
end


-- tableUtil.Assign(Table target, ...Table sources)
local function Assign(target, ...)
	for _,src in ipairs({...}) do
		for k,v in pairs(src) do
			target[k] = v
		end
	end
	return target
end


local function Extend(tbl, extension)
	for k,v in pairs(extension) do
		tbl[k] = v
	end
end


local function Print(tbl, label, deepPrint)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(label == nil or type(label) == "string", "Second argument must be a string or nil")

	label = (label or "TABLE")

	local strTbl = {}
	local indent = " - "

	-- Insert(string, indentLevel)
	local function Insert(s, l)
		strTbl[#strTbl + 1] = (indent:rep(l) .. s .. "\n")
	end

	local function AlphaKeySort(a, b)
		return (tostring(a.k) < tostring(b.k))
	end

	local function PrintTable(t, lvl, lbl)
		Insert(lbl .. ":", lvl - 1)
		local nonTbls = {}
		local tbls = {}
		local keySpaces = 0
		for k,v in pairs(t) do
			if (type(v) == "table") then
				table.insert(tbls, {k = k, v = v})
			else
				table.insert(nonTbls, {k = k, v = "[" .. typeof(v) .. "] " .. tostring(v)})
			end
			local spaces = #tostring(k) + 1
			if (spaces > keySpaces) then
				keySpaces = spaces
			end
		end
		table.sort(nonTbls, AlphaKeySort)
		table.sort(tbls, AlphaKeySort)
		for _,v in ipairs(nonTbls) do
			Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. v.v, lvl)
		end
		if (deepPrint) then
			for _,v in ipairs(tbls) do
				PrintTable(v.v, lvl + 1, tostring(v.k) .. (" "):rep(keySpaces - #tostring(v.k)) .. " [Table]")
			end
		else
			for _,v in ipairs(tbls) do
				Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. "[Table]", lvl)
			end
		end
	end

	PrintTable(tbl, 1, label)

	print(table.concat(strTbl, ""))

end


local function Reverse(tbl)
	local n = #tbl
	local tblRev = table.create(n)
	for i = 1,n do
		tblRev[i] = tbl[n - i + 1]
	end
	return tblRev
end


local function Shuffle(tbl)
	assert(type(tbl) == "table", "First argument must be a table")
	local rng = Random.new()
	for i = #tbl, 2, -1 do
		local j = rng:NextInteger(1, i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end


local function IsEmpty(tbl)
	return (next(tbl) == nil)
end


local function EncodeJSON(tbl)
	return http:JSONEncode(tbl)
end


local function DecodeJSON(str)
	return http:JSONDecode(str)
end


local function FastRemoveFirstValue(t, v)
	local index = IndexOf(t, v)
	if (index) then
		FastRemove(t, index)
		return true, index
	end
	return false, nil
end


TableUtil.Copy = CopyTable
TableUtil.CopyShallow = CopyTableShallow
TableUtil.Sync = Sync
TableUtil.FastRemove = FastRemove
TableUtil.FastRemoveFirstValue = FastRemoveFirstValue
TableUtil.Print = Print
TableUtil.Map = Map
TableUtil.Filter = Filter
TableUtil.Reduce = Reduce
TableUtil.Assign = Assign
TableUtil.Extend = Extend
TableUtil.IndexOf = IndexOf
TableUtil.Reverse = Reverse
TableUtil.Shuffle = Shuffle
TableUtil.IsEmpty = IsEmpty
TableUtil.EncodeJSON = EncodeJSON
TableUtil.DecodeJSON = DecodeJSON


return TableUtil]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1390FBEC8A6446278B76893ED0618B8C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Thread</string>
										<string name="ScriptGuid"></string>
										<ProtectedString name="Source"><![CDATA[-- Thread
-- Stephen Leitnick
-- January 5, 2020

--[[

	Thread.DelayRepeatBehavior { Delayed, Immediate }

	Thread.SpawnNow(func: (...any) -> void, [...any])
	Thread.Spawn(func: (...any) -> void, [...any])
	Thread.Delay(waitTime: number, func: (...any) -> void [, ...any])
	Thread.DelayRepeat(waitTime: number, func: (...any) -> void [, behavior: DelayRepeatBehavior, ...any])

	SpawnNow(func: (...any) -> void [, ...args])

		>	Uses a BindableEvent to spawn a new thread
			immediately. More performance-intensive than
			using Thread.Spawn, but will guarantee a
			thread is started immediately.

		>	Use this only if the thread must be executed
			right away, otherwise use Thread.Spawn for
			the sake of performance.

	Spawn(func: (...any) -> void [, ...args])

		>	Uses RunService's Heartbeat to spawn a new
			thread on the next heartbeat and then
			call the given function.

		>	Better performance than Thread.SpawnNow, but
			will have a short delay of 1 frame before
			calling the function.

	Delay(waitTime: number, func: (...any) -> void [, ...args])

		>	The same as Thread.Spawn, but waits to call
			the function until the in-game time as elapsed
			by 'waitTime' amount.

		>	Returns the connection to the Heartbeat event,
			so the delay can be cancelled by disconnecting
			the returned connection.

	DelayRepeat(intervalTime: number, func: (...any) -> void [, behavior: DelayRepeatBehavior, ...args])

		>	The same as Thread.Delay, except it repeats
			indefinitely.

		>	Returns the Heartbeat connection, thus the
			repeated delay can be stopped by disconnecting
			the returned connection.

		>	Properly bound to the time interval, thus will
			not experience drift.

		>	If DelayRepeatBehavior is Delayed (default behavior),
			then the function will first fire after an initial
			delay. If set to Immediate, the function will fire
			immediately before the first delay.


	Examples:

		Thread.Spawn(function()
			print("Hello from Spawn")
		end)

		Thread.Delay(1, function()
			print("Hello from Delay")
		end)

		Thread.SpawnNow(function()
			print("Hello from SpawnNow")
		end)

		local delayConnection = Thread.Delay(5, function()
			print("Hello?")
		end)
		delayConnection:Disconnect()

		local repeatConnection = Thread.DelayRepeat(1, function()
			print("Hello again", time())
		end, Thread.DelayRepeatBehavior.Delayed)
		wait(5)
		repeatConnection:Disconnect()


	Why:

		The built-in 'spawn' and 'delay' functions have the
		potential to be throttled unknowingly. This can cause
		all sorts of problems. Developers need to be certain
		when their code is going to run. This small library
		helps give the same functionality as 'spawn' and 'delay'
		but with the expected behavior.

	Why not coroutines:

		Coroutines are powerful, but can be extremely difficult
		to debug due to the ways that coroutines obscure the
		stack trace.

	Credit:

		evaera & buildthomas: https://devforum.roblox.com/t/coroutines-v-s-spawn-which-one-should-i-use/368966
		Quenty: FastSpawn (AKA SpawnNow) method using BindableEvent

--]]


local EnumList = require(script.Parent.EnumList)

local Thread = {}

local heartbeat = game:GetService("RunService").Heartbeat

Thread.DelayRepeatBehavior = EnumList.new("DelayRepeatBehavior", {
	"Delayed";
	"Immediate";
})


function Thread.SpawnNow(func, ...)
	--[[
		This method was originally written by Quenty and is slightly
		modified for this module. The original source can be found in
		the link below, as well as the MIT license:
			https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Utility/fastSpawn.lua
			https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md
	--]]
	local args = table.pack(...)
	local bindable = Instance.new("BindableEvent")
	bindable.Event:Connect(function() func(table.unpack(args, 1, args.n)) end)
	bindable:Fire()
	bindable:Destroy()
end


function Thread.Spawn(func, ...)
	local args = table.pack(...)
	local hb
	hb = heartbeat:Connect(function()
		hb:Disconnect()
		func(table.unpack(args, 1, args.n))
	end)
end


function Thread.Delay(waitTime, func, ...)
	local args = table.pack(...)
	local executeTime = (time() + waitTime)
	local hb
	hb = heartbeat:Connect(function()
		if (time() >= executeTime) then
			hb:Disconnect()
			func(table.unpack(args, 1, args.n))
		end
	end)
	return hb
end


function Thread.DelayRepeat(intervalTime, func, behavior, ...)
	local args = table.pack(...)
	if (behavior == nil) then
		behavior = Thread.DelayRepeatBehavior.Delayed
	end
	assert(Thread.DelayRepeatBehavior:Is(behavior), "Invalid behavior")
	local immediate = (behavior == Thread.DelayRepeatBehavior.Immediate)
	local nextExecuteTime = (time() + (immediate and 0 or intervalTime))
	local hb
	hb = heartbeat:Connect(function()
		if (time() >= nextExecuteTime) then
			nextExecuteTime = (time() + intervalTime)
			func(table.unpack(args, 1, args.n))
		end
	end)
	return hb
end


return Thread]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="StringValue" referent="RBX3DB56E1600724A82AA236B40C34DCE48">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Version</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">0.0.15-alpha</string>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX997F348DCB17459F8375D7738A4A85C8">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">TS</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX9425753F78B14C84BC537CB5C790E1BA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Remotes</string>
					<string name="ScriptGuid">{DE37A2CF-8546-4B62-97A4-129C8629A10E}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Net = TS.import(script, TS.getModule(script, "net").out)
local remotes = Net.Definitions.Create({
	ServerCreateHealthPack = Net.Definitions.ServerToClientEvent(),
})
local default = remotes
return {
	default = default,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXD2AA16A3EB40447492DE27B14E192A49">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Spirit</string>
					<string name="ScriptGuid">{51D1A190-5458-428E-8518-29D31F2F1B31}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _0 = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit", "toggle")
local startFreeCamera = _0.startFreeCamera
local stopFreeCamera = _0.stopFreeCamera
local SPIRIT_SETTINGS = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit", "settings").SPIRIT_SETTINGS
local ContextActionService = TS.import(script, TS.getModule(script, "services")).ContextActionService
local Spirit = {}
do
	local _1 = Spirit
	local enabled = false
	local mount, free
	local function bind(key)
		local handleActivationInput = function(action, state, input)
			if state == Enum.UserInputState.Begin then
				if input.KeyCode == key then
					if enabled then
						mount()
					else
						free()
					end
				end
			end
			return Enum.ContextActionResult.Pass
		end
		ContextActionService:BindActionAtPriority("FreeCameraToggle", handleActivationInput, false, SPIRIT_SETTINGS.TOGGLE_INPUT_PRIORITY, key)
	end
	_1.bind = bind
	local function unbind()
		ContextActionService:UnbindAction("FreeCameraToggle")
	end
	_1.unbind = unbind
	local function shape(key, value)
		SPIRIT_SETTINGS[key] = value
	end
	_1.shape = shape
	function free()
		print("start")
		startFreeCamera()
		enabled = true
	end
	_1.free = free
	function mount()
		stopFreeCamera()
		enabled = false
	end
	_1.mount = mount
end
return Spirit
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7A77DF94CD3F4A1580BB2A24DFA5F00B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">input</string>
						<string name="ScriptGuid">{9A004C9B-5C0D-4E70-BF06-E8C60B97C044}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _0 = TS.import(script, TS.getModule(script, "services"))
local ContextActionService = _0.ContextActionService
local UserInputService = _0.UserInputService
local _1 = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit", "settings")
local DEVICE_SETTINGS = _1.DEVICE_SETTINGS
local SPIRIT_SETTINGS = _1.SPIRIT_SETTINGS
local gamePad = {
	ButtonX = 0,
	ButtonY = 0,
	DPadDown = 0,
	ButtonL2 = 0,
	ButtonR2 = 0,
	Thumbstick1 = Vector3.new(),
	Thumbstick2 = Vector3.new(),
}
local keyboard = {
	W = 0,
	A = 0,
	S = 0,
	D = 0,
	E = 0,
	Q = 0,
	U = 0,
	H = 0,
	J = 0,
	K = 0,
	I = 0,
	Y = 0,
	Up = 0,
	Down = 0,
	LeftShift = 0,
	RightShift = 0,
}
local mouse = {
	Delta = Vector2.new(),
	MouseWheel = 0,
}
local function thumbstickCurve(x)
	return math.sign(x) * math.clamp((math.exp((2.0 * (math.abs(x) - 0.15)) / (1 - 0.15)) - 1) / (math.exp(0.15) - 1), 0, 1)
end
local Input = {}
do
	local _2 = Input
	local navSpeed = 1
	local function vel(dt)
		navSpeed = math.clamp(navSpeed + dt * (keyboard.Up - keyboard.Down) * DEVICE_SETTINGS.NAV_ADJ_SPEED, 0.01, 4)
		local _3 = Vector3.new(thumbstickCurve(gamePad.Thumbstick1.X), thumbstickCurve(gamePad.ButtonR2) - thumbstickCurve(gamePad.ButtonL2), thumbstickCurve(-gamePad.Thumbstick1.Y))
		local _4 = DEVICE_SETTINGS.NAV_GAMEPAD_SPEED
		local kGamepad = _3 * _4
		local _5 = Vector3.new(keyboard.D - keyboard.A + keyboard.K - keyboard.H, keyboard.E - keyboard.Q + keyboard.I - keyboard.Y, keyboard.S - keyboard.W + keyboard.J - keyboard.U)
		local _6 = DEVICE_SETTINGS.NAV_KEYBOARD_SPEED
		local kKeyBoard = _5 * _6
		-- eslint-disable-next-line prettier/prettier
		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)
		local _7 = kGamepad
		local _8 = kKeyBoard
		local _9 = navSpeed * (shift and DEVICE_SETTINGS.NAV_SHIFT_MUL or 1)
		return (_7 + _8) * _9
	end
	_2.vel = vel
	local function pan(dt)
		local _3 = Vector2.new(thumbstickCurve(gamePad.Thumbstick2.Y), thumbstickCurve(-gamePad.Thumbstick2.X))
		local _4 = DEVICE_SETTINGS.PAN_GAMEPAD_SPEED
		local kGamePad = _3 * _4
		local _5 = mouse.Delta
		local _6 = DEVICE_SETTINGS.PAN_MOUSE_SPEED
		local kMouse = _5 * _6
		mouse.Delta = Vector2.new()
		local _7 = kGamePad
		local _8 = kMouse
		return _7 + _8
	end
	_2.pan = pan
	local function fov(dt)
		local kGamePad = (gamePad.ButtonX - gamePad.ButtonY) * DEVICE_SETTINGS.FOV_GAMEPAD_SPEED
		local kMouse = mouse.MouseWheel * DEVICE_SETTINGS.FOV_WHEEL_SPEED
		mouse.MouseWheel = 0
		return kGamePad + kMouse
	end
	_2.fov = fov
	local function startCapture()
		local function keypress(action, state, input)
			keyboard[input.KeyCode.Name] = (state == Enum.UserInputState.Begin and 1 or 0)
			return Enum.ContextActionResult.Sink
		end
		local function gpButton(action, state, input)
			gamePad[input.KeyCode.Name] = (state == Enum.UserInputState.Begin and 1 or 0)
			return Enum.ContextActionResult.Sink
		end
		local function mousePan(action, state, input)
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.Y, -delta.X)
			return Enum.ContextActionResult.Sink
		end
		local function thumb(action, state, input)
			gamePad[input.KeyCode.Name] = input.Position
			return Enum.ContextActionResult.Sink
		end
		local function trigger(action, state, input)
			gamePad[input.KeyCode.Name] = input.Position.Z
			return Enum.ContextActionResult.Sink
		end
		local function mouseWheel(action, state, input)
			mouse[input.UserInputType.Name] = -input.Position.Z
			return Enum.ContextActionResult.Sink
		end
		ContextActionService:BindActionAtPriority("FreeCameraKeyboard", keypress, false, SPIRIT_SETTINGS.INPUT_PRIORITY, Enum.KeyCode.W, Enum.KeyCode.U, Enum.KeyCode.A, Enum.KeyCode.H, Enum.KeyCode.S, Enum.KeyCode.J, Enum.KeyCode.D, Enum.KeyCode.K, Enum.KeyCode.E, Enum.KeyCode.I, Enum.KeyCode.Q, Enum.KeyCode.Y, Enum.KeyCode.Up, Enum.KeyCode.Down)
		ContextActionService:BindActionAtPriority("FreeCameraMousePan", mousePan, false, SPIRIT_SETTINGS.INPUT_PRIORITY, Enum.UserInputType.MouseMovement)
		ContextActionService:BindActionAtPriority("FreeCameraMouseWheel", mouseWheel, false, SPIRIT_SETTINGS.INPUT_PRIORITY, Enum.UserInputType.MouseWheel)
		ContextActionService:BindActionAtPriority("FreeCameraGamePadButton", gpButton, false, SPIRIT_SETTINGS.INPUT_PRIORITY, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY)
		ContextActionService:BindActionAtPriority("FreeCameraGamePadTrigger", trigger, false, SPIRIT_SETTINGS.INPUT_PRIORITY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonL2)
		ContextActionService:BindActionAtPriority("FreeCameraGamePadThumbstick", thumb, false, SPIRIT_SETTINGS.INPUT_PRIORITY, Enum.KeyCode.Thumbstick1, Enum.KeyCode.Thumbstick2)
	end
	_2.startCapture = startCapture
	local function stopCapture()
		local function zero(t)
			for k, v in pairs(t) do
				t[k] = (v * 0)
			end
		end
		navSpeed = 1
		for _, device in ipairs({ gamePad, keyboard, mouse }) do
			zero(device)
		end
		ContextActionService:UnbindAction("FreeCameraKeyboard")
		ContextActionService:UnbindAction("FreeCameraMousePan")
		ContextActionService:UnbindAction("FreeCameraMouseWheel")
		ContextActionService:UnbindAction("FreeCameraGamePadButton")
		ContextActionService:UnbindAction("FreeCameraGamePadTrigger")
		ContextActionService:UnbindAction("FreeCameraGamePadThumbstick")
	end
	_2.stopCapture = stopCapture
end
return Input
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX19F38E70C90445EE9134413E70E3ED9E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">playerState</string>
						<string name="ScriptGuid">{0392B55A-6470-464C-A732-4EBB6AE46B4C}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _0 = TS.import(script, TS.getModule(script, "services"))
local Players = _0.Players
local StarterGui = _0.StarterGui
local UserInputService = _0.UserInputService
local screenGuis = {}
local coreGuis = {
	Backpack = true,
	Chat = true,
	Health = true,
	PlayerList = true,
}
local setCores = {
	BadgesNotificationsActive = true,
	PointsNotificationsActive = true,
}
local cameraFieldOfView = nil
local cameraType = nil
local cameraCFrame = nil
local cameraFocus = nil
local cameraSubject = nil
local mouseIconEnabled = nil
local mouseBehavior = nil
local PlayerState = {}
do
	local _1 = PlayerState
	local function push(camera)
		for name in pairs(coreGuis) do
			coreGuis[name] = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType[name])
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], false)
		end
		for name in pairs(setCores) do
			setCores[name] = StarterGui:GetCore(name)
			StarterGui:SetCore(name, false)
		end
		local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if playerGui then
			for _, gui in pairs(playerGui:GetChildren()) do
				if gui:IsA("ScreenGui") and gui.Enabled then
					local _2 = screenGuis
					local _3 = gui
					-- ▼ Array.push ▼
					_2[#_2 + 1] = _3
					-- ▲ Array.push ▲
					gui.Enabled = true
				end
			end
		end
		cameraFieldOfView = camera.FieldOfView
		camera.FieldOfView = 70
		cameraType = camera.CameraType
		camera.CameraType = Enum.CameraType.Custom
		cameraCFrame = camera.CFrame
		cameraFocus = camera.Focus
		cameraSubject = camera.CameraSubject
		mouseIconEnabled = UserInputService.MouseIconEnabled
		UserInputService.MouseIconEnabled = false
		mouseBehavior = UserInputService.MouseBehavior
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
	_1.push = push
	local function pop(camera)
		for name, isEnabled in pairs(coreGuis) do
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], isEnabled)
		end
		for name, isEnabled in pairs(setCores) do
			StarterGui:SetCore(name, isEnabled)
		end
		local _2 = screenGuis
		local _3 = function(gui)
			if gui.Parent then
				gui.Enabled = true
			end
		end
		-- ▼ ReadonlyArray.forEach ▼
		for _4, _5 in ipairs(_2) do
			_3(_5, _4 - 1, _2)
		end
		-- ▲ ReadonlyArray.forEach ▲
		camera.FieldOfView = cameraFieldOfView
		cameraFieldOfView = nil
		camera.CFrame = cameraCFrame
		cameraCFrame = nil
		camera.CameraType = cameraType
		cameraType = nil
		camera.CameraSubject = cameraSubject
		cameraSubject = nil
		camera.Focus = cameraFocus
		cameraFocus = nil
		UserInputService.MouseIconEnabled = mouseIconEnabled
		mouseIconEnabled = nil
		UserInputService.MouseBehavior = mouseBehavior
		mouseBehavior = nil
	end
	_1.pop = pop
end
return PlayerState
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX826D74D355B8469D9BAD3EADFB7E9E6D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">settings</string>
						<string name="ScriptGuid">{C407A503-C2E4-4EDE-BDB4-124E1284ED22}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local SPIRIT_SETTINGS = {
	TOGGLE_INPUT_PRIORITY = Enum.ContextActionPriority.Low.Value,
	INPUT_PRIORITY = Enum.ContextActionPriority.High.Value,
	FREE_CAMERA_MACRO_KB = { Enum.KeyCode.LeftShift, Enum.KeyCode.P },
	NAV_GAIN = Vector3.new(1, 1, 1) * 48,
	PAN_GAIN = Vector2.new(0.75, 1) * 8,
	FOV_GAIN = 300,
	PITCH_LIMIT = math.rad(90),
	VEL_STIFFNESS = 15,
	PAN_STIFFNESS = 10,
	FOV_STIFFNESS = 4.0,
}
local _0 = {
	NAV_GAMEPAD_SPEED = Vector3.new(1, 1, 1),
	NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1),
}
local _1 = "PAN_MOUSE_SPEED"
local _2 = Vector2.new(1, 1)
local _3 = math.pi / 164
_0[_1] = _2 * _3
local _4 = "PAN_GAMEPAD_SPEED"
local _5 = Vector2.new(1, 1)
local _6 = math.pi / 8
_0[_4] = _5 * _6
_0.FOV_WHEEL_SPEED = 1.0
_0.FOV_GAMEPAD_SPEED = 0.25
_0.NAV_ADJ_SPEED = 0.75
_0.NAV_SHIFT_MUL = 0.25
local DEVICE_SETTINGS = _0
return {
	SPIRIT_SETTINGS = SPIRIT_SETTINGS,
	DEVICE_SETTINGS = DEVICE_SETTINGS,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD0C04E969BA248C3A1E5A28253E39F7A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">spring</string>
						<string name="ScriptGuid">{929FB800-E7EC-4902-AA78-016693EA1D57}</string>
						<ProtectedString name="Source"><![CDATA[local Spring = {} do
	Spring.__index = Spring

	function Spring.new(freq, pos)
		local self = setmetatable({}, Spring)
		self.f = freq
		self.p = pos
		self.v = pos*0
		return self
	end

	function Spring:Update(dt, goal)
		local f = self.f*2*math.pi
		local p0 = self.p
		local v0 = self.v

		local offset = goal - p0
		local decay = math.exp(-f*dt)

		local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
		local v1 = (f*dt*(offset*f - v0) + v0)*decay

		self.p = p1
		self.v = v1

		return p1
	end

	function Spring:Reset(pos)
		self.p = pos
		self.v = pos*0
	end
end

return Spring]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFA9E7DAF24004522A899897878293C9C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">toggle</string>
						<string name="ScriptGuid">{E6380252-1649-4C23-BC8A-80357D6FC57A}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _0 = TS.import(script, TS.getModule(script, "services"))
local RunService = _0.RunService
local Workspace = _0.Workspace
local Input = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit", "input")
local SPIRIT_SETTINGS = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit", "settings").SPIRIT_SETTINGS
local Spring = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit", "spring")
local PlayerState = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Spirit", "playerState")
local camera = Workspace.CurrentCamera
do
	Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		local newCamera = Workspace.CurrentCamera
		if newCamera then
			camera = newCamera
		end
	end)
end
local cameraPosition = Vector3.new()
local cameraRotation = Vector2.new()
local cameraFieldOfView = 0
local function getFocusDistance(cameraFrame)
	local zNear = 0.1
	local viewPort = camera.ViewportSize
	local projY = 2 * math.tan(cameraFieldOfView / 2)
	local _1 = viewPort.X
	local _2 = viewPort
	if _2 ~= nil then
		_2 = _2.Y
	end
	local projX = (_1 / _2) * projY
	local fx = cameraFrame.RightVector
	local fy = cameraFrame.UpVector
	local fz = cameraFrame.LookVector
	local minimumVector = Vector3.new()
	local minimumDistance = 512
	do
		local _3 = 0
		while _3 < 1 do
			local x = _3
			do
				local _4 = 0
				while _4 < 1 do
					local y = _4
					local cx = (x - 0.5) * projX
					local cy = (y - 0.5) * projY
					local _5 = fx
					local _6 = cx
					local _7 = fy
					local _8 = cy
					local _9 = fz
					local offset = _5 * _6 - (_7 * _8) + _9
					local _10 = cameraFrame.Position
					local _11 = offset
					local _12 = zNear
					local origin = _10 + (_11 * _12)
					local _13 = Workspace
					local _14 = offset.Unit
					local _15 = minimumDistance
					local result = _13:Raycast(origin, _14 * _15)
					if result then
						local _16 = result.Position
						local _17 = origin
						local distance = (_16 - _17).Magnitude
						if minimumDistance > distance then
							minimumDistance = distance
							minimumVector = offset.Unit
						end
					end
					_4 = y
					_4 += 0.5
				end
			end
			_3 = x
			_3 += 0.5
		end
	end
	return fz:Dot(minimumVector) * minimumDistance
end
local velSpring = Spring.new(SPIRIT_SETTINGS.VEL_STIFFNESS, Vector3.new())
local panSpring = Spring.new(SPIRIT_SETTINGS.PAN_STIFFNESS, Vector2.new())
local fovSpring = Spring.new(SPIRIT_SETTINGS.FOV_STIFFNESS, 0)
local function stepFreeCamera(dt)
	local vel = velSpring:Update(dt, Input.vel(dt))
	local pan = panSpring:Update(dt, Input.pan(dt))
	local fov = fovSpring:Update(dt, Input.fov(dt))
	local zoomFactor = math.sqrt(math.tan(math.rad(70 / 20)) / math.tan(math.rad(cameraFieldOfView / 2)))
	cameraFieldOfView = math.clamp(cameraFieldOfView + fov * SPIRIT_SETTINGS.FOV_GAIN * (dt / zoomFactor), 1, 120)
	local _1 = cameraRotation
	local _2 = pan
	local _3 = SPIRIT_SETTINGS.PAN_GAIN
	local _4 = dt / zoomFactor
	cameraRotation = _1 + (_2 * _3 * _4)
	cameraRotation = Vector2.new(math.clamp(cameraRotation.X, -SPIRIT_SETTINGS.PITCH_LIMIT, SPIRIT_SETTINGS.PITCH_LIMIT), cameraRotation.Y % (2 * math.pi))
	local _5 = CFrame.new(cameraPosition)
	local _6 = CFrame.fromOrientation(cameraRotation.X, cameraRotation.Y, 0)
	local _7 = vel
	local _8 = SPIRIT_SETTINGS.NAV_GAIN
	local _9 = dt
	local _10 = CFrame.new(_7 * _8 * _9)
	local cameraCFrame = _5 * (_6 * _10)
	cameraPosition = cameraCFrame.Position
	camera.CFrame = cameraCFrame
	local _11 = cameraCFrame
	local _12 = CFrame.new(0, 0, -getFocusDistance(cameraCFrame))
	camera.Focus = _11 * _12
	camera.FieldOfView = cameraFieldOfView
end
local function startFreeCamera()
	while camera.CameraSubject == nil do
		RunService.Heartbeat:Wait()
	end
	local cameraCFrame = camera.CFrame
	cameraRotation = Vector2.new(cameraCFrame:ToEulerAnglesYXZ())
	cameraPosition = cameraCFrame.Position
	cameraFieldOfView = camera.FieldOfView
	velSpring:Reset(Vector3.new())
	panSpring:Reset(Vector2.new())
	fovSpring:Reset(0)
	PlayerState.push(camera)
	RunService:BindToRenderStep("FreeCamera", Enum.RenderPriority.Camera.Value, stepFreeCamera)
	Input.startCapture()
end
local function stopFreeCamera()
	Input.stopCapture()
	RunService:UnbindFromRenderStep("FreeCamera")
	PlayerState.pop(camera)
end
return {
	startFreeCamera = startFreeCamera,
	stopFreeCamera = stopFreeCamera,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXE7C0414E936448858F182E4A422CDE5F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">assets</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Model" referent="RBXDE684E7274DA4DBF95BF317F028F57D5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<token name="LevelOfDetail">0</token>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<CoordinateFrame name="ModelMeshCFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
						<Vector3 name="ModelMeshSize">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<string name="Name">Heal</string>
						<bool name="NeedsPivotMigration">true</bool>
						<Ref name="PrimaryPart">RBXD858C4B454D84C3E9C225E35C5EFB0B5</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
					</Properties>
					<Item class="MeshPart" referent="RBX1F47ABFEECF244B7BEFF44DC6D8E4738">
						<Properties>
							<bool name="Anchored">true</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-3.75</X>
								<Y>1.25</Y>
								<Z>11.25</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanTouch">false</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4278255360</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DoubleSided">false</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<Vector3 name="InitialSize">
								<X>15</X>
								<Y>50</Y>
								<Z>50</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="LODData"></BinaryString>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">288</token>
							<Content name="MeshID"><url>rbxassetid://6791324190</url></Content>
							<Content name="MeshId"><url>rbxassetid://6791324190</url></Content>
							<string name="Name">Inner</string>
							<SharedString name="PhysicalConfigData">x21M00F/J+XHo9NbCyDDnQ==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="size">
								<X>0.625</X>
								<Y>2.125</Y>
								<Z>2.125</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBX12D7AE143E314604BF2D0EFAAF2E4E28">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<string name="Name">Attachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBXD858C4B454D84C3E9C225E35C5EFB0B5">
						<Properties>
							<bool name="Anchored">true</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-3.75</X>
								<Y>1.25</Y>
								<Z>11.25</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">HitBox</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">1</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2.5</X>
								<Y>2.5</Y>
								<Z>2.5</Z>
							</Vector3>
						</Properties>
						<Item class="ParticleEmitter" referent="RBX085F9491EBFB4670BA16117D76CB87A3">
							<Properties>
								<Vector3 name="Acceleration">
									<X>0</X>
									<Y>0.5</Y>
									<Z>0</Z>
								</Vector3>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<ColorSequence name="Color">0 0.392157 1 0.392157 0 1 0.392157 1 0.392157 0 </ColorSequence>
								<float name="Drag">0</float>
								<token name="EmissionDirection">1</token>
								<bool name="Enabled">true</bool>
								<NumberRange name="Lifetime">1 2.5 </NumberRange>
								<float name="LightEmission">1</float>
								<float name="LightInfluence">0</float>
								<bool name="LockedToPart">false</bool>
								<string name="Name">Sparkles</string>
								<token name="Orientation">0</token>
								<float name="Rate">4</float>
								<NumberRange name="RotSpeed">0 0 </NumberRange>
								<NumberRange name="Rotation">0 0 </NumberRange>
								<NumberSequence name="Size">0 0.4 0.1 1 0.4 0.1 </NumberSequence>
								<int64 name="SourceAssetId">-1</int64>
								<NumberRange name="Speed">0.5 0.5 </NumberRange>
								<Vector2 name="SpreadAngle">
									<X>45</X>
									<Y>45</Y>
								</Vector2>
								<BinaryString name="Tags"></BinaryString>
								<Content name="Texture"><url>rbxassetid://1053546634</url></Content>
								<float name="TimeScale">1</float>
								<NumberSequence name="Transparency">0 1 0 0.5 0 0 1 1 0 </NumberSequence>
								<float name="VelocityInheritance">0</float>
								<float name="ZOffset">0</float>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX9619D8C89F744D1AA30CBFF3AC0DE971">
						<Properties>
							<bool name="Anchored">true</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-3.75</X>
								<Y>1.25</Y>
								<Z>11.25</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanTouch">false</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294112243</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DoubleSided">false</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<Vector3 name="InitialSize">
								<X>15</X>
								<Y>50</Y>
								<Z>50</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="LODData"></BinaryString>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">1584</token>
							<Content name="MeshID"><url>rbxassetid://6791324190</url></Content>
							<Content name="MeshId"><url>rbxassetid://6791324190</url></Content>
							<string name="Name">Overlay</string>
							<SharedString name="PhysicalConfigData">x21M00F/J+XHo9NbCyDDnQ==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><url>rbxassetid://3492801677</url></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="size">
								<X>0.75</X>
								<Y>2.25</Y>
								<Z>2.25</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXB480453C2CF3476EB5FA0821DC33DEDF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<string name="Name">Attachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Tool" referent="RBXF42BD6F534724F98937CAD73DB637BC4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">true</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">false</bool>
						<string name="Name">Pistol</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><null></null></Content>
						<string name="ToolTip"></string>
					</Properties>
					<Item class="MeshPart" referent="RBXD97379B5A1124777BE23871F8575960C">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>22.8273163</X>
								<Y>0.363108516</Y>
								<Z>4.85573959</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DoubleSided">false</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<Vector3 name="InitialSize">
								<X>1.44531989</X>
								<Y>0.726217031</Y>
								<Z>0.188472033</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="LODData"></BinaryString>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<Content name="MeshID"><url>rbxassetid://6856171736</url></Content>
							<Content name="MeshId"><url>rbxassetid://6856171736</url></Content>
							<string name="Name">Handle</string>
							<SharedString name="PhysicalConfigData">BfNrEqgHfIBywUSJrb8ngQ==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><url>rbxassetid://6856171793</url></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="size">
								<X>1.44531989</X>
								<Y>0.726217031</Y>
								<Z>0.188472033</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7031D41C7A904932894DE576CA471525">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tests</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX79CE79425E0C4DB1B40588EC82332978">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Events.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
-- / <reference types="@rbxts/testez/globals" />
local _0 = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "dispatcher")
local Dispatcher = _0.default
local interval = _0.interval
local noYield = _0.noYield
local function now()
	return DateTime.now().UnixTimestampMillis / 1000
end
return function()
	describe("interval", function()
		it("Should not run", function()
			local hasRan = false
			local listener = interval(1, function(message)
				hasRan = true
			end)
			local connection = listener.event:connect(function()
				listener.callback("hello")
			end)
			connection.disconnect()
			TS.Promise.delay(1.2):await()
			expect(hasRan).to.equal(false)
		end)
		it("Should fire every interval", function()
			local testValue = 0
			local times = {}
			local listener = interval(1 / 6, function()
				testValue += 1
				local _1 = times
				local _2 = now()
				-- ▼ Array.push ▼
				_1[#_1 + 1] = _2
				-- ▲ Array.push ▲
			end)
			local connection = listener.event:connect(function()
				listener.callback()
			end)
			TS.Promise.delay(5.2 / 6):await()
			connection.disconnect()
			expect(math.abs(testValue - 5) <= 1).to.equal(true)
		end)
	end)
	describe("Signal", function()
		it("Should only run once", function()
			local signal = Dispatcher.new()
			local hasRanTimes = 0
			local connection
			connection = signal:connect(function(check)
				connection.disconnect()
				hasRanTimes = check
			end)
			signal:fire(1)
			signal:fire(2)
			expect(hasRanTimes).to.equal(1)
		end)
		it("Inline resumption should be of okay", function()
			local signal = Dispatcher.new()
			local success = false
			signal:connect(function()
				success = true
			end)
			signal:fire()
			expect(success).to.equal(true)
		end)
		it("Error when yielding inside of handler", function()
			local signal = Dispatcher.new()
			signal:connect(function()
				wait(5)
			end)
			local tracebackReporter = function(message)
				return debug.traceback(tostring(message))
			end
			local ok, result = xpcall(function()
				noYield(function()
					error("Hello")
				end)
			end, tracebackReporter)
			-- warn(result); silence the warning
			expect(ok).to.equal(false)
		end)
	end)
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX9ABB286640F84A0DA6A5A4B1B10F1F36">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">typeChallenges</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX15DFEF5681EB4862865C42C3A05A10D5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">awaited</string>
						<string name="ScriptGuid">{94388686-A227-42FD-9E18-23026523F4F9}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF5E6BB05FCC645C898D041FB5136AA90">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">concat</string>
						<string name="ScriptGuid">{9F2409EC-77D1-4365-943D-F8B83F3A586F}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB56CA95E487645B598B582E43D76B951">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">exclude</string>
						<string name="ScriptGuid">{2C5DCD20-2ED3-439F-832F-E1CC883127B1}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX71D6C26704B74345BFC1297603883B77">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">firstOfArray</string>
						<string name="ScriptGuid">{2635D0FE-BD8F-4773-B050-5C08B8EF1693}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX44FB066520164BB38E459097F40C6FE6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">if</string>
						<string name="ScriptGuid">{4F77105E-7065-4B23-A208-94275A095D02}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEBCD370DCE9D4CC9931FCCE6B1547287">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">includes</string>
						<string name="ScriptGuid">{52750A2E-0126-4118-9A5A-62CC1382D45D}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0F48F4868A674F2EABA12435D7A98E6D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lengthOfTuple</string>
						<string name="ScriptGuid">{EFB3497E-D517-4C22-AB7C-CB220FCFA035}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3FE15A13B54643D0BF407EDDCB617959">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">myPick</string>
						<string name="ScriptGuid">{9810B1B6-7166-461E-A46A-0D94AED1A1BC}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local todo = {
	title = "hello",
}
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0207FBF023944A97BA3E38F9BF9A73D8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">myReadonly</string>
						<string name="ScriptGuid">{A7F830EC-075D-4354-9A7C-67CDA771EB9E}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local todo = {
	title = "hello",
	description = "foo",
	completed = false,
}
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9FFB45EA5F084200AFFEFB7B5A5E1ED8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tupleToObject</string>
						<string name="ScriptGuid">{1D7B292E-0695-4816-A5A9-7579C08B04DC}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local tuple = { "foo", "bar", "baz" }
local result = {
	foo = "foo",
	bar = "bar",
	baz = "baz",
}
return nil
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXB40DBC2A93D84C67874DF3DA8FF0E991">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">dispatcher</string>
					<string name="ScriptGuid">{DEE1A836-1125-41D1-9668-F596C2A5C456}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
local RunService = TS.import(script, TS.getModule(script, "services")).RunService
local Signal = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "dispatcher", "signal")
local SingleEvent = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "dispatcher", "singleEvent")
local dt = 1 / 60
RunService.Heartbeat:Connect(function(dt)
	dt = dt
end)
local function interval(duration, callback)
	local event = SingleEvent.new(function(dispatch)
		return function(_listener, _promise, isCancelled)
			local loop
			loop = TS.async(function()
				local _0 = TS.Promise.try(dispatch):andThenCall(TS.Promise.delay, duration)
				local _1 = function()
					if not isCancelled(function()
						warn("[Event] Rejected")
						loop = nil
					end) then
						return loop()
					end
				end
				return _0:andThen(_1)
			end)
			loop()
		end
	end)
	return {
		event = event,
		callback = callback,
	}
end
local function spreadInterval(duration, callbackCreator)
	local isReady = true
	local needsRestart = false
	local loop
	local event = SingleEvent.new(function(dispatch)
		return function(_listener, _promise, isCancelled)
			loop = TS.async(function()
				local _0 = TS.Promise.try(dispatch):andThenCall(TS.Promise.delay, duration)
				local _1 = function()
					if not isCancelled(function()
						warn("[Event] Rejected")
						loop = nil
					end) then
						return loop()
					end
				end
				return _0:andThen(_1)
			end)
			loop()
		end
	end)
	local function becomeReady()
		isReady = true
		if needsRestart then
			needsRestart = false
			loop()
		end
	end
	return {
		event = event,
		callback = function(list)
			local callback = callbackCreator()
			local _0 = {}
			local _1 = #_0
			for _2, _3 in ipairs(list) do
				_0[_1 + _2] = _3
			end
			local listCopy = _0
			local copyIndex = 0
			local currentIndex = 0
			local seen = 0
			local function stepIndex()
				if copyIndex <= #listCopy and listCopy[copyIndex + 1] ~= list[currentIndex + 1] then
					local _2 = list
					local _3 = function(current)
						return current == listCopy[copyIndex + 1]
					end
					-- ▼ ReadonlyArray.findIndex ▼
					local _4 = -1
					for _5, _6 in ipairs(_2) do
						if _3(_6, _5 - 1, _2) == true then
							_4 = _5 - 1
							break
						end
					end
					-- ▲ ReadonlyArray.findIndex ▲
					local _5 = _4
					if _5 == nil then
						_5 = currentIndex
					end
					currentIndex = _5
				end
				local value = list[currentIndex + 1]
				currentIndex = math.min(#list + 1, currentIndex + 1)
				copyIndex = math.min(#list, copyIndex + 1)
				if value then
					seen += 1
				end
				return value
			end
			local currentTime = 0
			while currentTime <= duration do
				local remainingTasks = #list - seen
				local remainingTime = duration - currentTime
				local timePerUpdate = remainingTime / remainingTasks
				local updateToDoNow = math.ceil(dt / timePerUpdate)
				local _2 = TS.Promise.delay(timePerUpdate)
				local _3 = function(timeTaken)
					currentTime += timeTaken
				end
				local promise = _2:andThen(_3)
				do
					local _4 = 0
					while _4 < updateToDoNow do
						local i = _4
						local nextTask = stepIndex()
						if nextTask then
							local ok, result = coroutine.resume(coroutine.create(callback), nextTask)
							if not ok then
								warn(result)
							end
						end
						_4 = i
						_4 += 1
					end
				end
				promise:await()
				if seen < #list then
					do
						local _4 = seen
						while _4 < #list do
							local i = _4
							local ok, result = coroutine.resume(coroutine.create(callback), list[i + 1])
							if not ok then
								warn(result)
							end
							_4 = i
							_4 += 1
						end
					end
				end
				becomeReady()
			end
		end,
	}
end
exports.noYield = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "dispatcher", "noYield").noYield
local default = Signal
exports.interval = interval
exports.spreadInterval = spreadInterval
exports.default = default
return exports
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX9A5B4DE9B1504A46B702AB42B5F52571">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">signal</string>
						<string name="ScriptGuid">{4C1694C8-4704-408C-9BA7-78E11B02AEAA}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local Signal
do
	Signal = setmetatable({}, {
		__tostring = function()
			return "Signal"
		end,
	})
	Signal.__index = Signal
	function Signal.new(...)
		local self = setmetatable({}, Signal)
		self:constructor(...)
		return self
	end
	function Signal:constructor()
		self._currentListHead = nil
	end
	function Signal:connect(handler)
		local listener = {
			handler = handler,
			disconnected = false,
			connectTraceback = debug.traceback,
			disconnectTraceback = nil,
			next = self._currentListHead,
		}
		local disconnect = function()
			if listener.disconnected then
				error("Listener connected at: \n" .. tostring(listener.connectTraceback) .. "\nwas already disconnected at listener.disconnectTraceback")
			end
			listener.disconnected = true
			listener.disconnectTraceback = debug.traceback()
			if self._currentListHead == listener then
				self._currentListHead = listener.next
			else
				local previous = self._currentListHead
				while previous and previous.next ~= listener do
					previous = previous.next
				end
				if previous then
					previous.next = listener.next
				end
			end
		end
		self._currentListHead = listener
		return {
			listener = listener,
			disconnect = disconnect,
		}
	end
	function Signal:fire(...)
		local args = { ... }
		local listener = self._currentListHead
		while listener ~= nil do
			if not listener.disconnected then
				listener.handler(unpack(args))
			end
			listener = listener.next
		end
	end
end
return Signal
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0F6C939824DB4ECAA5569EB3313D8071">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">singleEvent</string>
						<string name="ScriptGuid">{4A742203-AE11-4BA2-8D25-EA17F020D6F0}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local SingleEvent
do
	SingleEvent = setmetatable({}, {
		__tostring = function()
			return "SingleEvent"
		end,
	})
	SingleEvent.__index = SingleEvent
	function SingleEvent.new(...)
		local self = setmetatable({}, SingleEvent)
		self:constructor(...)
		return self
	end
	function SingleEvent:constructor(executor)
		self._listener = nil
		self._promise = nil
		local dispatch = function()
			if self._listener ~= nil then
				coroutine.wrap(self._listener)()
			end
		end
		self._promise = TS.Promise.defer(function(resolve)
			local _0 = TS.Promise.new(executor(dispatch))
			local _1 = function()
				self._listener = nil
				return self._listener
			end
			resolve(_0:andThen(_1))
		end)
	end
	function SingleEvent:connect(handler)
		local _0 = self._listener == nil
		assert(_0, "Dispatcher is already used up")
		local _1 = self._promise:getStatus() == "Started"
		assert(_1, "Dispatcher is already used up")
		self._listener = handler
		local disconnect = function()
			self._promise:cancel()
			self._listener = nil
		end
		return {
			disconnect = disconnect,
		}
	end
end
return SingleEvent
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2C993F36A9E747DB9BE0AE75B9BC8B24">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">noYield</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local function resultHandler(co, ok, ...)
	local results = { ... }
	if not ok then
		error(debug.traceback(co, unpack(results)), 2)
	end
	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end
	return unpack(results)
end
local function noYield(callback, ...)
	local args = { ... }
	local co = coroutine.create(callback)
	return resultHandler(co, coroutine.resume(co, unpack(args)))
end
return {
	noYield = noYield,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="43">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="44">
		<Properties>
			<Color3 name="Ambient">
				<R>0.274509817</R>
				<G>0.274509817</G>
				<B>0.274509817</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">3</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">1</float>
			<float name="EnvironmentSpecularScale">1</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.752941251</R>
				<G>0.752941251</G>
				<B>0.752941251</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">0</float>
			<bool name="GlobalShadows">true</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.274509817</R>
				<G>0.274509817</G>
				<B>0.274509817</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.200000003</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">3</token>
			<string name="TimeOfDay">14:30:00</string>
		</Properties>
		<Item class="Sky" referent="45">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="CelestialBodiesShown">true</bool>
				<float name="MoonAngularSize">11</float>
				<Content name="MoonTextureId"><url>rbxassetid://6444320592</url></Content>
				<string name="Name">Sky</string>
				<Content name="SkyboxBk"><url>rbxassetid://6444884337</url></Content>
				<Content name="SkyboxDn"><url>rbxassetid://6444884785</url></Content>
				<Content name="SkyboxFt"><url>rbxassetid://6444884337</url></Content>
				<Content name="SkyboxLf"><url>rbxassetid://6444884337</url></Content>
				<Content name="SkyboxRt"><url>rbxassetid://6444884337</url></Content>
				<Content name="SkyboxUp"><url>rbxassetid://6412503613</url></Content>
				<int64 name="SourceAssetId">332039975</int64>
				<int name="StarCount">3000</int>
				<float name="SunAngularSize">11</float>
				<Content name="SunTextureId"><url>rbxassetid://6196665106</url></Content>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="SunRaysEffect" referent="46">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<float name="Intensity">0.00999999978</float>
				<string name="Name">SunRays</string>
				<int64 name="SourceAssetId">-1</int64>
				<float name="Spread">0.100000001</float>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Atmosphere" referent="47">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="Color">
					<R>0.78039217</R>
					<G>0.78039217</G>
					<B>0.78039217</B>
				</Color3>
				<Color3 name="Decay">
					<R>0.41568628</R>
					<G>0.43921569</G>
					<B>0.490196079</B>
				</Color3>
				<float name="Density">0.300000012</float>
				<float name="Glare">0</float>
				<float name="Haze">0</float>
				<string name="Name">Atmosphere</string>
				<float name="Offset">0.25</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="BloomEffect" referent="48">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<float name="Intensity">1</float>
				<string name="Name">Bloom</string>
				<float name="Size">24</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="Threshold">2</float>
			</Properties>
		</Item>
		<Item class="DepthOfFieldEffect" referent="49">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">false</bool>
				<float name="FarIntensity">0.100000001</float>
				<float name="FocusDistance">0.0500000007</float>
				<float name="InFocusRadius">30</float>
				<string name="Name">DepthOfField</string>
				<float name="NearIntensity">0.75</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="DataStoreService" referent="50">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutomaticRetry">true</bool>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="HttpService" referent="51">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="52">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Teams" referent="53">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="54">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="55">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="BfNrEqgHfIBywUSJrb8ngQ==">Q1NHUEhTBwAAAAKuEp89MvpcPRTNFT600gK77Z0TO7XTBztXPWS4BQVcPFRJmDf9lno8EAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxIAAAAEAAAAAKRsPoT1a7yA
Y+u8AKRsPgAAALCAY+u8BNGbPgAAALCAY+u8AKRsPm77a7ygY+s8AKRsPgAAALCgY+s8BNGb
PgAAALCgY+s8GAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAABAAAAAAAAAAE
AAAAAQAAAAEAAAAEAAAABQAAAAEAAAAFAAAAAgAAAAIAAAAFAAAAAwAAAAMAAAAFAAAABAAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8hAAAABAAAALC0iT0A
AFm2gGPrvLC0iT0AAAAybdHOPP6jbD4AAFm2gGPrvD3gwT0gjwe9gGPrvLC0iT0AAFm2oGPr
PP6jbD4AAFm2oGPrPP6jbD66CGy8gGPrvD3gwT0gjwe9oGPrPNlPCz4gjwe9gGPrvP6jbD66
CGy8oGPrPNlPCz4gjwe9oGPrPDYAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAA
AAgAAAAAAAAACAAAAAMAAAAAAAAAAwAAAAcAAAAAAAAABwAAAAQAAAAAAAAABAAAAAEAAAAB
AAAABAAAAAUAAAABAAAABQAAAAIAAAACAAAABQAAAAkAAAACAAAACQAAAAYAAAADAAAACAAA
AAoAAAADAAAACgAAAAcAAAAEAAAABwAAAAoAAAAEAAAACgAAAAkAAAAEAAAACQAAAAUAAAAG
AAAACQAAAAoAAAAGAAAACgAAAAgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAA
AAAAAAAAAIA/GAAAAAQAAAASNso+AAAAABOoWD2pW6w+AAAAABOoWD0SNso+CRIAvhOoWD0S
Nso+AAAAAAOnWL2pW6w+AAAAAAOnWL0/KrI+wO0CvROoWD0SNso+CRIAvgOnWL0/KrI+wO0C
vQOnWL0kAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAAD
AAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAHAAAAAQAAAAcAAAAFAAAAAgAA
AAUAAAAHAAAAAgAAAAcAAAAGAAAAAwAAAAYAAAAHAAAAAwAAAAcAAAAEAAAAEAAAAAAAAAAA
AAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyQAAAAEAAAA8AS5vYLfSj4AAAAA8AS5
vQZxYz6Kkiu9RgA5voLfSj4AAAAA8AS5vUKV4j0AAAAARgA5vgZxYz6Kkiu98AS5vQZxYz4p
5oK9RgA5vpxkzD0AAAAA8AS5vUKV4j3Q/sC9RgA5vgZxYz4p5oK98AS5vYLfSj7Q/sC9RgA5
vpxkzD3Q/sC9RgA5voLfSj7Q/sC9PAAAAAAAAAABAAAABAAAAAAAAAAEAAAAAgAAAAAAAAAC
AAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABwAAAAAAAAAHAAAACQAAAAAAAAAJAAAABQAA
AAAAAAAFAAAAAQAAAAEAAAAFAAAACAAAAAEAAAAIAAAABAAAAAIAAAAEAAAACAAAAAIAAAAI
AAAACwAAAAIAAAALAAAACgAAAAIAAAAKAAAABgAAAAMAAAAGAAAACgAAAAMAAAAKAAAABwAA
AAUAAAAJAAAACwAAAAUAAAALAAAACAAAAAcAAAAKAAAACwAAAAcAAAALAAAACQAAABAAAAAA
AAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8kAAAABAAAAPAEub2N57k+AAAA
AEYAOb6N57k+AAAAAPAEub2cjZk+AAAAAPAEub2N57k+0P7AvUYAOb6N57k+0P7AvUYAOb6c
jZk+AAAAAPAEub3Id2M+ipIrvfAEub2cjZk+0P7AvUYAOb6cjZk+0P7AvUYAOb7Id2M+ipIr
vfAEub3Id2M+KeaCvUYAOb7Id2M+KeaCvTwAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAA
AAAAAgAAAAYAAAAAAAAABgAAAAoAAAAAAAAACgAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAA
AAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAgAAAABAAAACAAAAAsAAAABAAAACwAAAAkAAAAB
AAAACQAAAAUAAAACAAAABQAAAAkAAAACAAAACQAAAAYAAAADAAAABwAAAAgAAAADAAAACAAA
AAQAAAAGAAAACQAAAAsAAAAGAAAACwAAAAoAAAAHAAAACgAAAAsAAAAHAAAACwAAAAgAAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/JAAAAAQAAAAAAAC0jee5
PgAAAABOALm9jee5PgAAAAAAAAC0nI2ZPgAAAAAAAAC0jee5PtD+wL1OALm9jee5PtD+wL1O
ALm9nI2ZPgAAAAAAAAC0yHdjPoqSK70AAAC0nI2ZPtD+wL1OALm9nI2ZPtD+wL1OALm9yHdj
PoqSK70AAAC0yHdjPinmgr1OALm9yHdjPinmgr08AAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAC
AAAAAAAAAAIAAAAGAAAAAAAAAAYAAAAKAAAAAAAAAAoAAAAHAAAAAAAAAAcAAAADAAAAAAAA
AAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAIAAAAAQAAAAgAAAALAAAAAQAAAAsAAAAJ
AAAAAQAAAAkAAAAFAAAAAgAAAAUAAAAJAAAAAgAAAAkAAAAGAAAAAwAAAAcAAAAIAAAAAwAA
AAgAAAAEAAAABgAAAAkAAAALAAAABgAAAAsAAAAKAAAABwAAAAoAAAALAAAABwAAAAsAAAAI
AAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyoAAAAEAAAAFgIx
v+RaTT4AAAAAytQ4v+RaTT4AAAAAOOAhv0CMGz0AAAAAOOAhv+RaTT7Q/sC9QAA5v+RaTT6T
O428rP84v8P4SD4AAAAAUo4xv0CMGz0AAAAAOOAhv0CMGz3Q/sC9Uo4xv+RaTT7Q/sC9scI3
v+RaTT7s4RO9Uo4xv0CMGz3Q/sC9QAA5v7AZTD6Uiny8m503v+RaTT7gHRq9rKw3v+RaTT4q
qRe9SAAAAAAAAAABAAAABQAAAAAAAAAFAAAABgAAAAAAAAAGAAAAAgAAAAAAAAACAAAAAwAA
AAAAAAADAAAACAAAAAAAAAAIAAAADAAAAAAAAAAMAAAADQAAAAAAAAANAAAACQAAAAAAAAAJ
AAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAABQAAAAIAAAAGAAAACgAAAAIAAAAKAAAABwAA
AAIAAAAHAAAAAwAAAAMAAAAHAAAACgAAAAMAAAAKAAAACAAAAAQAAAAJAAAACgAAAAQAAAAK
AAAACwAAAAQAAAALAAAABQAAAAUAAAALAAAACgAAAAUAAAAKAAAABgAAAAgAAAAKAAAADAAA
AAkAAAANAAAACgAAAAoAAAANAAAADAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAA
AAAAAAAAAAAAgD8wAAAABAAAADjgIb/kWk0+0P7APVKOMb/kWk0+0P7APTjgIb9AjBs90P7A
PTjgIb9AjBs9AAAAABYCMb/kWk0+AAAAAJudN7/kWk0+ptUaPVKOMb9AjBs90P7APVKOMb9A
jBs9AAAAAE4JM7/kWk0+AAAAAKysN7/kWk0+nWoYPbHCN7/kWk0+C60UPUAAOb/kWk0+IKuO
PEAAOb+wGUw+YJB/PEAAOb9s8Eg+AMzUOJudN7+kszw+AAAAADbUOL/kWk0+AMzUOFQAAAAA
AAAAAQAAAAYAAAAAAAAABgAAAAIAAAAAAAAAAgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAA
AAgAAAAAAAAACAAAAA8AAAAAAAAADwAAAAsAAAAAAAAACwAAAAoAAAAAAAAACgAAAAkAAAAA
AAAACQAAAAUAAAAAAAAABQAAAAEAAAABAAAABQAAAAYAAAACAAAABgAAAAcAAAACAAAABwAA
AAMAAAADAAAABwAAAA4AAAADAAAADgAAAAgAAAADAAAACAAAAAQAAAAFAAAACQAAAAYAAAAG
AAAACQAAAAoAAAAGAAAACgAAAAsAAAAGAAAACwAAAAwAAAAGAAAADAAAAA0AAAAGAAAADQAA
AAcAAAAHAAAADQAAAA4AAAAIAAAADgAAAA8AAAALAAAADwAAAA0AAAALAAAADQAAAAwAAAAN
AAAADwAAAA4AAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/KgAA
AAQAAAAAAAC0lOFKPgAAAAAAAAC0KnRjPoqSK71OALm9lOFKPgAAAAAAAAC0dDKmPQAAAABO
ALm9KnRjPoqSK70AAAC0KnRjPinmgr1OALm9C5fiPQAAAAAAAAC0dDKmPaJ267xOALm9KnRj
Pinmgr0AAAC0lOFKPtD+wL1OALm9C5fiPdD+wL3Mocy8C5fiPdD+wL0AAAC07DkQPtD+wL1O
ALm9lOFKPtD+wL1IAAAAAAAAAAEAAAAEAAAAAAAAAAQAAAACAAAAAAAAAAIAAAAGAAAAAAAA
AAYAAAADAAAAAAAAAAMAAAAHAAAAAAAAAAcAAAAMAAAAAAAAAAwAAAAJAAAAAAAAAAkAAAAF
AAAAAAAAAAUAAAABAAAAAQAAAAUAAAAIAAAAAQAAAAgAAAAEAAAAAgAAAAQAAAAIAAAAAgAA
AAgAAAANAAAAAgAAAA0AAAAKAAAAAgAAAAoAAAAGAAAAAwAAAAYAAAAKAAAAAwAAAAoAAAAH
AAAABQAAAAkAAAANAAAABQAAAA0AAAAIAAAABwAAAAoAAAALAAAABwAAAAsAAAAMAAAACQAA
AAwAAAALAAAACQAAAAsAAAAKAAAACQAAAAoAAAANAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQ
AAAAAAAAAAAAAAAAAAAAAACAP1QAAAAEAAAAOOAhv1zpuT7Q/sA9OOAhv1zpuT4AAAAAAXUu
v1zpuT7Q/sA9OOAhv+RaTT7Q/sA9AXUuv1zpuT4AAAAAFgIxv+RaTT4AAAAATgkzv5Y2pz5o
Dpc9Uo4xv7cGqz7Q/sA9Uo4xv+RaTT7Q/sA9Tgkzv5Y2pz4AAAAATgkzv+RaTT4AAAAAm503
vxoRlD4AzNQ4QAA5v8z0jT4AzNQ4QAA5vxNejD5gkH88QAA5v7/ehz5KY+s8QAA5vwMmgT7O
qRk9QAA5vy1xcj66PiY9m503vy1xcj7hP1c9m503v8bgXT4K2kY9m503v+RaTT6m1Ro9S2g3
v2incj4AAAAANtQ4v+RaTT4AzNQ4S2g3v8c2cj4AAAAAQAA5v+RaTT4gq448QAA5v/yNYj7O
qRk9rKw3v+RaTT6dahg9scI3v+RaTT4LrRQ9QAA5v4QcVT5KY+s8nAAAAAAAAAABAAAABAAA
AAAAAAAEAAAAAgAAAAAAAAACAAAABwAAAAAAAAAHAAAACAAAAAAAAAAIAAAAAwAAAAAAAAAD
AAAAAQAAAAEAAAADAAAABQAAAAEAAAAFAAAACgAAAAEAAAAKAAAAFgAAAAEAAAAWAAAAFAAA
AAEAAAAUAAAACQAAAAEAAAAJAAAABAAAAAIAAAAEAAAACQAAAAIAAAAJAAAABgAAAAIAAAAG
AAAABwAAAAMAAAAIAAAAEwAAAAMAAAATAAAAGQAAAAMAAAAZAAAAGgAAAAMAAAAaAAAAFwAA
AAMAAAAXAAAAFQAAAAMAAAAVAAAACgAAAAMAAAAKAAAABQAAAAYAAAAJAAAACwAAAAYAAAAL
AAAADAAAAAYAAAAMAAAADQAAAAYAAAANAAAADgAAAAYAAAAOAAAABwAAAAcAAAAOAAAADwAA
AAcAAAAPAAAAEAAAAAcAAAAQAAAAEQAAAAcAAAARAAAACAAAAAgAAAASAAAAEwAAAAgAAAAR
AAAAEgAAAAkAAAAUAAAADAAAAAkAAAAMAAAACwAAAAoAAAAVAAAAFgAAAAwAAAAUAAAAFgAA
AAwAAAAWAAAAFQAAAAwAAAAVAAAAFwAAAAwAAAAXAAAAGwAAAAwAAAAbAAAAGAAAAAwAAAAY
AAAAEAAAAAwAAAAQAAAADwAAAAwAAAAPAAAADgAAAAwAAAAOAAAADQAAABAAAAAYAAAAEQAA
ABEAAAAYAAAAEgAAABIAAAAYAAAAGQAAABIAAAAZAAAAEwAAABcAAAAaAAAAGwAAABgAAAAb
AAAAGQAAABkAAAAbAAAAGgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAA
AAAAgD9XAAAABAAAAEIAub5c6bk+AAAAAAE+575c6bk+AAAAAEIAub6djZk+AAAAAEIAub5c
6bk+0P7AvQE+575c6bk+0P7AvQE+576djZk+AAAAAEIAub5sqlg+1R0pvUIAub6djZk+0P7A
vQE+576djZk+0P7AvQE+575sqlg+1R0pvQE+577vwFQ+bYszvUIAub5tBlU+ptMyvUIAub5s
qlg+MCqEvQE+575sqlg+MCqEvQE+576If1Q+M0M0vUIAub6If1Q+M0M0vUIAub6D3FY+/cOB
vQE+574BC1g+ZVWDvQE+574YsFE+v+xEvUIAub4YsFE+v+xEvUIAub6If1Q+qRt9vQE+576I
f1Q+qRt9vQE+575AWlE+FHZLvUIAub6oslA+wqVYvUIAub4YsFE+cmhsvQE+57528FM+KdJ5
vQE+576oslA+wqVYvQE+576EZlE+lL1mvQE+574YsFE+cmhsvaIAAAAAAAAAAQAAAAUAAAAA
AAAABQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAsAAAAAAAAACwAAAA8AAAAAAAAADwAA
ABMAAAAAAAAAEwAAABcAAAAAAAAAFwAAABgAAAAAAAAAGAAAABQAAAAAAAAAFAAAABAAAAAA
AAAAEAAAAAwAAAAAAAAADAAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAA
AAEAAAABAAAABAAAAAgAAAABAAAACAAAAA0AAAABAAAADQAAABEAAAABAAAAEQAAABUAAAAB
AAAAFQAAABkAAAABAAAAGQAAABwAAAABAAAAHAAAABsAAAABAAAAGwAAABoAAAABAAAAGgAA
ABYAAAABAAAAFgAAABIAAAABAAAAEgAAAA4AAAABAAAADgAAAAoAAAABAAAACgAAAAkAAAAB
AAAACQAAAAUAAAACAAAABQAAAAkAAAACAAAACQAAAAYAAAADAAAABwAAAAgAAAADAAAACAAA
AAQAAAAGAAAACQAAAAoAAAAGAAAACgAAAAsAAAAHAAAADAAAAA0AAAAHAAAADQAAAAgAAAAK
AAAADgAAAA8AAAAKAAAADwAAAAsAAAAMAAAAEAAAAA0AAAANAAAAEAAAABEAAAAOAAAAEgAA
ABMAAAAOAAAAEwAAAA8AAAAQAAAAFAAAABUAAAAQAAAAFQAAABEAAAASAAAAFgAAABMAAAAT
AAAAFgAAABcAAAAUAAAAGAAAABkAAAAUAAAAGQAAABUAAAAWAAAAGgAAABcAAAAXAAAAGgAA
ABsAAAAXAAAAGwAAABgAAAAYAAAAGwAAABwAAAAYAAAAHAAAABkAAAAQAAAAAAAAAAAAAAAA
AAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/YwAAAAQAAAChQue+XOm5PgAAAAAwwAq/XOm5
PgAAAAChQue+nY2ZPgAAAAChQue+XOm5PtD+wL0wwAq/XOm5PtD+wL0wwAq/nY2ZPgAAAACh
Que+bKpYPtUdKb2hQue+nY2ZPtD+wL0wwAq/nY2ZPtD+wL0wwAq/bKpYPtUdKb0wwAq/JEBY
PqksKr2hQue+78BUPm2LM72hQue+bKpYPjAqhL0wwAq/bKpYPjAqhL0wwAq/aKhUPiLPM72h
Que+iH9UPjNDNL2hQue+AQtYPmVVg70wwAq/tEJXPmdLgr0wwAq/iH9UPjNDNL0wwAq/Lp1S
PpJoP72hQue+GLBRPr/sRL2hQue+iH9UPqkbfb0wwAq/iH9UPqkbfb0wwAq/GLBRPr/sRL2h
Que+QFpRPhR2S72hQue+dvBTPinSeb0wwAq/RIpTPtCNd70wwAq/qLJQPsKlWL2hQue+qLJQ
PsKlWL2hQue+GLBRPnJobL0wwAq/GLBRPnJobL0wwAq/QFpRPhjCZb2hQue+hGZRPpS9Zr26
AAAAAAAAAAEAAAAFAAAAAAAAAAUAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAALAAAAAAAA
AAsAAAAPAAAAAAAAAA8AAAAUAAAAAAAAABQAAAAYAAAAAAAAABgAAAAcAAAAAAAAABwAAAAg
AAAAAAAAACAAAAAdAAAAAAAAAB0AAAAZAAAAAAAAABkAAAAVAAAAAAAAABUAAAAQAAAAAAAA
ABAAAAAMAAAAAAAAAAwAAAAHAAAAAAAAAAcAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAAB
AAAAAQAAAAQAAAAIAAAAAQAAAAgAAAANAAAAAQAAAA0AAAARAAAAAQAAABEAAAAWAAAAAQAA
ABYAAAAaAAAAAQAAABoAAAAeAAAAAQAAAB4AAAAfAAAAAQAAAB8AAAAbAAAAAQAAABsAAAAX
AAAAAQAAABcAAAATAAAAAQAAABMAAAASAAAAAQAAABIAAAAOAAAAAQAAAA4AAAAKAAAAAQAA
AAoAAAAJAAAAAQAAAAkAAAAFAAAAAgAAAAUAAAAJAAAAAgAAAAkAAAAGAAAAAwAAAAcAAAAI
AAAAAwAAAAgAAAAEAAAABgAAAAkAAAAKAAAABgAAAAoAAAALAAAABwAAAAwAAAANAAAABwAA
AA0AAAAIAAAACgAAAA4AAAALAAAACwAAAA4AAAAPAAAADAAAABAAAAARAAAADAAAABEAAAAN
AAAADgAAABIAAAAPAAAADwAAABIAAAATAAAADwAAABMAAAAUAAAAEAAAABUAAAARAAAAEQAA
ABUAAAAWAAAAEwAAABcAAAAUAAAAFAAAABcAAAAYAAAAFQAAABkAAAAaAAAAFQAAABoAAAAW
AAAAFwAAABsAAAAYAAAAGAAAABsAAAAcAAAAGQAAAB0AAAAaAAAAGgAAAB0AAAAeAAAAGwAA
AB8AAAAgAAAAGwAAACAAAAAcAAAAHQAAACAAAAAeAAAAHgAAACAAAAAfAAAAEAAAAAAAAAAA
AAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAP1oAAAAEAAAAMsCKvlzpuT4AAAAAQgC5
vlzpuT4AAAAAMsCKvp2NmT4AAAAAMsCKvlzpuT7Q/sC9QgC5vlzpuT7Q/sC9QgC5vp2NmT4A
AAAAMsCKvmyqWD7VHSm9MsCKvp2NmT7Q/sC9QgC5vp2NmT7Q/sC9QgC5vmyqWD7VHSm9MsCK
vla9Vz6Kkiu9MsCKvmyqWD4wKoS9QgC5vmyqWD4wKoS9QgC5vm0GVT6m0zK9MsCKvjLNVD68
ZDO9MsCKvsKKVj7rT4G9QgC5voPcVj79w4G9QgC5voh/VD4zQzS9MsCKvoh/VD4zQzS9MsCK
voh/VD6pG329QgC5voh/VD6pG329QgC5vhiwUT6/7ES9MsCKvhiwUT6/7ES9MsCKvqMPUz61
rnS9QgC5vhiwUT5yaGy9QgC5vqiyUD7CpVi9MsCKvoRmUT6dl0q9MsCKvhiwUT5yaGy9MsCK
viGDUT5A+Gi9MsCKvqiyUD7CpVi9qAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAAC
AAAABgAAAAAAAAAGAAAACgAAAAAAAAAKAAAADgAAAAAAAAAOAAAAEgAAAAAAAAASAAAAFgAA
AAAAAAAWAAAAGgAAAAAAAAAaAAAAHQAAAAAAAAAdAAAAHAAAAAAAAAAcAAAAGwAAAAAAAAAb
AAAAFwAAAAAAAAAXAAAAEwAAAAAAAAATAAAADwAAAAAAAAAPAAAACwAAAAAAAAALAAAABwAA
AAAAAAAHAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAACAAAAAEAAAAI
AAAADAAAAAEAAAAMAAAAEAAAAAEAAAAQAAAAFAAAAAEAAAAUAAAAGAAAAAEAAAAYAAAAGQAA
AAEAAAAZAAAAFQAAAAEAAAAVAAAAEQAAAAEAAAARAAAADQAAAAEAAAANAAAACQAAAAEAAAAJ
AAAABQAAAAIAAAAFAAAACQAAAAIAAAAJAAAABgAAAAMAAAAHAAAACAAAAAMAAAAIAAAABAAA
AAYAAAAJAAAACgAAAAcAAAALAAAADAAAAAcAAAAMAAAACAAAAAkAAAANAAAADgAAAAkAAAAO
AAAACgAAAAsAAAAPAAAAEAAAAAsAAAAQAAAADAAAAA0AAAARAAAADgAAAA4AAAARAAAAEgAA
AA8AAAATAAAAEAAAABAAAAATAAAAFAAAABEAAAAVAAAAFgAAABEAAAAWAAAAEgAAABMAAAAX
AAAAFAAAABQAAAAXAAAAGAAAABUAAAAZAAAAGgAAABUAAAAaAAAAFgAAABcAAAAbAAAAGAAA
ABgAAAAbAAAAHAAAABgAAAAcAAAAGQAAABkAAAAdAAAAGgAAABkAAAAcAAAAHQAAABAAAAAA
AAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD9aAAAABAAAAEYAOb5c6bk+AAAA
ADLAir5c6bk+AAAAAEYAOb6djZk+AAAAAEYAOb5c6bk+0P7AvTLAir5c6bk+0P7AvTLAir6d
jZk+AAAAAEYAOb5sqlg+1R0pvUYAOb6djZk+0P7AvTLAir6djZk+0P7AvTLAir5sqlg+1R0p
vTLAir5WvVc+ipIrvTLAir4yzVQ+vGQzvUYAOb6If1Q+M0M0vUYAOb5sqlg+MCqEvTLAir5s
qlg+MCqEvTLAir6If1Q+M0M0vUYAOb4YsFE+v+xEvTLAir7CilY+60+BvUYAOb6If1Q+qRt9
vTLAir4YsFE+v+xEvUYAOb6EZlE+nZdKvTLAir6If1Q+qRt9vUYAOb7QF1M+Et90vTLAir6E
ZlE+nZdKvUYAOb6oslA+wqVYvTLAir6jD1M+ta50vUYAOb4YsFE+cmhsvTLAir6oslA+wqVY
vTLAir4hg1E+QPhovTLAir4YsFE+cmhsvagAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAA
AAAAAgAAAAYAAAAAAAAABgAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAA
ABgAAAAAAAAAGAAAABoAAAAAAAAAGgAAABYAAAAAAAAAFgAAABIAAAAAAAAAEgAAAA0AAAAA
AAAADQAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAA
AAgAAAABAAAACAAAAA4AAAABAAAADgAAABEAAAABAAAAEQAAABUAAAABAAAAFQAAABkAAAAB
AAAAGQAAAB0AAAABAAAAHQAAABwAAAABAAAAHAAAABsAAAABAAAAGwAAABcAAAABAAAAFwAA
ABMAAAABAAAAEwAAAA8AAAABAAAADwAAAAsAAAABAAAACwAAAAoAAAABAAAACgAAAAkAAAAB
AAAACQAAAAUAAAACAAAABQAAAAkAAAACAAAACQAAAAYAAAADAAAABwAAAAgAAAADAAAACAAA
AAQAAAAGAAAACQAAAAoAAAAGAAAACgAAAAsAAAAGAAAACwAAAAwAAAAHAAAADQAAAA4AAAAH
AAAADgAAAAgAAAALAAAADwAAAAwAAAAMAAAADwAAABMAAAAMAAAAEwAAABAAAAANAAAAEQAA
AA4AAAANAAAAEgAAABEAAAAQAAAAEwAAABcAAAAQAAAAFwAAABQAAAARAAAAEgAAABUAAAAS
AAAAFgAAABUAAAAUAAAAFwAAABsAAAAUAAAAGwAAABgAAAAVAAAAFgAAABkAAAAWAAAAGgAA
ABkAAAAYAAAAHAAAABoAAAAYAAAAGwAAABwAAAAZAAAAGgAAAB0AAAAaAAAAHAAAAB0AAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAAAwwAq/XOm5
PtD+wD044CG/XOm5PtD+wD0wwAq/zYyZPtD+wD0wwAq/XOm5PgAAAAA44CG/XOm5PgAAAAA4
4CG/5FpNPtD+wD18mRi/5FpNPtD+wD0wwAq/zYyZPgAAAACFYh2/aR6KPgAAAAB8mRi/5FpN
PgAAAAAwAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAGAAAAAAAAAAYAAAACAAAAAAAAAAIAAAAH
AAAAAAAAAAcAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAFAAAAAgAA
AAYAAAAJAAAAAgAAAAkAAAAHAAAAAwAAAAcAAAAJAAAAAwAAAAkAAAAIAAAAAwAAAAgAAAAE
AAAABAAAAAgAAAAFAAAABQAAAAgAAAAJAAAABQAAAAkAAAAGAAAAEAAAAAAAAAAAAAAAAAAA
AAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAP1oAAAAEAAAAOOAhv1zpuT4AAAAAOOAhv1zpuT7Q
/sC9AXUuv1zpuT4AAAAAFgIxv+RaTT4AAAAAOOAhvz6yWD4pFCm9AXUuv1zpuT7Q/sC9OOAh
v+RaTT7Q/sC9Tgkzv5Y2pz4AAAAAytQ4v+RaTT4AAAAAOOAhv2O6UD4WnFi9OOAhv4GwUT6/
7ES9OOAhv9R5VD4zQzS9OOAhv+apWD7VHSm9Uo4xv7cGqz7Q/sC9Tgkzv5Y2pz5oDpe9Uo4x
v+RaTT7Q/sC9WJ83v5YElD4AAAAAQAA5v+RaTT6TO428QAA5v6DwjT4AAAAAm503vy1xcj5u
fla9QAA5vy1xcj5HfSW9QAA5vwMmgT6v3hi9QAA5v7/ehz5k4Om8QAA5vxNejD6Uiny8m503
v+RaTT7gHRq9m503v8bgXT5EIka9scI3v+RaTT7s4RO9QAA5v4QcVT5k4Om8QAA5v/yNYj6v
3hi9rKw3v+RaTT4qqRe9qAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABwAA
AAAAAAAHAAAAEAAAAAAAAAAQAAAAEgAAAAAAAAASAAAACAAAAAAAAAAIAAAAAwAAAAAAAAAD
AAAABAAAAAAAAAAEAAAADAAAAAAAAAAMAAAACwAAAAAAAAALAAAACgAAAAAAAAAKAAAACQAA
AAAAAAAJAAAABgAAAAAAAAAGAAAAAQAAAAEAAAAGAAAADwAAAAEAAAAPAAAADQAAAAEAAAAN
AAAABQAAAAIAAAAFAAAADgAAAAIAAAAOAAAABwAAAAMAAAAIAAAAEQAAAAMAAAARAAAAGgAA
AAMAAAAaAAAAHQAAAAMAAAAdAAAAGAAAAAMAAAAYAAAADwAAAAMAAAAPAAAABgAAAAMAAAAG
AAAACQAAAAMAAAAJAAAACgAAAAMAAAAKAAAACwAAAAMAAAALAAAADAAAAAMAAAAMAAAABAAA
AAUAAAANAAAADgAAAAcAAAAOAAAAEAAAAAgAAAASAAAAEQAAAA0AAAATAAAAFAAAAA0AAAAU
AAAAFQAAAA0AAAAVAAAAFgAAAA0AAAAWAAAADgAAAA0AAAAPAAAAEwAAAA4AAAAWAAAAFwAA
AA4AAAAXAAAAEgAAAA4AAAASAAAAEAAAAA8AAAAYAAAAGQAAAA8AAAAZAAAAEwAAABEAAAAS
AAAAFwAAABEAAAAXAAAAFgAAABEAAAAWAAAAFQAAABEAAAAVAAAAFAAAABEAAAAUAAAAHAAA
ABEAAAAcAAAAGwAAABEAAAAbAAAAGgAAABMAAAAcAAAAFAAAABMAAAAZAAAAHAAAABgAAAAd
AAAAHAAAABgAAAAcAAAAGQAAABoAAAAbAAAAHQAAABsAAAAcAAAAHQAAABAAAAAAAAAAAAAA
AAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAEIAub5Qj5k+AAAAAEIAub5c
6bk+AAAAAOgEOb5Qj5k+AAAAAEIAub5Qj5k+0P7APUIAub5c6bk+0P7APegEOb5c6bk+AAAA
AOgEOb5Qj5k+0P7APegEOb5c6bk+0P7APSQAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAA
AAAAAgAAAAYAAAAAAAAABgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAA
AAcAAAABAAAABwAAAAUAAAACAAAABQAAAAcAAAACAAAABwAAAAYAAAADAAAABgAAAAcAAAAD
AAAABwAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAA
AAQAAABGADm+UI+ZPgAAAABGADm+XOm5PgAAAAAAAAC0UI+ZPgAAAABGADm+UI+ZPtD+wD1G
ADm+XOm5PtD+wD0AAAC0XOm5PgAAAAAAAAC0UI+ZPtD+wD0AAAC0XOm5PtD+wD0kAAAAAAAA
AAEAAAAFAAAAAAAAAAUAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAADAAAAAAAAAAMAAAAE
AAAAAAAAAAQAAAABAAAAAQAAAAQAAAAHAAAAAQAAAAcAAAAFAAAAAgAAAAUAAAAHAAAAAgAA
AAcAAAAGAAAAAwAAAAYAAAAHAAAAAwAAAAcAAAAEAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQ
AAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAAMMAKv1CPmT4AAAAAMMAKv1zpuT4AAAAAQgC5
vlCPmT4AAAAAMMAKv1CPmT7Q/sA9MMAKv1zpuT7Q/sA9QgC5vlzpuT4AAAAAQgC5vlCPmT7Q
/sA9QgC5vlzpuT7Q/sA9JAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABgAA
AAAAAAAGAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAABwAAAAEAAAAH
AAAABQAAAAIAAAAFAAAABwAAAAIAAAAHAAAABgAAAAMAAAAGAAAABwAAAAMAAAAHAAAABAAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD9RAAAABAAAADDACr9c
6bk+AAAAADjgIb9c6bk+AAAAADDACr/NjJk+AAAAADDACr9c6bk+0P7AvTjgIb9c6bk+0P7A
vTjgIb8+slg+KRQpvYViHb9pHoo+AAAAADDACr/mqVg+1R0pvXyZGL/kWk0+AAAAADDACr/N
jJk+0P7AvTjgIb/kWk0+0P7AvTjgIb/mqVg+1R0pvTDACr9wPVg+qSwqvTjgIb/UeVQ+M0M0
vTjgIb+BsFE+v+xEvTjgIb9julA+FpxYvXyZGL/kWk0+0P7AvTDACr9julA+wqVYvTDACr+W
11A+ANpVvTDACr+BsFE+v+xEvTDACr+eFFI+YotCvTDACr/UeVQ+M0M0vTDACr/mqVg+MCqE
vTDACr8mQ1c+Z0uCvTDACr/UeVQ+qRt9vTDACr+BsFE+cmhsvTDACr/2ilE+A5NpvZYAAAAA
AAAAAQAAAAYAAAAAAAAABgAAAAgAAAAAAAAACAAAAAIAAAAAAAAAAgAAAAcAAAAAAAAABwAA
AAwAAAAAAAAADAAAABUAAAAAAAAAFQAAABQAAAAAAAAAFAAAABMAAAAAAAAAEwAAABIAAAAA
AAAAEgAAABEAAAAAAAAAEQAAABoAAAAAAAAAGgAAABkAAAAAAAAAGQAAABgAAAAAAAAAGAAA
ABcAAAAAAAAAFwAAABYAAAAAAAAAFgAAAAkAAAAAAAAACQAAAAMAAAAAAAAAAwAAAAQAAAAA
AAAABAAAAAEAAAABAAAABAAAAAoAAAABAAAACgAAAA8AAAABAAAADwAAAA4AAAABAAAADgAA
AA0AAAABAAAADQAAAAsAAAABAAAACwAAAAUAAAABAAAABQAAAAYAAAACAAAACAAAAAcAAAAD
AAAACQAAABAAAAADAAAAEAAAAAoAAAADAAAACgAAAAQAAAAFAAAACwAAAAYAAAAGAAAACwAA
AAgAAAAHAAAACAAAAAwAAAAIAAAADQAAAA4AAAAIAAAADgAAAA8AAAAIAAAADwAAAAoAAAAI
AAAACgAAABAAAAAIAAAAEAAAABEAAAAIAAAAEQAAABIAAAAIAAAAEgAAABMAAAAIAAAAEwAA
ABQAAAAIAAAAFAAAABUAAAAIAAAAFQAAAAwAAAAIAAAACwAAAA0AAAAJAAAAFgAAABAAAAAQ
AAAAFgAAABcAAAAQAAAAFwAAABgAAAAQAAAAGAAAABkAAAAQAAAAGQAAABoAAAAQAAAAGgAA
ABEAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GwAAAAQAAAB8
mRi/5FpNPtD+wD044CG/5FpNPtD+wD0wwAq//+RKPtD+wD18mRi/5FpNPgAAAAA44CG/QIwb
PQAAAAA44CG/QIwbPdD+wD0wwAq/QIwbPdD+wD0wwAq//+RKPgAAAAAwwAq/QIwbPQAAAAAq
AAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAGAAAAAAAAAAYAAAACAAAAAAAAAAIAAAAHAAAAAAAA
AAcAAAADAAAAAAAAAAMAAAABAAAAAQAAAAMAAAAEAAAAAQAAAAQAAAAFAAAAAgAAAAYAAAAI
AAAAAgAAAAgAAAAHAAAAAwAAAAcAAAAIAAAAAwAAAAgAAAAEAAAABAAAAAgAAAAGAAAABAAA
AAYAAAAFAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxsAAAAE
AAAAfJkYv+RaTT4AAAAAfJkYv+RaTT7Q/sC9OOAhv+RaTT7Q/sC9OOAhv0CMGz0AAAAAMMAK
v//kSj4AAAAAMMAKv//kSj7Q/sC9OOAhv0CMGz3Q/sC9MMAKv0CMGz0AAAAAMMAKv0CMGz3Q
/sC9KgAAAAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAABwAAAAAAAAAHAAAABAAA
AAAAAAAEAAAABQAAAAAAAAAFAAAAAQAAAAEAAAAFAAAACAAAAAEAAAAIAAAABgAAAAEAAAAG
AAAAAgAAAAIAAAAGAAAAAwAAAAMAAAAGAAAACAAAAAMAAAAIAAAABwAAAAQAAAAHAAAACAAA
AAQAAAAIAAAABQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8e
AAAABAAAAIne8T5c6Tk+onbrPIne8T5c6Tk+0P7APYne8T6KpUI+AAAAADspAD9c6Tk+AAAA
AAy1ID9c6Tk+0P7APYne8T5c6bk+0P7APYne8T5c6bk+AAAAAAy1ID9c6Tk+AAAAABD0Az9c
6bk+0P7APRD0Az9c6bk+AAAAADAAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAYAAAAAAAAABgAA
AAIAAAAAAAAAAgAAAAMAAAAAAAAAAwAAAAcAAAAAAAAABwAAAAQAAAAAAAAABAAAAAEAAAAB
AAAABAAAAAgAAAABAAAACAAAAAUAAAACAAAABgAAAAkAAAACAAAACQAAAAcAAAACAAAABwAA
AAMAAAAEAAAABwAAAAkAAAAEAAAACQAAAAgAAAAFAAAACAAAAAkAAAAFAAAACQAAAAYAAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAACJ3vE+XOk5
PtD+wL2J3vE+XOk5PqJ267yJ3vE+XOm5PtD+wL0MtSA/XOk5PtD+wL07KQA/XOk5PgAAAACJ
3vE+iqVCPgAAAACJ3vE+XOm5PgAAAAAQ9AM/XOm5PtD+wL0MtSA/XOk5PgAAAAAQ9AM/XOm5
PgAAAAAwAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAGAAAAAAAAAAYAAAACAAAAAAAAAAIAAAAH
AAAAAAAAAAcAAAADAAAAAAAAAAMAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAABAAAAAQAA
AAQAAAAFAAAAAgAAAAYAAAAJAAAAAgAAAAkAAAAHAAAAAwAAAAcAAAAJAAAAAwAAAAkAAAAI
AAAABAAAAAgAAAAJAAAABAAAAAkAAAAGAAAABAAAAAYAAAAFAAAAEAAAAAAAAAAAAAAAAAAA
AAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAAAAAAtBjlSj7Q/sA9AAAAtBjlSj4A
AAAARgA5vhjlSj7Q/sA9AAAAtA80ED7Q/sA9AAAAtDo3pj0AAAAARgA5vhjlSj4AAAAARgA5
vsJrzD3Q/sA9WLTMvIyV4j3Q/sA9AAAAtDo3pj2idus8RgA5vsJrzD0AAAAAMAAAAAAAAAAB
AAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAABwAAAAAAAAAHAAAAAwAA
AAAAAAADAAAACAAAAAAAAAAIAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAACQAAAAEAAAAJ
AAAABQAAAAIAAAAFAAAACQAAAAIAAAAJAAAABgAAAAMAAAAHAAAACAAAAAQAAAAIAAAABgAA
AAQAAAAGAAAACQAAAAYAAAAIAAAABwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAA
AAAAAAAAAAAAgD8wAAAABAAAAAAggTdSL6Y9AAAAABC4iT0AAAAyAAAAAAAggTdSL6Y9onbr
PAAggTdMSBk+AAAAABC4iT0AAAAyonbrPDyoIT7gGh48AAAAAOVKIj4AAAAyonbrPAAggTea
MxA+0P7APQAggTdc6Tk+0P7APYDkMjqAVho+AAAAAOVKIj4IRR88AAAAAOVKIj6uBzA+0P7A
PeVKIj5c6Tk+0P7APbKpqjxc6Tk+AAAAAOVKIj6uBzA+AAAAAOVKIj5c6Tk+onbrPFQAAAAA
AAAAAQAAAAQAAAAAAAAABAAAAAIAAAAAAAAAAgAAAAcAAAAAAAAABwAAAAgAAAAAAAAACAAA
AAMAAAAAAAAAAwAAAAkAAAAAAAAACQAAAA0AAAAAAAAADQAAAA4AAAAAAAAADgAAAAoAAAAA
AAAACgAAAAUAAAAAAAAABQAAAAEAAAABAAAABQAAAAYAAAABAAAABgAAAAQAAAACAAAABAAA
AAcAAAADAAAACAAAAAkAAAAEAAAABgAAAAcAAAAFAAAACgAAAAYAAAAGAAAACgAAAA4AAAAG
AAAADgAAAA8AAAAGAAAADwAAAAwAAAAGAAAADAAAAAsAAAAGAAAACwAAAAcAAAAHAAAACwAA
AAwAAAAHAAAADAAAAAgAAAAIAAAADAAAAA8AAAAIAAAADwAAAA0AAAAIAAAADQAAAAkAAAAN
AAAADwAAAA4AAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/MAAA
AAQAAAAAIIE3Ui+mPaJ267wAIIE3Ui+mPQAAAAAAIIE3mjMQPtD+wL0QuIk9AAAAMqJ267wQ
uIk9AAAAMgAAAAAAIIE3TEgZPgAAAADlSiI+AAAAMqJ267wAIIE3XOk5PtD+wL3lSiI+rgcw
PtD+wL08qCE+4BoePAAAAACA5DI6gFYaPgAAAADlSiI+CEUfPAAAAACyqao8XOk5PgAAAADl
SiI+XOk5PtD+wL3lSiI+rgcwPgAAAADlSiI+XOk5PqJ267xUAAAAAAAAAAEAAAAFAAAAAAAA
AAUAAAAHAAAAAAAAAAcAAAACAAAAAAAAAAIAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAAB
AAAAAQAAAAQAAAAJAAAAAQAAAAkAAAALAAAAAQAAAAsAAAAOAAAAAQAAAA4AAAAMAAAAAQAA
AAwAAAAKAAAAAQAAAAoAAAAFAAAAAgAAAAYAAAADAAAAAgAAAAcAAAANAAAAAgAAAA0AAAAI
AAAAAgAAAAgAAAAGAAAAAwAAAAYAAAAEAAAABAAAAAYAAAAJAAAABQAAAAoAAAAHAAAABgAA
AAgAAAANAAAABgAAAA0AAAAPAAAABgAAAA8AAAAOAAAABgAAAA4AAAALAAAABgAAAAsAAAAJ
AAAABwAAAAoAAAAMAAAABwAAAAwAAAAPAAAABwAAAA8AAAANAAAADAAAAA4AAAAPAAAAEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyoAAAAEAAAACFMiPgAAADKi
dus8CFMiPghFHzwAAAAAzc+bPgAAADIAAAAAzc+bPgAAADKidus8CFMiPq4HMD7Q/sA9CFMi
Pq4HMD4AAAAA6kqiPsCVETsAAAAA6kqiPsCVETuidus86kqiPq4HMD7Q/sA9CFMiPlzpOT7Q
/sA9CFMiPlzpOT6idus86kqiPq4HMD4AAAAA6kqiPlzpOT7Q/sA96kqiPlzpOT6idus8SAAA
AAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAACAAAAAAAAAAIAAAABAAAAAAAAAAE
AAAACQAAAAAAAAAJAAAACgAAAAAAAAAKAAAABQAAAAAAAAAFAAAAAQAAAAEAAAAFAAAACwAA
AAEAAAALAAAABgAAAAEAAAAGAAAAAgAAAAIAAAAGAAAABwAAAAIAAAAHAAAAAwAAAAMAAAAH
AAAACAAAAAQAAAAIAAAADAAAAAQAAAAMAAAACQAAAAUAAAAKAAAADQAAAAUAAAANAAAACwAA
AAYAAAALAAAADQAAAAYAAAANAAAADAAAAAYAAAAMAAAACAAAAAYAAAAIAAAABwAAAAkAAAAM
AAAADQAAAAkAAAANAAAACgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAA
AAAAgD8qAAAABAAAAAhTIj4AAAAyonbrvM3Pmz4AAAAyAAAAAAhTIj4IRR88AAAAAAhTIj6u
BzA+0P7Avc3Pmz4AAAAyonbrvOpKoj7AlRE7AAAAAAhTIj6uBzA+AAAAAAhTIj5c6Tk+0P7A
vepKoj6uBzA+0P7AvepKoj7AlRE7onbrvOpKoj6uBzA+AAAAAAhTIj5c6Tk+onbrvOpKoj5c
6Tk+0P7AvepKoj5c6Tk+onbrvEgAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAA
AAsAAAAAAAAACwAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAgAAAAAAAAACAAAAAQAAAAA
AAAABAAAAAEAAAABAAAABAAAAAkAAAABAAAACQAAAAUAAAABAAAABQAAAAoAAAABAAAACgAA
AAYAAAABAAAABgAAAAIAAAADAAAABwAAAAwAAAADAAAADAAAAAgAAAAEAAAACAAAAAkAAAAF
AAAACQAAAAgAAAAFAAAACAAAAAwAAAAFAAAADAAAAA0AAAAFAAAADQAAAAoAAAAGAAAACgAA
AA0AAAAGAAAADQAAAAsAAAAHAAAACwAAAA0AAAAHAAAADQAAAAwAAAAQAAAAAAAAAAAAAAAA
AAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/KgAAAAQAAACJevM+AAAAMsKlWL0lciA/AAAA
MgAAAACJevM+CvcPPgAAAACJevM+rgcwPtD+wL0lciA/AAAAMsKlWL38TiI/rgcwPgAAAACJ
evM+sMYwPgAAAAD8TiI/rgcwPtD+wL2JevM+XOk5PtD+wL1AtSA/XOk5PgAAAAD5q/Y+rxEz
PgAAAACJevM+XOk5PqJ267xAtSA/XOk5PtD+wL1LKQA/XOk5PgAAAABIAAAAAAAAAAEAAAAC
AAAAAAAAAAIAAAAGAAAAAAAAAAYAAAALAAAAAAAAAAsAAAAIAAAAAAAAAAgAAAADAAAAAAAA
AAMAAAAHAAAAAAAAAAcAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAHAAAAAQAAAAcAAAAF
AAAAAQAAAAUAAAAJAAAAAQAAAAkAAAANAAAAAQAAAA0AAAAKAAAAAQAAAAoAAAAGAAAAAQAA
AAYAAAACAAAAAwAAAAgAAAAMAAAAAwAAAAwAAAAHAAAABQAAAAcAAAAMAAAABQAAAAwAAAAJ
AAAABgAAAAoAAAALAAAACAAAAAsAAAANAAAACAAAAA0AAAAJAAAACAAAAAkAAAAMAAAACgAA
AA0AAAALAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyoAAAAE
AAAAiXrzPgAAADLCpVg9JXIgPwAAADLCpVg9iXrzPq4HMD7Q/sA9iXrzPgr3Dz4AAAAAJXIg
PwAAADIAAAAA/E4iP64HMD7Q/sA9iXrzPlzpOT7Q/sA9iXrzPrDGMD4AAAAA/E4iP64HMD4A
AAAAQLUgP1zpOT7Q/sA9iXrzPlzpOT6idus8+av2Pq8RMz4AAAAAQLUgP1zpOT4AAAAASykA
P1zpOT4AAAAASAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABgAAAAAAAAAG
AAAACgAAAAAAAAAKAAAABwAAAAAAAAAHAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAA
AAEAAAAEAAAACAAAAAEAAAAIAAAABQAAAAIAAAAFAAAACQAAAAIAAAAJAAAABgAAAAMAAAAH
AAAACwAAAAMAAAALAAAADQAAAAMAAAANAAAADAAAAAMAAAAMAAAACAAAAAMAAAAIAAAABAAA
AAUAAAAIAAAADAAAAAUAAAAMAAAACQAAAAYAAAAJAAAADAAAAAYAAAAMAAAADQAAAAYAAAAN
AAAACgAAAAcAAAAKAAAACwAAAAoAAAANAAAACwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAA
AAAAAAAAAAAAAAAAAAAAgD8tAAAABAAAAPpOoj7AlRE7AAAAAEtdrD4AAAAyAAAAAPpOoj7A
lRE7onbrPPpOoj6uBzA+AAAAAEtdrD4AAAAywqVYPWly8z4K9w8+AAAAAGly8z4AAAAywqVY
PQxbqz7A2rY7wqVYPfpOoj6uBzA+0P7APfpOoj5c6Tk+onbrPGly8z6wxjA+AAAAAGly8z6u
BzA+0P7APfpOoj5c6Tk+0P7APWly8z5c6Tk+onbrPGly8z5c6Tk+0P7APU4AAAAAAAAAAQAA
AAQAAAAAAAAABAAAAAIAAAAAAAAAAgAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAAAkAAAAA
AAAACQAAAAMAAAAAAAAAAwAAAAoAAAAAAAAACgAAAAUAAAAAAAAABQAAAAEAAAABAAAABQAA
AAYAAAABAAAABgAAAAQAAAACAAAABAAAAAcAAAACAAAABwAAAAgAAAADAAAACQAAAAoAAAAE
AAAABgAAAAsAAAAEAAAACwAAAAgAAAAEAAAACAAAAAcAAAAFAAAACgAAAA0AAAAFAAAADQAA
AA4AAAAFAAAADgAAAAsAAAAFAAAACwAAAAYAAAAIAAAACwAAAA4AAAAIAAAADgAAAAwAAAAJ
AAAADAAAAA4AAAAJAAAADgAAAA0AAAAJAAAADQAAAAoAAAAQAAAAAAAAAAAAAAAAAAAAAAAA
ABAAAAAAAAAAAAAAAAAAAAAAAIA/LQAAAAQAAAD6TqI+wJURO6J267wMW6s+wNq2O8KlWL1L
Xaw+AAAAMsKlWL36TqI+wJUROwAAAAD6TqI+rgcwPtD+wL1LXaw+AAAAMgAAAABpcvM+AAAA
MsKlWL36TqI+rgcwPgAAAAD6TqI+XOk5PtD+wL1pcvM+rgcwPtD+wL1pcvM+CvcPPgAAAABp
cvM+sMYwPgAAAAD6TqI+XOk5PqJ267xpcvM+XOk5PtD+wL1pcvM+XOk5PqJ267xOAAAAAAAA
AAEAAAACAAAAAAAAAAIAAAAFAAAAAAAAAAUAAAADAAAAAAAAAAMAAAAHAAAAAAAAAAcAAAAM
AAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAACAAAAAgAA
AAQAAAAJAAAAAgAAAAkAAAAGAAAAAgAAAAYAAAAFAAAAAwAAAAUAAAAKAAAAAwAAAAoAAAAL
AAAAAwAAAAsAAAAHAAAABAAAAAgAAAANAAAABAAAAA0AAAAJAAAABQAAAAYAAAAKAAAABgAA
AAkAAAANAAAABgAAAA0AAAAOAAAABgAAAA4AAAALAAAABgAAAAsAAAAKAAAABwAAAAsAAAAM
AAAACAAAAAwAAAAOAAAACAAAAA4AAAANAAAACwAAAA4AAAAMAAAAEAAAAAAAAAAAAAAAAAAA
AAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAA+FCiPlzpOT6idus8+FCiPlzpOT7Q
/sA9+FCiPoqlQj4AAAAAht7xPlzpOT6idus8ht7xPlzpOT7Q/sA9+FCiPlzpuT7Q/sA9+FCi
PlzpuT4AAAAAht7xPoqlQj4AAAAAht7xPlzpuT7Q/sA9ht7xPlzpuT4AAAAAMAAAAAAAAAAB
AAAABQAAAAAAAAAFAAAABgAAAAAAAAAGAAAAAgAAAAAAAAACAAAABwAAAAAAAAAHAAAAAwAA
AAAAAAADAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAACAAAAAEAAAAIAAAABQAAAAIAAAAG
AAAACQAAAAIAAAAJAAAABwAAAAMAAAAHAAAACQAAAAMAAAAJAAAACAAAAAMAAAAIAAAABAAA
AAUAAAAIAAAACQAAAAUAAAAJAAAABgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAA
AAAAAAAAAAAAgD8eAAAABAAAAPhQoj5c6Tk+0P7AvYbe8T5c6Tk+0P7AvfhQoj5c6Tk+onbr
vPhQoj5c6bk+0P7AvYbe8T5c6Tk+onbrvIbe8T5c6bk+0P7AvfhQoj6KpUI+AAAAAPhQoj5c
6bk+AAAAAIbe8T6KpUI+AAAAAIbe8T5c6bk+AAAAADAAAAAAAAAAAQAAAAQAAAAAAAAABAAA
AAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAUAAAAA
AAAABQAAAAEAAAABAAAABQAAAAkAAAABAAAACQAAAAgAAAABAAAACAAAAAQAAAACAAAABAAA
AAgAAAACAAAACAAAAAYAAAADAAAABwAAAAkAAAADAAAACQAAAAUAAAAGAAAACAAAAAkAAAAG
AAAACQAAAAcAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAA
AAQAAAAIUyI+XOk5PqJ26zwIUyI+XOk5PtD+wD0IUyI+iqVCPgAAAADqSqI+XOk5PqJ26zzq
SqI+XOk5PtD+wD0IUyI+XOm5PtD+wD0IUyI+XOm5PgAAAADqSqI+iqVCPgAAAADqSqI+XOm5
PtD+wD3qSqI+XOm5PgAAAAAwAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAGAAAAAAAAAAYAAAAC
AAAAAAAAAAIAAAAHAAAAAAAAAAcAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAA
AAQAAAAIAAAAAQAAAAgAAAAFAAAAAgAAAAYAAAAJAAAAAgAAAAkAAAAHAAAAAwAAAAcAAAAJ
AAAAAwAAAAkAAAAIAAAAAwAAAAgAAAAEAAAABQAAAAgAAAAJAAAABQAAAAkAAAAGAAAAEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAACFMiPlzpOT7Q
/sC96kqiPlzpOT7Q/sC9CFMiPlzpOT6iduu8CFMiPlzpuT7Q/sC96kqiPlzpOT6iduu86kqi
PlzpuT7Q/sC9CFMiPoqlQj4AAAAACFMiPlzpuT4AAAAA6kqiPoqlQj4AAAAA6kqiPlzpuT4A
AAAAMAAAAAAAAAABAAAABAAAAAAAAAAEAAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAABwAA
AAAAAAAHAAAAAwAAAAAAAAADAAAABQAAAAAAAAAFAAAAAQAAAAEAAAAFAAAACQAAAAEAAAAJ
AAAACAAAAAEAAAAIAAAABAAAAAIAAAAEAAAACAAAAAIAAAAIAAAABgAAAAMAAAAHAAAACQAA
AAMAAAAJAAAABQAAAAYAAAAIAAAACQAAAAYAAAAJAAAABwAAABAAAAAAAAAAAAAAAAAAAAAA
AAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAAAggTdc6Tk+0P7APbKpqjxc6Tk+AAAA
AOVKIj5c6Tk+0P7APQAggTdc6bk+0P7APQAggTeY6Eo+AAAAAOVKIj6KpUI+AAAAAOVKIj5c
6Tk+onbrPOVKIj5c6bk+0P7APQAggTdc6bk+AAAAAOVKIj5c6bk+AAAAADAAAAAAAAAAAQAA
AAYAAAAAAAAABgAAAAIAAAAAAAAAAgAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAgAAAAA
AAAACAAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAgAAAABAAAACAAAAAkAAAABAAAACQAA
AAUAAAABAAAABQAAAAYAAAACAAAABgAAAAUAAAACAAAABQAAAAkAAAACAAAACQAAAAcAAAAD
AAAABwAAAAkAAAADAAAACQAAAAgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAA
AAAAAAAAAIA/HgAAAAQAAAAAIIE3XOk5PtD+wL3lSiI+XOk5PtD+wL2yqao8XOk5PgAAAAAA
IIE3mOhKPgAAAAAAIIE3XOm5PtD+wL3lSiI+XOk5PqJ267zlSiI+XOm5PtD+wL3lSiI+iqVC
PgAAAAAAIIE3XOm5PgAAAADlSiI+XOm5PgAAAAAwAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAC
AAAAAAAAAAIAAAADAAAAAAAAAAMAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAGAAAAAAAA
AAYAAAABAAAAAQAAAAYAAAAJAAAAAQAAAAkAAAAHAAAAAQAAAAcAAAAFAAAAAgAAAAUAAAAH
AAAAAgAAAAcAAAAJAAAAAgAAAAkAAAAIAAAAAgAAAAgAAAADAAAABAAAAAgAAAAJAAAABAAA
AAkAAAAGAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAE
AAAA6AQ5vhjlSj7Q/sA96AQ5vnhozD3Q/sA96AQ5vhjlSj7Q/sC9QgC5vhjlSj7Q/sA9HFqJ
vkCMGz3Q/sA96AQ5vnhozD3Q/sC9QgC5vhjlSj7Q/sC9QgC5vkCMGz3Q/sA9HFqJvkCMGz3Q
/sC9QgC5vkCMGz3Q/sC9MAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABgAA
AAAAAAAGAAAAAwAAAAAAAAADAAAABwAAAAAAAAAHAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAE
AAAACAAAAAEAAAAIAAAABQAAAAIAAAAFAAAACAAAAAIAAAAIAAAACQAAAAIAAAAJAAAABgAA
AAMAAAAGAAAACQAAAAMAAAAJAAAABwAAAAQAAAAHAAAACQAAAAQAAAAJAAAACAAAABAAAAAA
AAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAEIAub4Y5Uo+0P7A
PUIAub5AjBs90P7APUIAub4Y5Uo+0P7AvTDACr8Y5Uo+0P7APTDACr9AjBs90P7APUIAub5A
jBs90P7AvTDACr8Y5Uo+0P7AvTDACr9AjBs90P7AvSQAAAAAAAAAAQAAAAUAAAAAAAAABQAA
AAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAEAAAAB
AAAABAAAAAcAAAABAAAABwAAAAUAAAACAAAABQAAAAcAAAACAAAABwAAAAYAAAADAAAABgAA
AAcAAAADAAAABwAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAA
AIA/WgAAAAQAAAAGO8o+/BMAvgOnWL0GO8o+/BMAvhOoWD0GO8o+AACAsgOnWL1giNc+ZKWt
vgOnWL0GO8o+AACAshOoWD1giNc+ZKWtvhOoWD30cCA/AACAsgOnWL2XxNo+4Oy0vgOnWL30
cCA/AACAshOoWD2XxNo+4Oy0vhOoWD0oAiY/+CsDvQOnWL1MoPA+XOm5vgOnWL0oAiY/+CsD
vROoWD1MoPA+XOm5vhOoWD3HOi8/i4/cvQOnWL1xYQc/hzy3vgOnWL3HOi8/i4/cvROoWD1x
YQc/hzy3vhOoWD159jU/pUE5vgOnWL2oRx0/iJyvvgOnWL159jU/pUE5vhOoWD2oRx0/iJyv
vhOoWD0i/jg/wx2CvgOnWL0OWyw/ScmnvgOnWL0i/jg/wx2CvhOoWD0OWyw/ScmnvhOoWD0t
wTg/RayOvgOnWL3ORjc/djGbvgOnWL0twTg/RayOvhOoWD3ORjc/djGbvhOoWD2oAAAAAAAA
AAEAAAAEAAAAAAAAAAQAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAAKAAAAAAAAAAoAAAAO
AAAAAAAAAA4AAAASAAAAAAAAABIAAAAWAAAAAAAAABYAAAAaAAAAAAAAABoAAAAbAAAAAAAA
ABsAAAAXAAAAAAAAABcAAAATAAAAAAAAABMAAAAPAAAAAAAAAA8AAAALAAAAAAAAAAsAAAAH
AAAAAAAAAAcAAAADAAAAAAAAAAMAAAAFAAAAAAAAAAUAAAABAAAAAQAAAAUAAAAJAAAAAQAA
AAkAAAANAAAAAQAAAA0AAAARAAAAAQAAABEAAAAVAAAAAQAAABUAAAAZAAAAAQAAABkAAAAd
AAAAAQAAAB0AAAAcAAAAAQAAABwAAAAYAAAAAQAAABgAAAAUAAAAAQAAABQAAAAQAAAAAQAA
ABAAAAAMAAAAAQAAAAwAAAAIAAAAAQAAAAgAAAAEAAAAAgAAAAQAAAAIAAAAAgAAAAgAAAAG
AAAAAwAAAAcAAAAJAAAAAwAAAAkAAAAFAAAABgAAAAgAAAAMAAAABgAAAAwAAAAKAAAABwAA
AAsAAAANAAAABwAAAA0AAAAJAAAACgAAAAwAAAAQAAAACgAAABAAAAAOAAAACwAAAA8AAAAR
AAAACwAAABEAAAANAAAADgAAABAAAAAUAAAADgAAABQAAAASAAAADwAAABMAAAAVAAAADwAA
ABUAAAARAAAAEgAAABQAAAAYAAAAEgAAABgAAAAWAAAAEwAAABcAAAAZAAAAEwAAABkAAAAV
AAAAFgAAABgAAAAcAAAAFgAAABwAAAAaAAAAFwAAABsAAAAdAAAAFwAAAB0AAAAZAAAAGgAA
ABwAAAAdAAAAGgAAAB0AAAAbAAAA</SharedString>
		<SharedString md5="x21M00F/J+XHo9NbCyDDnQ==">Q1NHUEhTBwAAAALR04BG2Z5zt3CSyTllHT65Ir6iSkC+Tz6at0lAURM4SgDALsE4FDhKEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxsAAAAEAAAAAADwQAAAAAAA
AAAAAADwQP7/R0EAYKA6AADwQAAAAAAAAEhBAGBAOv1RBUH7TAVBAAAAtabCMUH7TAVBAAAA
tf7/R0H7TAVBAADwQP7/R0H7TAVBAADwQP1RBUEAAEhBAGBAOv1RBUEAAEhBKgAAAAAAAAAB
AAAABgAAAAAAAAAGAAAABwAAAAAAAAAHAAAAAgAAAAAAAAACAAAACAAAAAAAAAAIAAAAAwAA
AAAAAAADAAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAAAAQAAAAEAAAAFAAAABgAAAAIAAAAH
AAAACAAAAAMAAAAIAAAABAAAAAQAAAAIAAAABQAAAAUAAAAIAAAABwAAAAUAAAAHAAAABgAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAAAA8MAA
AAAA//9HQQAA8MAAAAAAAAAAAAAA8MD7TAXB//9HQQBgQLr7TAXB//9HQQBgQLr7TAXB+kwF
QQAAADUAAEjB+kwFQQAA8MAAAEjBAAAAAAAA8MAAAEjB+kwFQSQAAAAAAAAAAQAAAAYAAAAA
AAAABgAAAAcAAAAAAAAABwAAAAIAAAAAAAAAAgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAA
AAEAAAABAAAABAAAAAUAAAABAAAABQAAAAYAAAACAAAABwAAAAUAAAACAAAABQAAAAMAAAAD
AAAABQAAAAQAAAAFAAAABwAAAAYAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAA
AAAAAAAAAIA/GAAAAAQAAAAAAPBAAAAAAP//R0EAAPBAAAAAAAAAAAAAAAC1+0wFwf//R0EA
APBA+0wFwf//R0EAAPBAAABIwQAAAAAAYEA6+0wFwfpMBUEAYEA6AABIwfpMBUEAAPBAAABI
wfpMBUEkAAAAAAAAAAEAAAACAAAAAAAAAAIAAAADAAAAAAAAAAMAAAAHAAAAAAAAAAcAAAAE
AAAAAAAAAAQAAAABAAAAAQAAAAQAAAAGAAAAAQAAAAYAAAAFAAAAAQAAAAUAAAACAAAAAgAA
AAUAAAAGAAAAAgAAAAYAAAAHAAAAAgAAAAcAAAADAAAABAAAAAcAAAAGAAAAEAAAAAAAAAAA
AAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxsAAAAEAAAAAADwwP//R8H7TAXBAGBA
uv//R8H7TAXBAADwwP//R8EAAAAAAADwwPpMBcEAAEjBAAAANfpMBcEAAEjBAAAANfpMBcGl
vTHBAGBAuvpMBcH7TAXBAADwwAAAAAAAAAAAAADwwAAAAAAAAEjBKgAAAAAAAAABAAAAAgAA
AAAAAAACAAAABwAAAAAAAAAHAAAACAAAAAAAAAAIAAAAAwAAAAAAAAADAAAABAAAAAAAAAAE
AAAAAQAAAAEAAAAEAAAABQAAAAEAAAAFAAAABgAAAAEAAAAGAAAABwAAAAEAAAAHAAAAAgAA
AAMAAAAIAAAABAAAAAQAAAAIAAAABwAAAAQAAAAHAAAABQAAAAUAAAAHAAAABgAAABAAAAAA
AAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAAAAgLT5TAVBAABI
QQCAQLr+/0dB/1EFQQAA8MD5TAVBAABIQQAA8MAAIKA6AABIQQAA8MAAAAC2AAAANgAAgLT5
TAVB/1EFQQAA8MD+/0dB/1EFQQAA8MD+/0dBAAAANiQAAAAAAAAAAQAAAAYAAAAAAAAABgAA
AAIAAAAAAAAAAgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAUAAAAAAAAABQAAAAEAAAAB
AAAABQAAAAcAAAABAAAABwAAAAYAAAACAAAABgAAAAcAAAACAAAABwAAAAQAAAACAAAABAAA
AAMAAAAEAAAABwAAAAUAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAA
AIA/GAAAAAQAAAAAAPDAAABIQQAAADYAAIC0AABIQflMBcEAAPDAAABIQflMBcEAAPDAAAAA
tgAAADYAAIC0+kwFQflMBcEAAIC0+kwFQf7/R8EAAPDA+kwFQf7/R8EAAPDAACCgOv7/R8Ek
AAAAAAAAAAEAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAAHAAAAAAAAAAcAAAADAAAAAAAA
AAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAFAAAAAQAAAAUAAAAGAAAAAQAAAAYAAAAC
AAAAAwAAAAcAAAAFAAAAAwAAAAUAAAAEAAAABQAAAAcAAAAGAAAAEAAAAAAAAAAAAAAAAAAA
AAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAAAACANP//R8H7TAXBAIBAOvpMBcEA
AEjBAADwQP//R8H7TAXBAADwQP//R8EAAAAAAACANPpMBcH7TAXBAADwQPpMBcEAAEjBAADw
QAAAAAAAAEjBAADwQAAAAAAAAAAAJAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAAC
AAAAAwAAAAAAAAADAAAABwAAAAAAAAAHAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAABgAA
AAEAAAAGAAAABQAAAAIAAAAFAAAABgAAAAIAAAAGAAAABwAAAAIAAAAHAAAAAwAAAAQAAAAH
AAAABgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAA
AAAA8EAAAAAA/v9HwQAAgDT6TAVB/v9HwQAA8ED6TAVB/v9HwQAA8EAAAAAAAAAANgAAgDT6
TAVB+UwFwQAAgDT//0dB+UwFwQAA8ED//0dB+UwFwQAA8ED//0dBAAAANiQAAAAAAAAAAQAA
AAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAQAAAAA
AAAABAAAAAEAAAABAAAABAAAAAUAAAABAAAABQAAAAYAAAABAAAABgAAAAIAAAADAAAABwAA
AAUAAAADAAAABQAAAAQAAAAFAAAABwAAAAYAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA
AAAAAAAAAAAAAAAAAIA/GAAAAAQAAAD//+9AAgVIwQDAVbr//+9AAgVIwQFSBcH//+/AAgVI
wQDAVbr//+9A///HwQDAVbr//+9A/PrHwQFSBcH//+/AAgVIwQFSBcH//+/A///HwQDAVbr/
/+/A/PrHwQFSBcEkAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAACAAAAAAAAAAIAAAAGAAAAAAAA
AAYAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAHAAAAAQAAAAcAAAAF
AAAAAgAAAAUAAAAHAAAAAgAAAAcAAAAGAAAAAwAAAAYAAAAHAAAAAwAAAAcAAAAEAAAAEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAA///vwAFSBcEC
BUhB///vwADAVboCBUhB///vQAFSBcECBUhB///vwAFSBcH8+sdB///vwADAVbr//8dB///v
QADAVboCBUhB///vQAFSBcH8+sdB///vQADAVbr//8dBJAAAAAAAAAABAAAABQAAAAAAAAAF
AAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAA
AAEAAAAEAAAABwAAAAEAAAAHAAAABQAAAAIAAAAFAAAABwAAAAIAAAAHAAAABgAAAAMAAAAG
AAAABwAAAAMAAAAHAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAA
AAAAgD8YAAAABAAAAP//78AAwFU6///Hwf//78ABUgVBfv3Hwf//70AAwFU6///Hwf//78AA
wFU6/v9Hwf//78ABUgVB/v9Hwf//70ABUgVBfv3Hwf//70AAwFU6/v9Hwf//70ABUgVB/v9H
wSQAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAMAAAAA
AAAAAwAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAcAAAABAAAABwAAAAUAAAACAAAABQAA
AAcAAAACAAAABwAAAAYAAAADAAAABgAAAAcAAAADAAAABwAAAAQAAAAQAAAAAAAAAAAAAAAA
AAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAAAAQAAAD//+9Af/3HQQAAADb//+9Af/3H
QaROBcH//+/Af/3HQQAAADb//+9AAQVIQQAAADb//+9AAQVIQVJVBcH//+/Af/3HQaROBcH/
/+/AAQVIQQAAADb//+/AAQVIQVJVBcEkAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAACAAAAAAAA
AAIAAAAGAAAAAAAAAAYAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAH
AAAAAQAAAAcAAAAFAAAAAgAAAAUAAAAHAAAAAgAAAAcAAAAGAAAAAwAAAAYAAAAHAAAAAwAA
AAcAAAAEAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxsAAAAE
AAAA///vwAAAAAAAAEhB///vwFJVBUEAAEhB///vQAAAAAAAAEhB///vwAAAAAD9+sdB///v
wKROBUEAAMhB//9vwFJVBUEAAEhB///vQKROBUEAAEhB///vQAAAAAD9+sdB///vQKROBUEA
AMhBKgAAAAAAAAABAAAABQAAAAAAAAAFAAAABgAAAAAAAAAGAAAAAgAAAAAAAAACAAAABwAA
AAAAAAAHAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAACAAAAAEAAAAI
AAAABQAAAAIAAAAGAAAACAAAAAIAAAAIAAAABwAAAAMAAAAHAAAACAAAAAMAAAAIAAAABAAA
AAUAAAAIAAAABgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8b
AAAABAAAAP//78CkTgXBAADIwf//78AAAAAA/frHwf//70CkTgXBAADIwf//78BSVQXBAABI
wf//78AAAAAAAABIwf//70AAAAAA/frHwf//b0BSVQXBAABIwf//70CkTgXBAABIwf//70AA
AAAAAABIwSoAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAA
AAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAgAAAABAAAACAAAAAUAAAAC
AAAABQAAAAgAAAACAAAACAAAAAcAAAACAAAABwAAAAYAAAADAAAABgAAAAcAAAADAAAABwAA
AAgAAAADAAAACAAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAA
AIA/GwAAAAQAAAD//+9AAABIwaROBUH//+9AAABIwQAAAAD//29AAABIwVJVBUH//+9AAADI
waROBUH//+9A/frHwQAAAAD//+/AAABIwQAAAAD//+/AAABIwVJVBUH//+/AAADIwaROBUH/
/+/A/frHwQAAAAAqAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAGAAAAAAAAAAYAAAACAAAAAAAA
AAIAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAIAAAAAQAAAAgAAAAF
AAAAAgAAAAYAAAAHAAAAAgAAAAcAAAADAAAAAwAAAAcAAAAIAAAAAwAAAAgAAAAEAAAABQAA
AAgAAAAHAAAABQAAAAcAAAAGAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAA
AAAAAACAPxgAAAAEAAAA///vQP//x0EAAAA2///vQH79x0FYVQVB///vQP7/R0EAAAA2///v
wP//x0EAAAA2///vwH79x0FYVQVB///vQP7/R0GpTgVB///vwP7/R0EAAAA2///vwP7/R0Gp
TgVBJAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAAAwAA
AAAAAAADAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAABwAAAAEAAAAHAAAABQAAAAIAAAAF
AAAABwAAAAIAAAAHAAAABgAAAAMAAAAGAAAABwAAAAMAAAAHAAAABAAAAA==</SharedString>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>